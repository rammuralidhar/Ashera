//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ramm/git/Ashera/AsheraAndroidParser/freemarker/freemarker/template/Template.java
//

#ifndef _FreemarkerTemplateTemplate_H_
#define _FreemarkerTemplateTemplate_H_

#include "Configurable.h"
#include "J2ObjC_header.h"
#include "ParseException.h"

@class FreemarkerCoreEnvironment;
@class FreemarkerCoreLibraryLoad;
@class FreemarkerCoreMacro;
@class FreemarkerCoreTemplateElement;
@class FreemarkerTemplateConfiguration;
@class FreemarkerTemplateVersion;
@class JavaIoPrintStream;
@class JavaIoReader;
@class JavaIoWriter;
@protocol FreemarkerTemplateObjectWrapper;
@protocol FreemarkerTemplateTemplateNodeModel;
@protocol JavaUtilList;
@protocol JavaUtilMap;

/**
 @brief <p>Stores an already parsed template, ready to be processed (rendered) for unlimited times, possibly from multiple threads.
 <p>Typically, you will use Configuration#getTemplate(String) to create/get Template objects, so you don't construct them directly. But you can also construct a template from a Reader or a String that contains the template source code. But then it's important to know that while the resulting Template is efficient for later processing, creating a new Template itself is relatively expensive. So try to re-use Template objects if possible. Configuration#getTemplate(String) does that (caching Template -s) for you, but the constructor of course doesn't, so it's up to you to solve then. <p>Objects of this class meant to be handled as immutable and thus thread-safe. However, it has some setter methods for changing FreeMarker settings. Those must not be used while the template is being processed, or if the template object is already accessible from multiple threads.
 */
@interface FreemarkerTemplateTemplate : FreemarkerCoreConfigurable

#pragma mark Public

/**
 @brief Equivalent to #Template(String,Reader,Configuration) Template(name, reader, null) .
 */
- (instancetype)initWithNSString:(NSString *)name
                withJavaIoReader:(JavaIoReader *)reader;

/**
 @brief Same as #Template(String,String,Reader,Configuration) with <code>null</code>  <code>sourceName</code> parameter.
 */
- (instancetype)initWithNSString:(NSString *)name
                withJavaIoReader:(JavaIoReader *)reader
withFreemarkerTemplateConfiguration:(FreemarkerTemplateConfiguration *)cfg;

/**
 @brief Convenience constructor for #Template(String,String,Reader,Configuration,String) Template(name, null, reader, cfg, encoding) .
 */
- (instancetype)initWithNSString:(NSString *)name
                withJavaIoReader:(JavaIoReader *)reader
withFreemarkerTemplateConfiguration:(FreemarkerTemplateConfiguration *)cfg
                    withNSString:(NSString *)encoding;

/**
 @brief Convenience constructor for #Template(String,Reader,Configuration) Template(name, new StringReader(reader), cfg) .
 @since 2.3.20
 */
- (instancetype)initWithNSString:(NSString *)name
                    withNSString:(NSString *)sourceCode
withFreemarkerTemplateConfiguration:(FreemarkerTemplateConfiguration *)cfg;

/**
 @brief Constructs a template from a character stream.
 Note that this is a relatively expensive operation; where higher performance matters, you should re-use (cache) Template instances instead of re-creating them from the same source again and again. ( Configuration#getTemplate(String) and its overloads already do such reuse. )
 @param name The path of the template file relatively to the (virtual) directory that you use to store the templates (except if #Template(String,String,Reader,Configuration,String) sourceName differs from it). Shouldn't start with <code>'/'</code> . Should use <code>'/'</code> , not <code>'\'</code> . Check #getName() to see how the name will be used. The name should be independent of the actual storage mechanism and physical location as far as possible. Even when the templates are stored straightforwardly in real files (they often aren't; see TemplateLoader ), the name shouldn't be an absolute file path. Like if the template is stored in <code>"/www/templates/forum/main.ftl"</code> , and you are using <code>"/www/templates/"</code> as the template root directory via Configuration#setDirectoryForTemplateLoading(java.io.File) , then the template name will be <code>"forum/main.ftl"</code> . The name can be <code>null</code> (should be used for template made on-the-fly instead of being loaded from somewhere), in which case relative paths in it will be relative to the template root directory (and here again, it's the TemplateLoader that knows what that "physically" means).
 @param sourceName See #getSourceName() for the meaning. Can be <code>null</code> , in which case #getSourceName() will return the same as #getName() .
 @param reader The character stream to read from. It will always be closed ( Reader#close() ) by this method.
 @param cfg The Configuration object that this Template is associated with. If this is <code>null</code> , the "default" Configuration object is used, which is highly discouraged, because it can easily lead to erroneous, unpredictable behavior. (See more Configuration#getDefaultConfiguration() here... )
 @since 2.3.22
 */
- (instancetype)initWithNSString:(NSString *)name
                    withNSString:(NSString *)sourceName
                withJavaIoReader:(JavaIoReader *)reader
withFreemarkerTemplateConfiguration:(FreemarkerTemplateConfiguration *)cfg;

/**
 @brief Same as #Template(String,String,Reader,Configuration) , but also specifies the template's encoding (not recommended).
 @param encoding This is the encoding that we are supposed to be using. But it's not really necessary because we have a Reader which is already decoded, but it's kept as meta-info. It also has an impact when <code>#include</code> -ing/ <code>#import</code> -ing another template from this template, as its default encoding will be this. But this behavior of said directives is considered to be harmful, and will be probably phased out. Until that, it's better to leave this on <code>null</code> , so that the encoding will come from the Configuration . Note that if this is non- <code>null</code> and there's an <code>#ftl</code> header with encoding, they must match, or else a WrongEncodingException is thrown.
 @since 2.3.22
 */
- (instancetype)initWithNSString:(NSString *)name
                    withNSString:(NSString *)sourceName
                withJavaIoReader:(JavaIoReader *)reader
withFreemarkerTemplateConfiguration:(FreemarkerTemplateConfiguration *)cfg
                    withNSString:(NSString *)encoding;

/**
 @brief Called by code internally to maintain a list of imports
 */
- (void)addImportWithFreemarkerCoreLibraryLoad:(FreemarkerCoreLibraryLoad *)ll;

/**
 @brief Called by code internally to maintain a table of macros
 */
- (void)addMacroWithFreemarkerCoreMacro:(FreemarkerCoreMacro *)macro;

/**
 @brief This is used internally.
 */
- (void)addPrefixNSMappingWithNSString:(NSString *)prefix
                          withNSString:(NSString *)nsURI;

/**
 @brief Same as #createProcessingEnvironment(Object,Writer,ObjectWrapper) createProcessingEnvironment(dataModel, out, null) .
 */
- (FreemarkerCoreEnvironment *)createProcessingEnvironmentWithId:(id)dataModel
                                                withJavaIoWriter:(JavaIoWriter *)outArg;

/**
 @brief Creates a freemarker.core.Environment Environment object, using this template, the data-model provided as parameter.
 You have to call Environment#process() on the return value to set off the actual rendering. <p>Use this method if you want to do some special initialization on the Environment before template processing, or if you want to read the Environment after template processing. Otherwise using Template#process(Object,Writer) is simpler. <p>Example: <pre> Environment env = myTemplate.createProcessingEnvironment(root, out, null); env.process();</pre> <p>The above is equivalent with this: <pre> myTemplate.process(root, out);</pre> <p>But with <tt>createProcessingEnvironment</tt>, you can manipulate the environment before and after the processing: <pre> Environment env = myTemplate.createProcessingEnvironment(root, out); env.setLocale(myUsersPreferredLocale); env.setTimeZone(myUsersPreferredTimezone); env.process();  // output is rendered here TemplateModel x = env.getVariable("x");  // read back a variable set by the template</pre>
 @param dataModel the holder of the variables visible from all templates; see #process(Object,Writer) for more details.
 @param wrapper The ObjectWrapper to use to wrap objects into TemplateModel instances. Normally you left it <code>null</code> , in which case Configurable#getObjectWrapper() will be used.
 @param out The Writer where the output of the template will go; see #process(Object,Writer) for more details.
 @return the Environment object created for processing. Call Environment#process() to process the template.
 @throws TemplateException if an exception occurs while setting up the Environment object.
 @throws IOException if an exception occurs doing any auto-imports
 */
- (FreemarkerCoreEnvironment *)createProcessingEnvironmentWithId:(id)dataModel
                                                withJavaIoWriter:(JavaIoWriter *)outArg
                             withFreemarkerTemplateObjectWrapper:(id<FreemarkerTemplateObjectWrapper>)wrapper;

/**
 @brief Dump the raw template in canonical form.
 */
- (void)dumpWithJavaIoPrintStream:(JavaIoPrintStream *)ps;

/**
 @brief Dump the raw template in canonical form.
 */
- (void)dumpWithJavaIoWriter:(JavaIoWriter *)outArg;

/**
 @brief Returns the naming convention the parser has chosen for this template.
 If it could be determined, it's Configuration#LEGACY_NAMING_CONVENTION or Configuration#CAMEL_CASE_NAMING_CONVENTION . If it couldn't be determined (like because there no identifier that's part of the template language was used where the naming convention matters), this returns whatever the default is in the current configuration, so it's maybe Configuration#AUTO_DETECT_TAG_SYNTAX .
 @since 2.3.23
 */
- (jint)getActualNamingConvention;

/**
 @brief Returns the tag syntax the parser has chosen for this template.
 If the syntax could be determined, it's Configuration#SQUARE_BRACKET_TAG_SYNTAX or Configuration#ANGLE_BRACKET_TAG_SYNTAX . If the syntax couldn't be determined (like because there was no tags in the template, or it was a plain text template), this returns whatever the default is in the current configuration, so it's maybe Configuration#AUTO_DETECT_TAG_SYNTAX .
 @since 2.3.20
 */
- (jint)getActualTagSyntax;

/**
 @brief Returns the Configuration object associated with this template.
 */
- (FreemarkerTemplateConfiguration *)getConfiguration;

/**
 @brief Gets the custom lookup condition with which this template was found.
 See the <code>customLookupCondition</code> parameter of Configuration#getTemplate(String,java.util.Locale,Object,String,boolean,boolean) for more explanation.
 @since 2.3.22
 */
- (id)getCustomLookupCondition;

- (NSString *)getDefaultNS;

/**
 @brief Returns the default character encoding used for reading included files.
 */
- (NSString *)getEncoding;

/**
 */
- (id<JavaUtilList>)getImports;

/**
 */
- (id<JavaUtilMap>)getMacros;

/**
 @brief The usually path-like (or URL-like) identifier of the template, or possibly <code>null</code> for non-stored templates.
 It usually looks like a relative UN*X path; it should use <code>/</code> , not <code>\</code> , and shouldn't start with <code>/</code> (but there are no hard guarantees). It's not a real path in a file-system, it's just a name that a TemplateLoader used to load the backing resource (in simple cases; actually that name is #getSourceName() , but see it there). Or, it can also be a name that was never used to load the template (directly created with #Template(String,Reader,Configuration) ). Even if the templates are stored straightforwardly in files, this is relative to the base directory of the TemplateLoader . So it really could be anything, except that it has importance in these situations: <p> Relative paths to other templates in this template will be resolved relatively to the directory part of this. Like if the template name is <code>"foo/this.ftl"</code> , then <code><#include "other.ftl"></code> gets the template with name <code>"foo/other.ftl"</code> . </p> <p> You should not use this name to indicate error locations, or to find the actual templates in general, because localized lookup, acquisition and other lookup strategies can transform names before they get to the TemplateLoader (the template storage) mechanism. Use #getSourceName() for these purposes. </p> <p> Some frameworks use URL-like template names like <code>"someSchema://foo/bar.ftl"</code> . FreeMarker understands this notation, so an absolute path like <code>"/baaz.ftl"</code> in that template will be resolved too <code>"someSchema://baaz.ftl"</code> .
 */
- (NSString *)getName;

/**
 @return the NamespaceUri mapped to this prefix in this template. (Or null if there is none.)
 */
- (NSString *)getNamespaceForPrefixWithNSString:(NSString *)prefix;

/**
 @brief Same as #getPlainTextTemplate(String,String,String,Configuration) with <code>null</code>  <code>sourceName</code> argument.
 */
+ (FreemarkerTemplateTemplate *)getPlainTextTemplateWithNSString:(NSString *)name
                                                    withNSString:(NSString *)content
                             withFreemarkerTemplateConfiguration:(FreemarkerTemplateConfiguration *)config;

/**
 @brief Creates a Template that only contains a single block of static text, no dynamic content.
 @param name See #getName for more details.
 @param sourceName See #getSourceName for more details. If <code>null</code> , it will be the same as the <code>name</code> .
 @param content the block of text that this template represents
 @param config the configuration to which this template belongs
 @since 2.3.22
 */
+ (FreemarkerTemplateTemplate *)getPlainTextTemplateWithNSString:(NSString *)name
                                                    withNSString:(NSString *)sourceName
                                                    withNSString:(NSString *)content
                             withFreemarkerTemplateConfiguration:(FreemarkerTemplateConfiguration *)config;

/**
 @return the prefixed name, based on the ns_prefixes defined in this template's header for the local name and node namespace passed in as parameters.
 */
- (NSString *)getPrefixedNameWithNSString:(NSString *)localName
                             withNSString:(NSString *)nsURI;

/**
 @return the prefix mapped to this nsURI in this template. (Or null if there is none.)
 */
- (NSString *)getPrefixForNamespaceWithNSString:(NSString *)nsURI;

/**
 */
- (FreemarkerCoreTemplateElement *)getRootTreeNode;

/**
 @brief Returns the template source at the location specified by the coordinates given, or <code>null</code> if unavailable.
 @param beginColumn the first column of the requested source, 1-based
 @param beginLine the first line of the requested source, 1-based
 @param endColumn the last column of the requested source, 1-based
 @param endLine the last line of the requested source, 1-based
 */
- (NSString *)getSourceWithInt:(jint)beginColumn
                       withInt:(jint)beginLine
                       withInt:(jint)endColumn
                       withInt:(jint)endLine;

/**
 @brief The name that was actually used to load this template from the TemplateLoader (or from other custom storage mechanism).
 This is what should be shown in error messages as the error location. This is usually the same as #getName() , except when localized lookup, template acquisition ( <code>*</code> step in the name), or other TemplateLookupStrategy transforms the requested name ( #getName() ) to a different final TemplateLoader -level name. For example, when you get a template with name <code>"foo.ftl"</code> then because of localized lookup, it's possible that something like <code>"foo_en.ftl"</code> will be loaded behind the scenes. While the template name will be still the same as the requested template name ( <code>"foo.ftl"</code> ), errors should point to <code>"foo_de.ftl"</code> . Note that relative paths are always resolved relatively to the <code>name</code> , not to the <code>sourceName</code> .
 @since 2.3.22
 */
- (NSString *)getSourceName;

/**
 @brief Executes template, using the data-model provided, writing the generated output to the supplied Writer .
 <p>For finer control over the runtime environment setup, such as per-HTTP-request configuring of FreeMarker settings, you may need to use #createProcessingEnvironment(Object,Writer) instead.
 @param dataModel the holder of the variables visible from the template (name-value pairs); usually a <code>Map<String, Object></code> or a JavaBean (where the JavaBean properties will be the variables). Can be any object that the ObjectWrapper in use turns into a TemplateHashModel . You can also use an object that already implements TemplateHashModel ; in that case it won't be wrapped. If it's <code>null</code> , an empty data model is used.
 @param out The Writer where the output of the template will go. Note that unless you have used Configuration#setAutoFlush(boolean) to disable this, Writer#flush() will be called at the when the template processing was finished. Writer#close() is not called.
 @throws TemplateException if an exception occurs during template processing
 @throws IOException if an I/O exception occurs during writing to the writer.
 */
- (void)processWithId:(id)dataModel
     withJavaIoWriter:(JavaIoWriter *)outArg;

/**
 @brief Like #process(Object,Writer) , but overrides the Configuration#getObjectWrapper() .
 @param wrapper The ObjectWrapper to be used instead of what Configuration#getObjectWrapper() provides, or <code>null</code> if you don't want to override that.
 */
- (void)processWithId:(id)dataModel
     withJavaIoWriter:(JavaIoWriter *)outArg
withFreemarkerTemplateObjectWrapper:(id<FreemarkerTemplateObjectWrapper>)wrapper;

/**
 @brief Like #process(Object,Writer) , but also sets a (XML-)node to be recursively processed by the template.
 That node is accessed in the template with <tt>.node</tt>, <tt>#recurse</tt>, etc. See the <a href="http://freemarker.org/docs/xgui_declarative.html" target="_blank">Declarative XML Processing</a> as a typical example of recursive node processing.
 @param rootNode The root node for recursive processing or <code>null</code> .
 @throws TemplateException if an exception occurs during template processing
 @throws IOException if an I/O exception occurs during writing to the writer.
 */
- (void)processWithId:(id)dataModel
     withJavaIoWriter:(JavaIoWriter *)outArg
withFreemarkerTemplateObjectWrapper:(id<FreemarkerTemplateObjectWrapper>)wrapper
withFreemarkerTemplateTemplateNodeModel:(id<FreemarkerTemplateTemplateNodeModel>)rootNode;

/**
 @brief Mostly only used internally; setter pair of #getCustomLookupCondition() .
 This meant to be called directly after instantiating the template with its constructor, after a successfull lookup that used this condition. So this should only be called from code that deals with creating new <code>Template</code> objects, like from TemplateCache .
 @since 2.3.22
 */
- (void)setCustomLookupConditionWithId:(id)customLookupCondition;

/**
 */
- (void)setEncodingWithNSString:(NSString *)encoding;

/**
 @brief Returns a string representing the raw template text in canonical form.
 */
- (NSString *)description;

#pragma mark Package-Private

/**
 @brief Only meant to be used internally.
 */
- (instancetype)initWithNSString:(NSString *)name
withFreemarkerCoreTemplateElement:(FreemarkerCoreTemplateElement *)root
withFreemarkerTemplateConfiguration:(FreemarkerTemplateConfiguration *)cfg;

/**
 @brief Return the template language (FTL) version used by this template.
 For now (2.3.21) this is the same as Configuration#getIncompatibleImprovements() , except that it's normalized to the lowest version where the template language was changed.
 */
- (FreemarkerTemplateVersion *)getTemplateLanguageVersion;

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerTemplateTemplate)

FOUNDATION_EXPORT NSString *FreemarkerTemplateTemplate_DEFAULT_NAMESPACE_PREFIX_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateTemplate, DEFAULT_NAMESPACE_PREFIX_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateTemplate_NO_NS_PREFIX_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateTemplate, NO_NS_PREFIX_, NSString *)

FOUNDATION_EXPORT void FreemarkerTemplateTemplate_initWithNSString_withJavaIoReader_withFreemarkerTemplateConfiguration_(FreemarkerTemplateTemplate *self, NSString *name, JavaIoReader *reader, FreemarkerTemplateConfiguration *cfg);

FOUNDATION_EXPORT FreemarkerTemplateTemplate *new_FreemarkerTemplateTemplate_initWithNSString_withJavaIoReader_withFreemarkerTemplateConfiguration_(NSString *name, JavaIoReader *reader, FreemarkerTemplateConfiguration *cfg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerTemplateTemplate_initWithNSString_withNSString_withFreemarkerTemplateConfiguration_(FreemarkerTemplateTemplate *self, NSString *name, NSString *sourceCode, FreemarkerTemplateConfiguration *cfg);

FOUNDATION_EXPORT FreemarkerTemplateTemplate *new_FreemarkerTemplateTemplate_initWithNSString_withNSString_withFreemarkerTemplateConfiguration_(NSString *name, NSString *sourceCode, FreemarkerTemplateConfiguration *cfg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerTemplateTemplate_initWithNSString_withJavaIoReader_withFreemarkerTemplateConfiguration_withNSString_(FreemarkerTemplateTemplate *self, NSString *name, JavaIoReader *reader, FreemarkerTemplateConfiguration *cfg, NSString *encoding);

FOUNDATION_EXPORT FreemarkerTemplateTemplate *new_FreemarkerTemplateTemplate_initWithNSString_withJavaIoReader_withFreemarkerTemplateConfiguration_withNSString_(NSString *name, JavaIoReader *reader, FreemarkerTemplateConfiguration *cfg, NSString *encoding) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerTemplateTemplate_initWithNSString_withNSString_withJavaIoReader_withFreemarkerTemplateConfiguration_(FreemarkerTemplateTemplate *self, NSString *name, NSString *sourceName, JavaIoReader *reader, FreemarkerTemplateConfiguration *cfg);

FOUNDATION_EXPORT FreemarkerTemplateTemplate *new_FreemarkerTemplateTemplate_initWithNSString_withNSString_withJavaIoReader_withFreemarkerTemplateConfiguration_(NSString *name, NSString *sourceName, JavaIoReader *reader, FreemarkerTemplateConfiguration *cfg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerTemplateTemplate_initWithNSString_withNSString_withJavaIoReader_withFreemarkerTemplateConfiguration_withNSString_(FreemarkerTemplateTemplate *self, NSString *name, NSString *sourceName, JavaIoReader *reader, FreemarkerTemplateConfiguration *cfg, NSString *encoding);

FOUNDATION_EXPORT FreemarkerTemplateTemplate *new_FreemarkerTemplateTemplate_initWithNSString_withNSString_withJavaIoReader_withFreemarkerTemplateConfiguration_withNSString_(NSString *name, NSString *sourceName, JavaIoReader *reader, FreemarkerTemplateConfiguration *cfg, NSString *encoding) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerTemplateTemplate_initWithNSString_withJavaIoReader_(FreemarkerTemplateTemplate *self, NSString *name, JavaIoReader *reader);

FOUNDATION_EXPORT FreemarkerTemplateTemplate *new_FreemarkerTemplateTemplate_initWithNSString_withJavaIoReader_(NSString *name, JavaIoReader *reader) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerTemplateTemplate_initWithNSString_withFreemarkerCoreTemplateElement_withFreemarkerTemplateConfiguration_(FreemarkerTemplateTemplate *self, NSString *name, FreemarkerCoreTemplateElement *root, FreemarkerTemplateConfiguration *cfg);

FOUNDATION_EXPORT FreemarkerTemplateTemplate *new_FreemarkerTemplateTemplate_initWithNSString_withFreemarkerCoreTemplateElement_withFreemarkerTemplateConfiguration_(NSString *name, FreemarkerCoreTemplateElement *root, FreemarkerTemplateConfiguration *cfg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT FreemarkerTemplateTemplate *FreemarkerTemplateTemplate_getPlainTextTemplateWithNSString_withNSString_withFreemarkerTemplateConfiguration_(NSString *name, NSString *content, FreemarkerTemplateConfiguration *config);

FOUNDATION_EXPORT FreemarkerTemplateTemplate *FreemarkerTemplateTemplate_getPlainTextTemplateWithNSString_withNSString_withNSString_withFreemarkerTemplateConfiguration_(NSString *name, NSString *sourceName, NSString *content, FreemarkerTemplateConfiguration *config);

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerTemplateTemplate)

/**
 @brief Thrown by the Template constructors that specify a non- <code>null</code> encoding whoch doesn't match the encoding specified in the <code>#ftl</code> header of the template.
 */
@interface FreemarkerTemplateTemplate_WrongEncodingException : FreemarkerCoreParseException {
 @public
  /**
   */
  NSString *specifiedEncoding_;
}

#pragma mark Public

/**
 */
- (instancetype)initWithNSString:(NSString *)templateSpecifiedEncoding;

/**
 @since 2.3.22
 */
- (instancetype)initWithNSString:(NSString *)templateSpecifiedEncoding
                    withNSString:(NSString *)constructorSpecifiedEncoding;

/**
 @since 2.3.22
 */
- (NSString *)getConstructorSpecifiedEncoding;

- (NSString *)getMessage;

/**
 @since 2.3.22
 */
- (NSString *)getTemplateSpecifiedEncoding;

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerTemplateTemplate_WrongEncodingException)

J2OBJC_FIELD_SETTER(FreemarkerTemplateTemplate_WrongEncodingException, specifiedEncoding_, NSString *)

FOUNDATION_EXPORT void FreemarkerTemplateTemplate_WrongEncodingException_initWithNSString_(FreemarkerTemplateTemplate_WrongEncodingException *self, NSString *templateSpecifiedEncoding);

FOUNDATION_EXPORT FreemarkerTemplateTemplate_WrongEncodingException *new_FreemarkerTemplateTemplate_WrongEncodingException_initWithNSString_(NSString *templateSpecifiedEncoding) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerTemplateTemplate_WrongEncodingException_initWithNSString_withNSString_(FreemarkerTemplateTemplate_WrongEncodingException *self, NSString *templateSpecifiedEncoding, NSString *constructorSpecifiedEncoding);

FOUNDATION_EXPORT FreemarkerTemplateTemplate_WrongEncodingException *new_FreemarkerTemplateTemplate_WrongEncodingException_initWithNSString_withNSString_(NSString *templateSpecifiedEncoding, NSString *constructorSpecifiedEncoding) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerTemplateTemplate_WrongEncodingException)

#endif // _FreemarkerTemplateTemplate_H_
