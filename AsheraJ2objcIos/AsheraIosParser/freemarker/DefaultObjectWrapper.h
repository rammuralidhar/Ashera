//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ramm/git/Ashera/AsheraAndroidParser/freemarker/freemarker/template/DefaultObjectWrapper.java
//

#ifndef _FreemarkerTemplateDefaultObjectWrapper_H_
#define _FreemarkerTemplateDefaultObjectWrapper_H_

#include "BeansWrapper.h"
#include "J2ObjC_header.h"

@class FreemarkerExtBeansBeansWrapperConfiguration;
@class FreemarkerTemplateDefaultObjectWrapperConfiguration;
@class FreemarkerTemplateVersion;
@protocol FreemarkerTemplateTemplateModel;

/**
 @brief The default implementation of the ObjectWrapper interface.
 Usually, you don't need to create instances of this, as an instance of this is already the default value of the Configuration#setObjectWrapper(ObjectWrapper) object_wrapper setting . Then the #DefaultObjectWrapper(Version) incompatibleImprovements of the DefaultObjectWrapper will be the same that you have set for the Configuration itself. As of this writing, it's highly recommended to use Configuration#Configuration(Version) incompatibleImprovements 2.3.22 (or higher). <p> If you still need to create an instance, that should be done with an DefaultObjectWrapperBuilder , not with its constructor, as that allows FreeMarker to reuse singletons. For new projects, it's recommended to set DefaultObjectWrapperBuilder#setForceLegacyNonListCollections(boolean) forceLegacyNonListCollections to <code>false</code> - something that setting <code>incompatibleImprovements</code> to 2.3.22 won't do. <p> This class is only thread-safe after you have finished calling its setter methods, and then safely published it (see JSR 133 and related literature). When used as part of Configuration , of course it's enough if that was safely published and then left unmodified.
 */
@interface FreemarkerTemplateDefaultObjectWrapper : FreemarkerExtBeansBeansWrapper

#pragma mark Public

/**
 @brief Creates a new instance with the incompatible-improvements-version specified in Configuration#DEFAULT_INCOMPATIBLE_IMPROVEMENTS .
 */
- (instancetype)init;

/**
 @brief Use DefaultObjectWrapperBuilder instead if possible.
 Instances created with this constructor won't share the class introspection caches with other instances. See BeansWrapper#BeansWrapper(Version) (the superclass constructor) for more details.
 @param incompatibleImprovements It's the same as in BeansWrapper#BeansWrapper(Version) , plus these  changes: <ul> <li>2.3.22 (or higher): The default value of #setUseAdaptersForContainers(boolean) useAdaptersForContainers changes to <code>true</code> .</li> </ul>
 @since 2.3.21
 */
- (instancetype)initWithFreemarkerTemplateVersion:(FreemarkerTemplateVersion *)incompatibleImprovements;

/**
 @brief Getter pair of #setForceLegacyNonListCollections(boolean) ; see there.
 @since 2.3.22
 */
- (jboolean)getForceLegacyNonListCollections;

/**
 @brief The getter pair of #setUseAdaptersForContainers(boolean) .
 @since 2.3.22
 */
- (jboolean)getUseAdaptersForContainers;

/**
 @brief Specifies whether non- List  Collection -s (like Set -s) must be wrapped by pre-fetching into a SimpleSequence .
 The modern approach is wrapping into a DefaultNonListCollectionAdapter . This setting only has effect when #getUseAdaptersForContainers() is also <code>true</code> , as otherwise SimpleSequence will be used regardless of this. In new projects you should set this to <code>false</code> . At least before <code>incompatible_improvements</code> 2.4.0 it defaults to <code>true</code> , because of backward compatibility concerns: with TemplateSequenceModel templates could access the items by index if they wanted to (the index values were defined by the iteration order). This was not very useful, or was even confusing, and it conflicts with the adapter approach.
 @since 2.3.22
 */
- (void)setForceLegacyNonListCollectionsWithBoolean:(jboolean)forceLegacyNonListCollections;

/**
 @brief Sets if to wrap container objects ( Map -s, List -s, arrays and such) the legacy copying approach or the newer adapter approach should be used.
 <code>true</code> is recommended, which is also the default when the <code>incompatible_improvements</code> of this instance was set to Configuration#VERSION_2_3_22 or higher. To understand the difference, check some of the classes that implement the two approaches: <ul> <li>Copying approach: SimpleHash , SimpleSequence </li> <li>Adapter approach: DefaultMapAdapter , DefaultListAdapter , DefaultArrayAdapter , DefaultIteratorAdapter </li> </ul> <p> See also the related Version History entry under 2.3.22 in the FreeMarker Manual, which gives a breakdown of the consequences. <p> <b>Attention:</b> For backward compatibility, currently, non- List collections (like Set -s) will only be wrapped with adapter approach (with DefaultNonListCollectionAdapter ) if #setForceLegacyNonListCollections(boolean) forceLegacyNonListCollections was set to <code>false</code> . Currently the default is <code>true</code> , but in new projects you should set it to <code>false</code> . See #setForceLegacyNonListCollections(boolean) for more.
 @since 2.3.22
 */
- (void)setUseAdaptersForContainersWithBoolean:(jboolean)useAdaptersForContainers;

/**
 @brief Wraps the parameter object to TemplateModel interface(s).
 Simple types like numbers, strings, booleans and dates will be wrapped into the corresponding <code>SimpleXxx</code> classes (like SimpleNumber ). Map -s, List -s, other Collection -s, arrays and Iterator -s will be wrapped into the corresponding <code>SimpleXxx</code> or <code>DefaultXxxAdapter</code> classes (like SimpleHash or DefaultMapAdapter ), depending on #getUseAdaptersForContainers() and #getForceLegacyNonListCollections() . After that, the wrapping is handled by #handleUnknownType(Object) , so see more there.
 */
- (id<FreemarkerTemplateTemplateModel>)wrapWithId:(id)obj;

#pragma mark Protected

/**
 @brief Use #DefaultObjectWrapper(DefaultObjectWrapperConfiguration,boolean) instead if possible; it does the same, except that it tolerates a non- DefaultObjectWrapperConfiguration configuration too.
 @since 2.3.21
 */
- (instancetype)initWithFreemarkerExtBeansBeansWrapperConfiguration:(FreemarkerExtBeansBeansWrapperConfiguration *)bwCfg
                                                        withBoolean:(jboolean)writeProtected;

/**
 @brief Calls BeansWrapper#BeansWrapper(BeansWrapperConfiguration,boolean) and sets up DefaultObjectWrapper -specific fields.
 @since 2.3.22
 */
- (instancetype)initWithFreemarkerTemplateDefaultObjectWrapperConfiguration:(FreemarkerTemplateDefaultObjectWrapperConfiguration *)dowCfg
                                                                withBoolean:(jboolean)writeProtected;

/**
 @brief Converts an array to a java.util.List.
 */
- (id)convertArrayWithId:(id)arr;

/**
 @brief Called for an object that aren't considered to be of a "basic" Java type, like for an application specific type, or for a W3C DOM node.
 In its default implementation, W3C Node -s will be wrapped as NodeModel -s (allows DOM tree traversal), Jython objects will be delegated to the <code>JythonWrapper</code> , others will be wrapped using BeansWrapper#wrap(Object) . <p> When you override this method, you should first decide if you want to wrap the object in a custom way (and if so then do it and return with the result), and if not, then you should call the super method (assuming the default behavior is fine with you).
 */
- (id<FreemarkerTemplateTemplateModel>)handleUnknownTypeWithId:(id)obj;

/**
 @brief Returns the lowest version number that is equivalent with the parameter version.
 @since 2.3.22
 */
+ (FreemarkerTemplateVersion *)normalizeIncompatibleImprovementsVersionWithFreemarkerTemplateVersion:(FreemarkerTemplateVersion *)incompatibleImprovements;

/**
 @since 2.3.22
 */
- (NSString *)toPropertiesString;

@end

J2OBJC_STATIC_INIT(FreemarkerTemplateDefaultObjectWrapper)

FOUNDATION_EXPORT FreemarkerTemplateDefaultObjectWrapper *FreemarkerTemplateDefaultObjectWrapper_instance_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateDefaultObjectWrapper, instance_, FreemarkerTemplateDefaultObjectWrapper *)

FOUNDATION_EXPORT void FreemarkerTemplateDefaultObjectWrapper_init(FreemarkerTemplateDefaultObjectWrapper *self);

FOUNDATION_EXPORT FreemarkerTemplateDefaultObjectWrapper *new_FreemarkerTemplateDefaultObjectWrapper_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerTemplateDefaultObjectWrapper_initWithFreemarkerTemplateVersion_(FreemarkerTemplateDefaultObjectWrapper *self, FreemarkerTemplateVersion *incompatibleImprovements);

FOUNDATION_EXPORT FreemarkerTemplateDefaultObjectWrapper *new_FreemarkerTemplateDefaultObjectWrapper_initWithFreemarkerTemplateVersion_(FreemarkerTemplateVersion *incompatibleImprovements) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerTemplateDefaultObjectWrapper_initWithFreemarkerExtBeansBeansWrapperConfiguration_withBoolean_(FreemarkerTemplateDefaultObjectWrapper *self, FreemarkerExtBeansBeansWrapperConfiguration *bwCfg, jboolean writeProtected);

FOUNDATION_EXPORT FreemarkerTemplateDefaultObjectWrapper *new_FreemarkerTemplateDefaultObjectWrapper_initWithFreemarkerExtBeansBeansWrapperConfiguration_withBoolean_(FreemarkerExtBeansBeansWrapperConfiguration *bwCfg, jboolean writeProtected) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerTemplateDefaultObjectWrapper_initWithFreemarkerTemplateDefaultObjectWrapperConfiguration_withBoolean_(FreemarkerTemplateDefaultObjectWrapper *self, FreemarkerTemplateDefaultObjectWrapperConfiguration *dowCfg, jboolean writeProtected);

FOUNDATION_EXPORT FreemarkerTemplateDefaultObjectWrapper *new_FreemarkerTemplateDefaultObjectWrapper_initWithFreemarkerTemplateDefaultObjectWrapperConfiguration_withBoolean_(FreemarkerTemplateDefaultObjectWrapperConfiguration *dowCfg, jboolean writeProtected) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT FreemarkerTemplateVersion *FreemarkerTemplateDefaultObjectWrapper_normalizeIncompatibleImprovementsVersionWithFreemarkerTemplateVersion_(FreemarkerTemplateVersion *incompatibleImprovements);

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerTemplateDefaultObjectWrapper)

#endif // _FreemarkerTemplateDefaultObjectWrapper_H_
