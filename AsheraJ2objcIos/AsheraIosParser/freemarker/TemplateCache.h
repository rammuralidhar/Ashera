//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ramm/git/Ashera/AsheraAndroidParser/freemarker/freemarker/cache/TemplateCache.java
//

#ifndef _FreemarkerCacheTemplateCache_H_
#define _FreemarkerCacheTemplateCache_H_

#include "J2ObjC_header.h"

@class FreemarkerCacheTemplateCache_MaybeMissingTemplate;
@class FreemarkerCacheTemplateLookupStrategy;
@class FreemarkerCacheTemplateNameFormat;
@class FreemarkerCoreEnvironment;
@class FreemarkerTemplateConfiguration;
@class FreemarkerTemplateTemplate;
@class JavaUtilLocale;
@protocol FreemarkerCacheCacheStorage;
@protocol FreemarkerCacheTemplateLoader;

#define FreemarkerCacheTemplateCache_DEFAULT_TEMPLATE_UPDATE_DELAY_MILLIS 5000LL

/**
 @brief Performs caching and on-demand loading of the templates.
 The actual template "file" loading is delegated to a TemplateLoader that you can specify in the constructor. Some aspects of caching is delegated to a CacheStorage that you can also specify in the constructor. <p>Typically you don't instantiate or otherwise use this class directly. The Configuration embeds an instance of this class, that you access indirectly through Configuration#getTemplate(String) and other Configuration API-s. Then TemplateLoader and CacheStorage can be set with Configuration#setTemplateLoader(TemplateLoader) and Configuration#setCacheStorage(CacheStorage) .
 */
@interface FreemarkerCacheTemplateCache : NSObject

#pragma mark Public

/**
 @brief Returns a template cache that will first try to load a template from the file system relative to the current user directory (i.e. the value of the system property <code>user.dir</code>), then from the classpath.
 */
- (instancetype)init;

/**
 */
- (instancetype)initWithFreemarkerCacheTemplateLoader:(id<FreemarkerCacheTemplateLoader>)templateLoader;

/**
 */
- (instancetype)initWithFreemarkerCacheTemplateLoader:(id<FreemarkerCacheTemplateLoader>)templateLoader
                      withFreemarkerCacheCacheStorage:(id<FreemarkerCacheCacheStorage>)cacheStorage;

/**
 @brief Same as #TemplateCache(TemplateLoader,CacheStorage,TemplateLookupStrategy,TemplateNameFormat,Configuration) with TemplateLookupStrategy#DEFAULT_2_3_0 and TemplateNameFormat#DEFAULT_2_3_0 .
 @since 2.3.21
 */
- (instancetype)initWithFreemarkerCacheTemplateLoader:(id<FreemarkerCacheTemplateLoader>)templateLoader
                      withFreemarkerCacheCacheStorage:(id<FreemarkerCacheCacheStorage>)cacheStorage
                  withFreemarkerTemplateConfiguration:(FreemarkerTemplateConfiguration *)config;

/**
 @param templateLoader The TemplateLoader to use. Can't be <code>null</code> .
 @param cacheStorage The CacheStorage to use. Can't be <code>null</code> .
 @param templateLookupStrategy The TemplateLookupStrategy to use. Can't be <code>null</code> .
 @param config The Configuration this cache will be used for. Can be <code>null</code> for backward compatibility, as it can be set with #setConfiguration(Configuration) later.
 @since 2.3.22
 */
- (instancetype)initWithFreemarkerCacheTemplateLoader:(id<FreemarkerCacheTemplateLoader>)templateLoader
                      withFreemarkerCacheCacheStorage:(id<FreemarkerCacheCacheStorage>)cacheStorage
            withFreemarkerCacheTemplateLookupStrategy:(FreemarkerCacheTemplateLookupStrategy *)templateLookupStrategy
                withFreemarkerCacheTemplateNameFormat:(FreemarkerCacheTemplateNameFormat *)templateNameFormat
                  withFreemarkerTemplateConfiguration:(FreemarkerTemplateConfiguration *)config;

/**
 @brief Same as #TemplateCache(TemplateLoader,CacheStorage,Configuration) with a new SoftCacheStorage as the 2nd parameter.
 @since 2.3.21
 */
- (instancetype)initWithFreemarkerCacheTemplateLoader:(id<FreemarkerCacheTemplateLoader>)templateLoader
                  withFreemarkerTemplateConfiguration:(FreemarkerTemplateConfiguration *)config;

/**
 @brief Removes all entries from the cache, forcing reloading of templates on subsequent #getTemplate(String,Locale,String,boolean) calls.
 If the configured template loader is StatefulTemplateLoader stateful , then its StatefulTemplateLoader#resetState() method is invoked as well.
 */
- (void)clear;

- (id<FreemarkerCacheCacheStorage>)getCacheStorage;

/**
 @brief Gets the delay in milliseconds between checking for newer versions of a template source.
 @return the current value of the delay
 */
- (jlong)getDelay;

/**
 @throws IllegalArgumentException If the <code>baseName</code> or <code>targetName</code> is malformed according the TemplateNameFormat in use.
 */
+ (NSString *)getFullTemplatePathWithFreemarkerCoreEnvironment:(FreemarkerCoreEnvironment *)env
                                                  withNSString:(NSString *)baseName
                                                  withNSString:(NSString *)targetName;

/**
 @brief Returns if localized template lookup is enabled or not.
 */
- (jboolean)getLocalizedLookup;

/**
 @brief Retrieves the template with the given name (and according the specified further parameters) from the template cache, loading it into the cache first if it's missing/staled.
 <p> All parameters must be non- <code>null</code> , except <code>customLookupCondition</code> . For the meaning of the parameters see Configuration#getTemplate(String,Locale,String,boolean) .
 @return A MaybeMissingTemplate object that contains the Template , or a MaybeMissingTemplate object that contains <code>null</code> as the Template and information about the missing template. The return value itself is never <code>null</code> . Note that exceptions occurring during template loading will not be classified as a missing template, so they will cause an exception to be thrown by this method instead of returning a MaybeMissingTemplate . The idea is that having a missing template is normal (not exceptional), providing that the backing storage mechanism could indeed check that it's missing.
 @throws MalformedTemplateNameException If the <code>name</code> was malformed according the current TemplateNameFormat . However, if the TemplateNameFormat is TemplateNameFormat#DEFAULT_2_3_0 and Configuration#getIncompatibleImprovements() is less than 2.4.0, then instead of throwing this exception, a MaybeMissingTemplate will be returned, similarly as if the template were missing (the MaybeMissingTemplate#getMissingTemplateReason() will describe the real error).
 @throws IOException If reading the template has failed from a reason other than the template is missing. This method should never be a TemplateNotFoundException , as that condition is indicated in the return value.
 @since 2.3.22
 */
- (FreemarkerCacheTemplateCache_MaybeMissingTemplate *)getTemplateWithNSString:(NSString *)name
                                                            withJavaUtilLocale:(JavaUtilLocale *)locale
                                                                        withId:(id)customLookupCondition
                                                                  withNSString:(NSString *)encoding
                                                                   withBoolean:(jboolean)parseAsFTL;

/**
 @brief Similar to #getTemplate(String,Locale,Object,String,boolean) with <code>null</code> <code>customLookupCondition</code> .
 @return MaybeMissingTemplate#getTemplate() of the #getTemplate(String,Locale,Object,String,boolean) return value.
 */
- (FreemarkerTemplateTemplate *)getTemplateWithNSString:(NSString *)name
                                     withJavaUtilLocale:(JavaUtilLocale *)locale
                                           withNSString:(NSString *)encoding
                                            withBoolean:(jboolean)parseAsFTL;

- (id<FreemarkerCacheTemplateLoader>)getTemplateLoader;

/**
 @since 2.3.22
 */
- (FreemarkerCacheTemplateLookupStrategy *)getTemplateLookupStrategy;

/**
 @since 2.3.22
 */
- (FreemarkerCacheTemplateNameFormat *)getTemplateNameFormat;

/**
 @brief Removes an entry from the cache, hence forcing the re-loading of it when it's next time requested.
 (It doesn't delete the template file itself.) This is to give the application finer control over cache updating than #setDelay(long) alone does. For the meaning of the parameters, see #getTemplate(TemplateLoader,String,Locale,Object,String,boolean) .
 */
- (void)removeTemplateWithNSString:(NSString *)name
                withJavaUtilLocale:(JavaUtilLocale *)locale
                            withId:(id)customLookupCondition
                      withNSString:(NSString *)encoding
                       withBoolean:(jboolean)parse;

- (void)removeTemplateWithNSString:(NSString *)name
                withJavaUtilLocale:(JavaUtilLocale *)locale
                      withNSString:(NSString *)encoding
                       withBoolean:(jboolean)parse;

/**
 @brief Sets the configuration object to which this cache belongs.
 This method is called by the configuration itself to establish the relation, and should not be called by users.
 */
- (void)setConfigurationWithFreemarkerTemplateConfiguration:(FreemarkerTemplateConfiguration *)config;

/**
 @brief Sets the delay in milliseconds between checking for newer versions of a template sources.
 @param delay the new value of the delay
 */
- (void)setDelayWithLong:(jlong)delay;

/**
 @brief Setis if localized template lookup is enabled or not.
 */
- (void)setLocalizedLookupWithBoolean:(jboolean)localizedLookup;

#pragma mark Protected

/**
 @brief Returns the deprecated default template loader of FreeMarker 2.3.0.
 */
+ (id<FreemarkerCacheTemplateLoader>)createLegacyDefaultTemplateLoader;

@end

J2OBJC_STATIC_INIT(FreemarkerCacheTemplateCache)

J2OBJC_STATIC_FIELD_GETTER(FreemarkerCacheTemplateCache, DEFAULT_TEMPLATE_UPDATE_DELAY_MILLIS, jlong)

FOUNDATION_EXPORT void FreemarkerCacheTemplateCache_init(FreemarkerCacheTemplateCache *self);

FOUNDATION_EXPORT FreemarkerCacheTemplateCache *new_FreemarkerCacheTemplateCache_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerCacheTemplateCache_initWithFreemarkerCacheTemplateLoader_(FreemarkerCacheTemplateCache *self, id<FreemarkerCacheTemplateLoader> templateLoader);

FOUNDATION_EXPORT FreemarkerCacheTemplateCache *new_FreemarkerCacheTemplateCache_initWithFreemarkerCacheTemplateLoader_(id<FreemarkerCacheTemplateLoader> templateLoader) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerCacheTemplateCache_initWithFreemarkerCacheTemplateLoader_withFreemarkerCacheCacheStorage_(FreemarkerCacheTemplateCache *self, id<FreemarkerCacheTemplateLoader> templateLoader, id<FreemarkerCacheCacheStorage> cacheStorage);

FOUNDATION_EXPORT FreemarkerCacheTemplateCache *new_FreemarkerCacheTemplateCache_initWithFreemarkerCacheTemplateLoader_withFreemarkerCacheCacheStorage_(id<FreemarkerCacheTemplateLoader> templateLoader, id<FreemarkerCacheCacheStorage> cacheStorage) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerCacheTemplateCache_initWithFreemarkerCacheTemplateLoader_withFreemarkerTemplateConfiguration_(FreemarkerCacheTemplateCache *self, id<FreemarkerCacheTemplateLoader> templateLoader, FreemarkerTemplateConfiguration *config);

FOUNDATION_EXPORT FreemarkerCacheTemplateCache *new_FreemarkerCacheTemplateCache_initWithFreemarkerCacheTemplateLoader_withFreemarkerTemplateConfiguration_(id<FreemarkerCacheTemplateLoader> templateLoader, FreemarkerTemplateConfiguration *config) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerCacheTemplateCache_initWithFreemarkerCacheTemplateLoader_withFreemarkerCacheCacheStorage_withFreemarkerTemplateConfiguration_(FreemarkerCacheTemplateCache *self, id<FreemarkerCacheTemplateLoader> templateLoader, id<FreemarkerCacheCacheStorage> cacheStorage, FreemarkerTemplateConfiguration *config);

FOUNDATION_EXPORT FreemarkerCacheTemplateCache *new_FreemarkerCacheTemplateCache_initWithFreemarkerCacheTemplateLoader_withFreemarkerCacheCacheStorage_withFreemarkerTemplateConfiguration_(id<FreemarkerCacheTemplateLoader> templateLoader, id<FreemarkerCacheCacheStorage> cacheStorage, FreemarkerTemplateConfiguration *config) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerCacheTemplateCache_initWithFreemarkerCacheTemplateLoader_withFreemarkerCacheCacheStorage_withFreemarkerCacheTemplateLookupStrategy_withFreemarkerCacheTemplateNameFormat_withFreemarkerTemplateConfiguration_(FreemarkerCacheTemplateCache *self, id<FreemarkerCacheTemplateLoader> templateLoader, id<FreemarkerCacheCacheStorage> cacheStorage, FreemarkerCacheTemplateLookupStrategy *templateLookupStrategy, FreemarkerCacheTemplateNameFormat *templateNameFormat, FreemarkerTemplateConfiguration *config);

FOUNDATION_EXPORT FreemarkerCacheTemplateCache *new_FreemarkerCacheTemplateCache_initWithFreemarkerCacheTemplateLoader_withFreemarkerCacheCacheStorage_withFreemarkerCacheTemplateLookupStrategy_withFreemarkerCacheTemplateNameFormat_withFreemarkerTemplateConfiguration_(id<FreemarkerCacheTemplateLoader> templateLoader, id<FreemarkerCacheCacheStorage> cacheStorage, FreemarkerCacheTemplateLookupStrategy *templateLookupStrategy, FreemarkerCacheTemplateNameFormat *templateNameFormat, FreemarkerTemplateConfiguration *config) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT id<FreemarkerCacheTemplateLoader> FreemarkerCacheTemplateCache_createLegacyDefaultTemplateLoader();

FOUNDATION_EXPORT NSString *FreemarkerCacheTemplateCache_getFullTemplatePathWithFreemarkerCoreEnvironment_withNSString_withNSString_(FreemarkerCoreEnvironment *env, NSString *baseName, NSString *targetName);

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerCacheTemplateCache)

/**
 @brief Used for the return value of TemplateCache#getTemplate(String,Locale,Object,String,boolean) .
 @since 2.3.22
 */
@interface FreemarkerCacheTemplateCache_MaybeMissingTemplate : NSObject

#pragma mark Public

/**
 @brief When the template was missing, this <em>possibly</em> contains its normalized name.
 If the template wasn't missing (i.e., when #getTemplate() return non- <code>null</code> ) this is always <code>null</code> . When the template is missing, it will be <code>null</code> for example if the normalization itself was unsuccessful.
 */
- (NSString *)getMissingTemplateNormalizedName;

/**
 @brief When the template was missing, this <em>possibly</em> contains the explanation, or <code>null</code> .
 If the template wasn't missing (i.e., when #getTemplate() return non- <code>null</code> ) this is always <code>null</code> .
 */
- (NSString *)getMissingTemplateReason;

/**
 @brief The Template if it wasn't missing, otherwise <code>null</code> .
 */
- (FreemarkerTemplateTemplate *)getTemplate;

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerCacheTemplateCache_MaybeMissingTemplate)

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerCacheTemplateCache_MaybeMissingTemplate)

#endif // _FreemarkerCacheTemplateCache_H_
