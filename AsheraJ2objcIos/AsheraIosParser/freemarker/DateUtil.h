//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ramm/git/Ashera/AsheraAndroidParser/freemarker/freemarker/template/utility/DateUtil.java
//

#ifndef _FreemarkerTemplateUtilityDateUtil_H_
#define _FreemarkerTemplateUtilityDateUtil_H_

#include "J2ObjC_header.h"
#include "java/text/ParseException.h"

@class JavaUtilDate;
@class JavaUtilGregorianCalendar;
@class JavaUtilTimeZone;
@protocol FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter;
@protocol FreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory;

#define FreemarkerTemplateUtilityDateUtil_ACCURACY_HOURS 4
#define FreemarkerTemplateUtilityDateUtil_ACCURACY_MINUTES 5
#define FreemarkerTemplateUtilityDateUtil_ACCURACY_SECONDS 6
#define FreemarkerTemplateUtilityDateUtil_ACCURACY_MILLISECONDS 7
#define FreemarkerTemplateUtilityDateUtil_ACCURACY_MILLISECONDS_FORCED 8

/**
 @brief Date and time related utilities.
 */
@interface FreemarkerTemplateUtilityDateUtil : NSObject

#pragma mark Public

/**
 @brief Format a date, time or dateTime with one of the ISO 8601 extended formats that is also compatible with the XML Schema format (as far as you don't have dates in the BC era).
 Examples of possible outputs: <code>"2005-11-27T15:30:00+02:00"</code> , <code>"2005-11-27"</code> , <code>"15:30:00Z"</code> . Note the <code>":00"</code> in the time zone offset; this is not required by ISO 8601, but included for compatibility with the XML Schema format. Regarding the B.C. issue, those dates will be one year off when read back according the XML Schema format, because of a mismatch between that format and ISO 8601:2000 Second Edition. <p>This method is thread-safe.
 @param date the date to convert to ISO 8601 string
 @param datePart whether the date part (year, month, day) will be included or not
 @param timePart whether the time part (hours, minutes, seconds, milliseconds) will be included or not
 @param offsetPart whether the time zone offset part will be included or not. This will be shown as an offset to UTC (examples: <code>"+01"</code> , <code>"-02"</code> , <code>"+04:30"</code> ) or as <code>"Z"</code> for UTC (and for UT1 and for GMT+00, since the Java platform doesn't really care about the difference). Note that this can't be <code>true</code> when <code>timePart</code> is <code>false</code> , because ISO 8601 (2004) doesn't mention such patterns.
 @param accuracy tells which parts of the date/time to drop. The <code>datePart</code> and <code>timePart</code> parameters are stronger than this. Note that when #ACCURACY_MILLISECONDS is specified, the milliseconds part will be displayed as fraction seconds (like <code>"15:30.00.25"</code> ) with the minimum number of digits needed to show the milliseconds without precision lose. Thus, if the milliseconds happen to be exactly 0, no fraction seconds will be shown at all.
 @param timeZone the time zone in which the date/time will be shown. (You may find DateUtil#UTC handy here.) Note that although date-only formats has no time zone offset part, the result still depends on the time zone, as days start and end at different points on the time line in different zones.
 @param calendarFactory the factory that will create the calendar used internally for calculations. The point of this parameter is that creating a new calendar is relatively expensive, so it's desirable to reuse calendars and only set their time and zone. (This was tested on Sun JDK 1.6 x86 Win, where it gave 2x-3x speedup.)
 */
+ (NSString *)dateToISO8601StringWithJavaUtilDate:(JavaUtilDate *)date
                                      withBoolean:(jboolean)datePart
                                      withBoolean:(jboolean)timePart
                                      withBoolean:(jboolean)offsetPart
                                          withInt:(jint)accuracy
                             withJavaUtilTimeZone:(JavaUtilTimeZone *)timeZone
withFreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory:(id<FreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory>)calendarFactory;

/**
 @brief Same as #dateToISO8601String , but gives XML Schema compliant format.
 */
+ (NSString *)dateToXSStringWithJavaUtilDate:(JavaUtilDate *)date
                                 withBoolean:(jboolean)datePart
                                 withBoolean:(jboolean)timePart
                                 withBoolean:(jboolean)offsetPart
                                     withInt:(jint)accuracy
                        withJavaUtilTimeZone:(JavaUtilTimeZone *)timeZone
withFreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory:(id<FreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory>)calendarFactory;

/**
 @brief Returns the time zone object for the name (or ID).
 This differs from TimeZone#getTimeZone(String) in that the latest returns GMT if it doesn't recognize the name, while this throws an UnrecognizedTimeZoneException .
 @throws UnrecognizedTimeZoneException If the time zone name wasn't understood
 */
+ (JavaUtilTimeZone *)getTimeZoneWithNSString:(NSString *)name;

/**
 @brief Same as #parseXSDate(String,TimeZone,CalendarFieldsToDateConverter) , but for ISO 8601 dates.
 */
+ (JavaUtilDate *)parseISO8601DateWithNSString:(NSString *)dateStr
                          withJavaUtilTimeZone:(JavaUtilTimeZone *)defaultTimeZone
withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter:(id<FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter>)calToDateConverter;

/**
 @brief Same as #parseXSDateTime(String,TimeZone,CalendarFieldsToDateConverter) but for ISO 8601 format.
 */
+ (JavaUtilDate *)parseISO8601DateTimeWithNSString:(NSString *)dateTimeStr
                              withJavaUtilTimeZone:(JavaUtilTimeZone *)defaultTZ
withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter:(id<FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter>)calToDateConverter;

/**
 @brief Same as #parseXSTime(String,TimeZone,CalendarFieldsToDateConverter) but for ISO 8601 times.
 */
+ (JavaUtilDate *)parseISO8601TimeWithNSString:(NSString *)timeStr
                          withJavaUtilTimeZone:(JavaUtilTimeZone *)defaultTZ
withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter:(id<FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter>)calToDateConverter;

/**
 @brief Parses an W3C XML Schema date string (not time or date-time).
 Unlike in ISO 8601:2000 Second Edition, year -1 means B.C 1, and year 0 is invalid.
 @param dateStr the string to parse.
 @param defaultTimeZone used if the date doesn't specify the time zone offset explicitly. Can't be <code>null</code> .
 @param calToDateConverter Used internally to calculate the result from the calendar field values. If you don't have a such object around, you can just use <code>new</code> TrivialCalendarFieldsToDateConverter <code>()</code> .
 @throws DateParseException if the date is malformed, or if the time zone offset is unspecified and the <code>defaultTimeZone</code> is <code>null</code> .
 */
+ (JavaUtilDate *)parseXSDateWithNSString:(NSString *)dateStr
                     withJavaUtilTimeZone:(JavaUtilTimeZone *)defaultTimeZone
withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter:(id<FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter>)calToDateConverter;

/**
 @brief Parses an W3C XML Schema date-time string (not date or time).
 Unlike in ISO 8601:2000 Second Edition, year -1 means B.C 1, and year 0 is invalid.
 @param dateTimeStr the string to parse.
 @param defaultTZ used if the dateTime doesn't specify the time zone offset explicitly. Can't be <code>null</code> .
 @throws DateParseException if the dateTime is malformed.
 */
+ (JavaUtilDate *)parseXSDateTimeWithNSString:(NSString *)dateTimeStr
                         withJavaUtilTimeZone:(JavaUtilTimeZone *)defaultTZ
withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter:(id<FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter>)calToDateConverter;

/**
 @brief Parses an W3C XML Schema time string (not date or date-time).
 If the time string doesn't specify the time zone offset explicitly, the value of the <code>defaultTZ</code> paramter will be used.
 */
+ (JavaUtilDate *)parseXSTimeWithNSString:(NSString *)timeStr
                     withJavaUtilTimeZone:(JavaUtilTimeZone *)defaultTZ
withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter:(id<FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter>)calToDateConverter;

/**
 @brief Parses the time zone part from a W3C XML Schema date/time/dateTime.
 @throws DateParseException if the zone is malformed.
 */
+ (JavaUtilTimeZone *)parseXSTimeZoneWithNSString:(NSString *)timeZoneStr;

@end

J2OBJC_STATIC_INIT(FreemarkerTemplateUtilityDateUtil)

J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateUtilityDateUtil, ACCURACY_HOURS, jint)

J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateUtilityDateUtil, ACCURACY_MINUTES, jint)

J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateUtilityDateUtil, ACCURACY_SECONDS, jint)

J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateUtilityDateUtil, ACCURACY_MILLISECONDS, jint)

J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateUtilityDateUtil, ACCURACY_MILLISECONDS_FORCED, jint)

FOUNDATION_EXPORT JavaUtilTimeZone *FreemarkerTemplateUtilityDateUtil_UTC_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateUtilityDateUtil, UTC_, JavaUtilTimeZone *)

FOUNDATION_EXPORT JavaUtilTimeZone *FreemarkerTemplateUtilityDateUtil_getTimeZoneWithNSString_(NSString *name);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityDateUtil_dateToISO8601StringWithJavaUtilDate_withBoolean_withBoolean_withBoolean_withInt_withJavaUtilTimeZone_withFreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory_(JavaUtilDate *date, jboolean datePart, jboolean timePart, jboolean offsetPart, jint accuracy, JavaUtilTimeZone *timeZone, id<FreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory> calendarFactory);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityDateUtil_dateToXSStringWithJavaUtilDate_withBoolean_withBoolean_withBoolean_withInt_withJavaUtilTimeZone_withFreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory_(JavaUtilDate *date, jboolean datePart, jboolean timePart, jboolean offsetPart, jint accuracy, JavaUtilTimeZone *timeZone, id<FreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory> calendarFactory);

FOUNDATION_EXPORT JavaUtilDate *FreemarkerTemplateUtilityDateUtil_parseXSDateWithNSString_withJavaUtilTimeZone_withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter_(NSString *dateStr, JavaUtilTimeZone *defaultTimeZone, id<FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter> calToDateConverter);

FOUNDATION_EXPORT JavaUtilDate *FreemarkerTemplateUtilityDateUtil_parseISO8601DateWithNSString_withJavaUtilTimeZone_withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter_(NSString *dateStr, JavaUtilTimeZone *defaultTimeZone, id<FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter> calToDateConverter);

FOUNDATION_EXPORT JavaUtilDate *FreemarkerTemplateUtilityDateUtil_parseXSTimeWithNSString_withJavaUtilTimeZone_withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter_(NSString *timeStr, JavaUtilTimeZone *defaultTZ, id<FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter> calToDateConverter);

FOUNDATION_EXPORT JavaUtilDate *FreemarkerTemplateUtilityDateUtil_parseISO8601TimeWithNSString_withJavaUtilTimeZone_withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter_(NSString *timeStr, JavaUtilTimeZone *defaultTZ, id<FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter> calToDateConverter);

FOUNDATION_EXPORT JavaUtilDate *FreemarkerTemplateUtilityDateUtil_parseXSDateTimeWithNSString_withJavaUtilTimeZone_withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter_(NSString *dateTimeStr, JavaUtilTimeZone *defaultTZ, id<FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter> calToDateConverter);

FOUNDATION_EXPORT JavaUtilDate *FreemarkerTemplateUtilityDateUtil_parseISO8601DateTimeWithNSString_withJavaUtilTimeZone_withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter_(NSString *dateTimeStr, JavaUtilTimeZone *defaultTZ, id<FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter> calToDateConverter);

FOUNDATION_EXPORT JavaUtilTimeZone *FreemarkerTemplateUtilityDateUtil_parseXSTimeZoneWithNSString_(NSString *timeZoneStr);

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerTemplateUtilityDateUtil)

/**
 @brief Used internally by DateUtil ; don't use its implementations for anything else.
 */
@protocol FreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory < NSObject, JavaObject >

/**
 @brief Returns a GregorianCalendar with the desired time zone and time and US locale.
 The returned calendar is used as read-only. It must be guaranteed that within a thread the instance returned last time is not in use anymore when this method is called again.
 */
- (JavaUtilGregorianCalendar *)getWithJavaUtilTimeZone:(JavaUtilTimeZone *)tz
                                      withJavaUtilDate:(JavaUtilDate *)date;

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory)

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory)

/**
 @brief Used internally by DateUtil ; don't use its implementations for anything else.
 */
@protocol FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter < NSObject, JavaObject >

/**
 @brief Calculates the Date from the specified calendar fields.
 */
- (JavaUtilDate *)calculateWithInt:(jint)era
                           withInt:(jint)year
                           withInt:(jint)month
                           withInt:(jint)day
                           withInt:(jint)hours
                           withInt:(jint)minutes
                           withInt:(jint)secs
                           withInt:(jint)millisecs
                       withBoolean:(jboolean)addOneDay
              withJavaUtilTimeZone:(JavaUtilTimeZone *)tz;

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter)

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter)

/**
 @brief Non-thread-safe factory that hard-references a calendar internally.
 */
@interface FreemarkerTemplateUtilityDateUtil_TrivialDateToISO8601CalendarFactory : NSObject < FreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory >

#pragma mark Public

- (instancetype)init;

- (JavaUtilGregorianCalendar *)getWithJavaUtilTimeZone:(JavaUtilTimeZone *)tz
                                      withJavaUtilDate:(JavaUtilDate *)date;

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerTemplateUtilityDateUtil_TrivialDateToISO8601CalendarFactory)

FOUNDATION_EXPORT void FreemarkerTemplateUtilityDateUtil_TrivialDateToISO8601CalendarFactory_init(FreemarkerTemplateUtilityDateUtil_TrivialDateToISO8601CalendarFactory *self);

FOUNDATION_EXPORT FreemarkerTemplateUtilityDateUtil_TrivialDateToISO8601CalendarFactory *new_FreemarkerTemplateUtilityDateUtil_TrivialDateToISO8601CalendarFactory_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerTemplateUtilityDateUtil_TrivialDateToISO8601CalendarFactory)

/**
 @brief Non-thread-safe implementation that hard-references a calendar internally.
 */
@interface FreemarkerTemplateUtilityDateUtil_TrivialCalendarFieldsToDateConverter : NSObject < FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter >

#pragma mark Public

- (instancetype)init;

- (JavaUtilDate *)calculateWithInt:(jint)era
                           withInt:(jint)year
                           withInt:(jint)month
                           withInt:(jint)day
                           withInt:(jint)hours
                           withInt:(jint)minutes
                           withInt:(jint)secs
                           withInt:(jint)millisecs
                       withBoolean:(jboolean)addOneDay
              withJavaUtilTimeZone:(JavaUtilTimeZone *)tz;

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerTemplateUtilityDateUtil_TrivialCalendarFieldsToDateConverter)

FOUNDATION_EXPORT void FreemarkerTemplateUtilityDateUtil_TrivialCalendarFieldsToDateConverter_init(FreemarkerTemplateUtilityDateUtil_TrivialCalendarFieldsToDateConverter *self);

FOUNDATION_EXPORT FreemarkerTemplateUtilityDateUtil_TrivialCalendarFieldsToDateConverter *new_FreemarkerTemplateUtilityDateUtil_TrivialCalendarFieldsToDateConverter_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerTemplateUtilityDateUtil_TrivialCalendarFieldsToDateConverter)

@interface FreemarkerTemplateUtilityDateUtil_DateParseException : JavaTextParseException

#pragma mark Public

- (instancetype)initWithNSString:(NSString *)message;

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerTemplateUtilityDateUtil_DateParseException)

FOUNDATION_EXPORT void FreemarkerTemplateUtilityDateUtil_DateParseException_initWithNSString_(FreemarkerTemplateUtilityDateUtil_DateParseException *self, NSString *message);

FOUNDATION_EXPORT FreemarkerTemplateUtilityDateUtil_DateParseException *new_FreemarkerTemplateUtilityDateUtil_DateParseException_initWithNSString_(NSString *message) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerTemplateUtilityDateUtil_DateParseException)

#endif // _FreemarkerTemplateUtilityDateUtil_H_
