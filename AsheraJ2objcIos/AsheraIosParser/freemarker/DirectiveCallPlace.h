//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ramm/git/Ashera/AsheraAndroidParser/freemarker/freemarker/core/DirectiveCallPlace.java
//

#ifndef _FreemarkerCoreDirectiveCallPlace_H_
#define _FreemarkerCoreDirectiveCallPlace_H_

#include "J2ObjC_header.h"

@protocol FreemarkerTemplateUtilityObjectFactory;

/**
 @brief Gives information about the place where a directive is called from, also lets you attach a custom data object to that place.
 Each directive call in a template has its own DirectiveCallPlace object (even when they call the same directive with the same parameters). The life cycle of the DirectiveCallPlace object is bound to the Template object that contains the directive call. Hence, the DirectiveCallPlace object and the custom data you put into it is cached together with the Template (and templates are normally cached - see Configuration#getTemplate(String) ). The custom data is normally initialized on demand, that is, when the directive call is first executed, via #getOrCreateCustomData(Object,ObjectFactory) . <p> Currently this method doesn't give you access to the Template object, because it's probable that future versions of FreeMarker will be able to use the same parsed representation of a "file" for multiple Template objects. Then the call place will be bound to the parsed representation, not to the Template objects that are based on it. <p> <b>Don't implement this interface yourself</b>, as new methods can be added to it any time! It's only meant to be implemented by the FreeMarker core. <p> This interface is currently only used for custom directive calls (that is, a <code><@@...></code> that calls a TemplateDirectiveModel , TemplateTransformModel , or a macro).
 @since 2.3.22
 */
@protocol FreemarkerCoreDirectiveCallPlace < NSObject, JavaObject >

/**
 @brief The 1-based column number of the first character of the directive call in the template source code, or -1 if it's not known.
 */
- (jint)getBeginColumn;

/**
 @brief The 1-based line number of the first character of the directive call in the template source code, or -1 if it's not known.
 */
- (jint)getBeginLine;

/**
 @brief The 1-based column number of the last character of the directive call in the template source code, or -1 if it's not known.
 If the directive has an end-tag ( <code></@@...></code> ), then it points to the last character of that.
 */
- (jint)getEndColumn;

/**
 @brief The 1-based line number of the last character of the directive call in the template source code, or -1 if it's not known.
 If the directive has an end-tag ( <code></@@...></code> ), then it points to the last character of that.
 */
- (jint)getEndLine;

/**
 @brief Returns the custom data, or if that's <code>null</code> , then it creates and stores it in an atomic operation then returns it.
 This method is thread-safe, however, it doesn't ensure thread safe (like synchronized) access to the custom data itself. See the top-level documentation of DirectiveCallPlace to understand the scope and life-cycle of the custom data. Be sure that the custom data only depends on things that get their final value during template parsing, not on runtime settings. <p> This method will block other calls while the <code>objectFactory</code> is executing, thus, the object will be <em>usually</em> created only once, even if multiple threads request the value when it's still <code>null</code> . It doesn't stand though when <code>providerIdentity</code> mismatches occur (see later). Furthermore, then it's also possible that multiple objects created by the same ObjectFactory will be in use on the same time, because of directive executions already running in parallel, and because of memory synchronization delays (hardware dependent) between the threads. <p> Note that this feature will only work on Java 5 or later.
 @param providerIdentity This is usually the class of the TemplateDirectiveModel that creates (and uses) the custom data, or if you are using your own class for the custom data object (as opposed to a class from some more generic API), then that class. This is needed as the same call place might calls different directives depending on runtime conditions, and so it must be ensured that these directives won't accidentally read each other's custom data, ending up with class cast exceptions or worse. In the current implementation, if there's a <code>providerIdentity</code> mismatch (means, the <code>providerIdentity</code> object used when the custom data was last set isn't the exactly same object as the one provided with the parameter now), the previous custom data will be just ignored as if it was <code>null</code> . So if multiple directives that use the custom data feature use the same call place, the caching of the custom data can be inefficient, as they will keep overwriting each other's custom data. (In a more generic implementation the <code>providerIdentity</code> would be a key in a IdentityHashMap , but then this feature would be slower, while <code>providerIdentity</code> mismatches aren't occurring in most applications.)
 @param objectFactory Called when the custom data wasn't yet set, to create its initial value. If this parameter is <code>null</code> and the custom data wasn't set yet, then <code>null</code> will be returned. The returned value of ObjectFactory#createObject() can be any kind of object, but can't be <code>null</code> .
 @return The current custom data object, or possibly <code>null</code> if there was no ObjectFactory provided.
 @throws CallPlaceCustomDataInitializationException If the ObjectFactory had to be invoked but failed.
 */
- (id)getOrCreateCustomDataWithId:(id)providerIdentity
withFreemarkerTemplateUtilityObjectFactory:(id<FreemarkerTemplateUtilityObjectFactory>)objectFactory;

/**
 @brief Tells if the nested content (the body) can be safely cached, as it only depends on the template content (not on variable values and such) and has no side-effects (other than writing to the output).
 Examples of cases that give <code>false</code> : <code><@@foo>Name:</code> <tt>${name}</tt> <code></@@foo></code> , <code><@@foo>Name: <#if showIt>Joe</#if></@@foo></code> . Examples of cases that give <code>true</code> : <code><@@foo>Name: Joe</@@foo></code> , <code><@@foo /></code> . Note that we get <code>true</code> for no nested content, because that's equivalent with 0-length nested content in FTL. <p> This method returns a pessimistic result. For example, if it sees a custom directive call, it can't know what it does, so it will assume that it's not cacheable.
 */
- (jboolean)isNestedOutputCacheable;

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerCoreDirectiveCallPlace)

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerCoreDirectiveCallPlace)

#endif // _FreemarkerCoreDirectiveCallPlace_H_
