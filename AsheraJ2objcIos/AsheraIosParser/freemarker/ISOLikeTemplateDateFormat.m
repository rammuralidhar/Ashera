//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ramm/git/Ashera/AsheraAndroidParser/freemarker/freemarker/core/ISOLikeTemplateDateFormat.java
//


#include "BugException.h"
#include "DateUtil.h"
#include "IOSClass.h"
#include "ISOLikeTemplateDateFormat.h"
#include "ISOLikeTemplateDateFormatFactory.h"
#include "J2ObjC_source.h"
#include "StringUtil.h"
#include "TemplateDateFormat.h"
#include "TemplateDateModel.h"
#include "TemplateModelException.h"
#include "UnknownDateTypeFormattingUnsupportedException.h"
#include "java/lang/Boolean.h"
#include "java/text/ParseException.h"
#include "java/util/Date.h"
#include "java/util/TimeZone.h"

#line 0 "/Users/ramm/git/Ashera/AsheraAndroidParser/freemarker/freemarker/core/ISOLikeTemplateDateFormat.java"

@interface FreemarkerCoreISOLikeTemplateDateFormat () {
 @public
  FreemarkerCoreISOLikeTemplateDateFormatFactory *factory_;
}

- (void)checkForceUTCNotSetWithJavaLangBoolean:(JavaLangBoolean *)fourceUTC
                                       withInt:(jint)i;

@end

J2OBJC_FIELD_SETTER(FreemarkerCoreISOLikeTemplateDateFormat, factory_, FreemarkerCoreISOLikeTemplateDateFormatFactory *)

static NSString *FreemarkerCoreISOLikeTemplateDateFormat_XS_LESS_THAN_SECONDS_ACCURACY_ERROR_MESSAGE_ = 
#line 34
@"Less than seconds accuracy isn't allowed by the XML Schema format";
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreISOLikeTemplateDateFormat, XS_LESS_THAN_SECONDS_ACCURACY_ERROR_MESSAGE_, NSString *)

__attribute__((unused)) static void FreemarkerCoreISOLikeTemplateDateFormat_checkForceUTCNotSetWithJavaLangBoolean_withInt_(FreemarkerCoreISOLikeTemplateDateFormat *self, JavaLangBoolean *fourceUTC, jint i);


#line 31
@implementation FreemarkerCoreISOLikeTemplateDateFormat


#line 48
- (instancetype)initWithNSString:(NSString *)settingValue
                         withInt:(jint)parsingStart
                         withInt:(jint)dateType
                     withBoolean:(jboolean)zonelessInput
            withJavaUtilTimeZone:(JavaUtilTimeZone *)timeZone
withFreemarkerCoreISOLikeTemplateDateFormatFactory:(FreemarkerCoreISOLikeTemplateDateFormatFactory *)factory {
  FreemarkerCoreISOLikeTemplateDateFormat_initWithNSString_withInt_withInt_withBoolean_withJavaUtilTimeZone_withFreemarkerCoreISOLikeTemplateDateFormatFactory_(self, settingValue, parsingStart, dateType, zonelessInput, timeZone, factory);
  return self;
}


#line 162
- (void)checkForceUTCNotSetWithJavaLangBoolean:(JavaLangBoolean *)fourceUTC
                                       withInt:(jint)i {
  FreemarkerCoreISOLikeTemplateDateFormat_checkForceUTCNotSetWithJavaLangBoolean_withInt_(self, fourceUTC, i);
}


#line 169
- (NSString *)formatWithFreemarkerTemplateTemplateDateModel:(id<FreemarkerTemplateTemplateDateModel>)dateModel {
  JavaUtilDate *date = [((id<FreemarkerTemplateTemplateDateModel>) nil_chk(dateModel)) getAsDate];
  return [self formatWithJavaUtilDate:
#line 172
  date withBoolean:
#line 173
  dateType_ != FreemarkerTemplateTemplateDateModel_TIME withBoolean:
#line 174
  dateType_ != FreemarkerTemplateTemplateDateModel_DATE withBoolean:
#line 175
  showZoneOffset_ == nil ?
#line 176
  !zonelessInput_ :
#line 177
  [showZoneOffset_ booleanValue] withInt:
#line 178
  accuracy_ withJavaUtilTimeZone:
#line 179
  (forceUTC_ == nil ? !zonelessInput_ : [forceUTC_ booleanValue]) ? FreemarkerTemplateUtilityDateUtil_get_UTC_() : timeZone_ withFreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory:
#line 180
  [((FreemarkerCoreISOLikeTemplateDateFormatFactory *) nil_chk(factory_)) getISOBuiltInCalendar]];
}


#line 183
- (NSString *)formatWithJavaUtilDate:(JavaUtilDate *)date
                         withBoolean:(jboolean)datePart
                         withBoolean:(jboolean)timePart
                         withBoolean:(jboolean)offsetPart
                             withInt:(jint)accuracy
                withJavaUtilTimeZone:(JavaUtilTimeZone *)timeZone
withFreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory:(id<FreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory>)calendarFactory {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 189
- (JavaUtilDate *)parseWithNSString:(NSString *)s {
  id<FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter> calToDateConverter = [((FreemarkerCoreISOLikeTemplateDateFormatFactory *) nil_chk(factory_)) getCalendarFieldsToDateCalculator];
  JavaUtilTimeZone *tz = forceUTC_ != JavaLangBoolean_get_FALSE__() ? FreemarkerTemplateUtilityDateUtil_get_UTC_() : timeZone_;
  if (dateType_ == FreemarkerTemplateTemplateDateModel_DATE) {
    return [self parseDateWithNSString:s withJavaUtilTimeZone:tz withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter:calToDateConverter];
  }
  else
#line 194
  if (dateType_ == FreemarkerTemplateTemplateDateModel_TIME) {
    return [self parseTimeWithNSString:s withJavaUtilTimeZone:tz withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter:calToDateConverter];
  }
  else
#line 196
  if (dateType_ == FreemarkerTemplateTemplateDateModel_DATETIME) {
    return [self parseDateTimeWithNSString:s withJavaUtilTimeZone:tz withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter:calToDateConverter];
  }
  else {
    
#line 199
    @throw new_FreemarkerCoreBugException_initWithNSString_(JreStrcat("$I", @"Unexpected date type: ", dateType_));
  }
}


#line 203
- (JavaUtilDate *)parseDateWithNSString:(NSString *)s
                   withJavaUtilTimeZone:(JavaUtilTimeZone *)tz
withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter:(id<FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter>)calToDateConverter {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 208
- (JavaUtilDate *)parseTimeWithNSString:(NSString *)s
                   withJavaUtilTimeZone:(JavaUtilTimeZone *)tz
withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter:(id<FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter>)calToDateConverter {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 213
- (JavaUtilDate *)parseDateTimeWithNSString:(NSString *)s
                       withJavaUtilTimeZone:(JavaUtilTimeZone *)tz
withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter:(id<FreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter>)calToDateConverter {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 218
- (NSString *)getDescription {
  switch (dateType_) {
    case FreemarkerTemplateTemplateDateModel_DATE:
    
#line 220
    return [self getDateDescription];
    case FreemarkerTemplateTemplateDateModel_TIME:
    
#line 221
    return [self getTimeDescription];
    case FreemarkerTemplateTemplateDateModel_DATETIME:
    
#line 222
    return [self getDateTimeDescription];
    default:
    
#line 223
    return @"<error: wrong format dateType>";
  }
}


#line 227
- (NSString *)getDateDescription {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 228
- (NSString *)getTimeDescription {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 229
- (NSString *)getDateTimeDescription {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 231
- (jboolean)isLocaleBound {
  return NO;
}

- (jboolean)isXSMode {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithNSString:withInt:withInt:withBoolean:withJavaUtilTimeZone:withFreemarkerCoreISOLikeTemplateDateFormatFactory:", "ISOLikeTemplateDateFormat", NULL, 0x1, "Ljava.text.ParseException;Lfreemarker.core.UnknownDateTypeFormattingUnsupportedException;", NULL },
    { "checkForceUTCNotSetWithJavaLangBoolean:withInt:", "checkForceUTCNotSet", "V", 0x2, "Ljava.text.ParseException;", NULL },
    { "formatWithFreemarkerTemplateTemplateDateModel:", "format", "Ljava.lang.String;", 0x11, "Lfreemarker.template.TemplateModelException;", NULL },
    { "formatWithJavaUtilDate:withBoolean:withBoolean:withBoolean:withInt:withJavaUtilTimeZone:withFreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory:", "format", "Ljava.lang.String;", 0x404, NULL, NULL },
    { "parseWithNSString:", "parse", "Ljava.util.Date;", 0x11, "Ljava.text.ParseException;", NULL },
    { "parseDateWithNSString:withJavaUtilTimeZone:withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter:", "parseDate", "Ljava.util.Date;", 0x404, "Lfreemarker.template.utility.DateUtil$DateParseException;", NULL },
    { "parseTimeWithNSString:withJavaUtilTimeZone:withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter:", "parseTime", "Ljava.util.Date;", 0x404, "Lfreemarker.template.utility.DateUtil$DateParseException;", NULL },
    { "parseDateTimeWithNSString:withJavaUtilTimeZone:withFreemarkerTemplateUtilityDateUtil_CalendarFieldsToDateConverter:", "parseDateTime", "Ljava.util.Date;", 0x404, "Lfreemarker.template.utility.DateUtil$DateParseException;", NULL },
    { "getDescription", NULL, "Ljava.lang.String;", 0x11, NULL, NULL },
    { "getDateDescription", NULL, "Ljava.lang.String;", 0x404, NULL, NULL },
    { "getTimeDescription", NULL, "Ljava.lang.String;", 0x404, NULL, NULL },
    { "getDateTimeDescription", NULL, "Ljava.lang.String;", 0x404, NULL, NULL },
    { "isLocaleBound", NULL, "Z", 0x11, NULL, NULL },
    { "isXSMode", NULL, "Z", 0x404, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "XS_LESS_THAN_SECONDS_ACCURACY_ERROR_MESSAGE_", NULL, 0x1a, "Ljava.lang.String;", &FreemarkerCoreISOLikeTemplateDateFormat_XS_LESS_THAN_SECONDS_ACCURACY_ERROR_MESSAGE_, NULL,  },
    { "factory_", NULL, 0x12, "Lfreemarker.core.ISOLikeTemplateDateFormatFactory;", NULL, NULL,  },
    { "dateType_", NULL, 0x14, "I", NULL, NULL,  },
    { "zonelessInput_", NULL, 0x14, "Z", NULL, NULL,  },
    { "timeZone_", NULL, 0x14, "Ljava.util.TimeZone;", NULL, NULL,  },
    { "forceUTC_", NULL, 0x14, "Ljava.lang.Boolean;", NULL, NULL,  },
    { "showZoneOffset_", NULL, 0x14, "Ljava.lang.Boolean;", NULL, NULL,  },
    { "accuracy_", NULL, 0x14, "I", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _FreemarkerCoreISOLikeTemplateDateFormat = { 2, "ISOLikeTemplateDateFormat", "freemarker.core", NULL, 0x400, 14, methods, 8, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_FreemarkerCoreISOLikeTemplateDateFormat;
}

@end


#line 48
void FreemarkerCoreISOLikeTemplateDateFormat_initWithNSString_withInt_withInt_withBoolean_withJavaUtilTimeZone_withFreemarkerCoreISOLikeTemplateDateFormatFactory_(FreemarkerCoreISOLikeTemplateDateFormat *self, NSString *settingValue, jint parsingStart, jint dateType, jboolean zonelessInput, JavaUtilTimeZone *timeZone, FreemarkerCoreISOLikeTemplateDateFormatFactory *factory) {
  (void) FreemarkerCoreTemplateDateFormat_init(self);
  
#line 54
  self->factory_ = factory;
  if (dateType == FreemarkerTemplateTemplateDateModel_UNKNOWN) {
    @throw new_FreemarkerCoreUnknownDateTypeFormattingUnsupportedException_init();
  }
  
#line 59
  self->dateType_ = dateType;
  self->zonelessInput_ = zonelessInput;
  
#line 62
  jint ln = ((jint) [((NSString *) nil_chk(settingValue)) length]);
  jboolean afterSeparator = NO;
  jint i = parsingStart;
  jint accuracy = FreemarkerTemplateUtilityDateUtil_ACCURACY_MILLISECONDS;
  JavaLangBoolean *showZoneOffset = nil;
  JavaLangBoolean *forceUTC = JavaLangBoolean_get_FALSE__();
  while (i < ln) {
    jchar c = [settingValue charAtWithInt:i++];
    if (c == '_' || c == ' ') {
      afterSeparator = YES;
    }
    else {
      
#line 73
      if (!afterSeparator) {
        @throw new_JavaTextParseException_initWithNSString_withInt_(JreStrcat("$CC", @"Missing space or \"_\" before \"",
#line 75
        c, '"'), i);
      }
      
#line 78
      switch (c) {
        case 'h':
        case 'm':
        case 's':
        if (accuracy != FreemarkerTemplateUtilityDateUtil_ACCURACY_MILLISECONDS) {
          @throw new_JavaTextParseException_initWithNSString_withInt_(JreStrcat("$C$", @"Character \"",
#line 84
          c, @"\" is unexpected as accuracy was already specified earlier."), i);
        }
        switch (c) {
          case 'h':
          if ([self isXSMode]) {
            @throw new_JavaTextParseException_initWithNSString_withInt_(FreemarkerCoreISOLikeTemplateDateFormat_XS_LESS_THAN_SECONDS_ACCURACY_ERROR_MESSAGE_, i);
          }
          accuracy = FreemarkerTemplateUtilityDateUtil_ACCURACY_HOURS;
          break;
          case 'm':
          if (i < ln && [settingValue charAtWithInt:i] == 's') {
            i++;
            accuracy = FreemarkerTemplateUtilityDateUtil_ACCURACY_MILLISECONDS_FORCED;
          }
          else {
            
#line 98
            if ([self isXSMode]) {
              @throw new_JavaTextParseException_initWithNSString_withInt_(FreemarkerCoreISOLikeTemplateDateFormat_XS_LESS_THAN_SECONDS_ACCURACY_ERROR_MESSAGE_, i);
            }
            accuracy = FreemarkerTemplateUtilityDateUtil_ACCURACY_MINUTES;
          }
          break;
          case 's':
          accuracy = FreemarkerTemplateUtilityDateUtil_ACCURACY_SECONDS;
          break;
        }
        break;
        case 'f':
        if (i < ln && [settingValue charAtWithInt:i] == 'u') {
          FreemarkerCoreISOLikeTemplateDateFormat_checkForceUTCNotSetWithJavaLangBoolean_withInt_(self, forceUTC, i);
          i++;
          forceUTC = JavaLangBoolean_get_TRUE__();
          break;
        }
        
#line 117
        case 'n':
        if (showZoneOffset != nil) {
          @throw new_JavaTextParseException_initWithNSString_withInt_(JreStrcat("$C$", @"Character \"",
#line 120
          c, @"\" is unexpected as zone offset visibility was already specified earlier."),
#line 121
          i);
        }
        switch (c) {
          case 'n':
          if (i < ln && [settingValue charAtWithInt:i] == 'z') {
            i++;
            showZoneOffset = JavaLangBoolean_get_FALSE__();
          }
          else {
            
#line 129
            @throw new_JavaTextParseException_initWithNSString_withInt_(@"\"n\" must be followed by \"z\"", i);
          }
          break;
          case 'f':
          if (i < ln && [settingValue charAtWithInt:i] == 'z') {
            i++;
            showZoneOffset = JavaLangBoolean_get_TRUE__();
          }
          else {
            
#line 137
            @throw new_JavaTextParseException_initWithNSString_withInt_(@"\"f\" must be followed by \"z\"", i);
          }
          break;
        }
        break;
        case 'u':
        FreemarkerCoreISOLikeTemplateDateFormat_checkForceUTCNotSetWithJavaLangBoolean_withInt_(self, forceUTC, i);
        forceUTC = nil;
        break;
        default:
        @throw new_JavaTextParseException_initWithNSString_withInt_(JreStrcat("$$$", @"Unexpected character, ", FreemarkerTemplateUtilityStringUtil_jQuoteWithNSString_(NSString_valueOfChar_(
#line 148
        c)), @". Expected the beginning of one of: h, m, s, ms, nz, fz, u"),
#line 150
        i);
      }
      afterSeparator = NO;
    }
  }
  
#line 156
  self->accuracy_ = accuracy;
  self->showZoneOffset_ = showZoneOffset;
  self->forceUTC_ = forceUTC;
  self->timeZone_ = timeZone;
}


#line 162
void FreemarkerCoreISOLikeTemplateDateFormat_checkForceUTCNotSetWithJavaLangBoolean_withInt_(FreemarkerCoreISOLikeTemplateDateFormat *self, JavaLangBoolean *fourceUTC, jint i) {
  if (fourceUTC != JavaLangBoolean_get_FALSE__()) {
    @throw new_JavaTextParseException_initWithNSString_withInt_(
#line 165
    @"The UTC usage option was already set earlier.", i);
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(FreemarkerCoreISOLikeTemplateDateFormat)
