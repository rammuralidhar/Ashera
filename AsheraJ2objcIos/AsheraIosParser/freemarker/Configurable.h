//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ramm/git/Ashera/AsheraAndroidParser/freemarker/freemarker/core/Configurable.java
//

#ifndef _FreemarkerCoreConfigurable_H_
#define _FreemarkerCoreConfigurable_H_

#include "J2ObjC_header.h"
#include "_MiscTemplateException.h"

@class FreemarkerCoreArithmeticEngine;
@class FreemarkerCoreCustomAttribute;
@class FreemarkerCoreEnvironment;
@class FreemarkerTemplateTemplateException;
@class FreemarkerTemplateVersion;
@class IOSObjectArray;
@class JavaIoInputStream;
@class JavaLangThrowable;
@class JavaUtilArrayList;
@class JavaUtilHashMap;
@class JavaUtilLocale;
@class JavaUtilProperties;
@class JavaUtilTimeZone;
@protocol FreemarkerCoreTemplateClassResolver;
@protocol FreemarkerTemplateObjectWrapper;
@protocol FreemarkerTemplateTemplateExceptionHandler;
@protocol JavaUtilMap;
@protocol JavaUtilSet;

/**
 @brief This is a common superclass of freemarker.template.Configuration , freemarker.template.Template , and Environment classes.
 It provides settings that are common to each of them. FreeMarker uses a three-level setting hierarchy - the return value of every setting getter method on <code>Configurable</code> objects inherits its value from its parent <code>Configurable</code> object, unless explicitly overridden by a call to a corresponding setter method on the object itself. The parent of an <code>Environment</code> object is a <code>Template</code> object, the parent of a <code>Template</code> object is a <code>Configuration</code> object.
 */
@interface FreemarkerCoreConfigurable : NSObject

#pragma mark Public

/**
 @brief Creates a top-level configurable, one that doesn't inherit from a parent, and thus stores the default values.
 */
- (instancetype)init;

/**
 @brief Creates a new instance.
 Normally you do not need to use this constructor, as you don't use <code>Configurable</code> directly, but its subclasses.
 */
- (instancetype)initWithFreemarkerCoreConfigurable:(FreemarkerCoreConfigurable *)parent;

/**
 @brief The getter pair of #setArithmeticEngine(ArithmeticEngine) .
 */
- (FreemarkerCoreArithmeticEngine *)getArithmeticEngine;

/**
 @brief See #setAutoFlush(boolean)
 @since 2.3.17
 */
- (jboolean)getAutoFlush;

/**
 @brief The getter pair of #setBooleanFormat(String) .
 */
- (NSString *)getBooleanFormat;

- (jint)getClassicCompatibleAsInt;

/**
 @brief Retrieves a named custom attribute for this configurable.
 If the attribute is not present in the configurable, and the configurable has a parent, then the parent is looked up as well.
 @param name the name of the custom attribute
 @return the value of the custom attribute. Note that if the custom attribute was created with <tt>&lt;#ftl&nbsp;attributes={...}&gt;</tt>, then this value is already unwrapped (i.e. it's a <code>String</code>, or a <code>List</code>, or a <code>Map</code>, ...etc., not a FreeMarker specific class).
 */
- (id)getCustomAttributeWithNSString:(NSString *)name;

/**
 @brief Returns an array with names of all custom attributes defined directly on this configurable.
 (That is, it doesn't contain the names of custom attributes defined indirectly on its parent configurables.) The returned array is never null, but can be zero-length. The order of elements in the returned array is not defined and can change between invocations.
 */
- (IOSObjectArray *)getCustomAttributeNames;

/**
 @brief The getter pair of #setDateFormat(String) .
 */
- (NSString *)getDateFormat;

/**
 @brief The getter pair of #setDateTimeFormat(String) .
 */
- (NSString *)getDateTimeFormat;

/**
 @brief Returns the assumed locale when searching for template files with no explicit requested locale.
 Defaults to system locale.
 */
- (JavaUtilLocale *)getLocale;

/**
 @brief See #setLogTemplateExceptions(boolean)
 @since 2.3.22
 */
- (jboolean)getLogTemplateExceptions;

/**
 @brief Retrieves the TemplateClassResolver used to resolve classes when "SomeClassName"?
 new is called in a template.
 @since 2.3.17
 */
- (id<FreemarkerCoreTemplateClassResolver>)getNewBuiltinClassResolver;

/**
 @brief Getter pair of #setNumberFormat(String) .
 */
- (NSString *)getNumberFormat;

/**
 @brief The getter pair of #setObjectWrapper(ObjectWrapper) .
 */
- (id<FreemarkerTemplateObjectWrapper>)getObjectWrapper;

- (NSString *)getOutputEncoding;

/**
 @brief Returns the parent Configurable object of this object.
 The parent stores the default setting values for this Configurable . For example, the parent of a freemarker.template.Template object is a Configuration object, so values not specified on Template -level are get from the Configuration object. <p> Note on the parent of Environment : If you set Configuration#setIncompatibleImprovements(Version) incompatible_improvements to at least 2.3.22, it will be always the "main" Template , that is, the template for whose processing the Environment was created. With lower <code>incompatible_improvements</code> , the current parent can temporary change <em>during template execution</em>, for example when your are inside an <code>#include</code> -d template (among others). Thus, don't build on which Template the parent of Environment is during template execution, unless you set <code>incompatible_improvements</code> to 2.3.22 or higher.
 @return The parent Configurable object, or <code>null</code> if this is the root Configurable object (i.e, if it's the Configuration object).
 */
- (FreemarkerCoreConfigurable *)getParent;

/**
 @brief Returns the textual representation of a setting.
 @param key the setting key. Can be any of standard <tt>XXX_KEY</tt> constants, or a custom key.
 */
- (NSString *)getSettingWithNSString:(NSString *)key;

/**
 @brief This meant to return the String-to-String <code>Map</code> of the settings.
 So it actually should return a <code>Properties</code> object, but it doesn't by mistake. The returned <code>Map</code> is read-only, but it will reflect the further configuration changes (aliasing effect).
 */
- (id<JavaUtilMap>)getSettings;

/**
 @brief See #setShowErrorTips(boolean)
 @since 2.3.21
 */
- (jboolean)getShowErrorTips;

/**
 @brief The getter pair of #setSQLDateAndTimeTimeZone(TimeZone) .
 @return <code>null</code> if the value of #getTimeZone() should be used for formatting java.sql.Date java.sql.Date and java.sql.Time java.sql.Time values, otherwise the time zone that should be used to format the values of those two types.
 @since 2.3.21
 */
- (JavaUtilTimeZone *)getSQLDateAndTimeTimeZone;

/**
 @brief The getter pair of #setTemplateExceptionHandler(TemplateExceptionHandler) .
 */
- (id<FreemarkerTemplateTemplateExceptionHandler>)getTemplateExceptionHandler;

/**
 @brief The getter pair of #setTimeFormat(String) .
 */
- (NSString *)getTimeFormat;

/**
 @brief The getter pair of #setTimeZone(TimeZone) .
 */
- (JavaUtilTimeZone *)getTimeZone;

- (NSString *)getURLEscapingCharset;

/**
 @brief See #setAPIBuiltinEnabled(boolean)
 @since 2.3.22
 */
- (jboolean)isAPIBuiltinEnabled;

/**
 @brief Returns whether the engine runs in the "Classic Compatibile" mode.
 When this mode is active, the engine behavior is altered in following way: (these resemble the behavior of the 1.7.x line of FreeMarker engine, now named "FreeMarker Classic", hence the name). <ul> <li>handle undefined expressions gracefully. Namely when an expression "expr" evaluates to null: <ul> <li> in <tt>&lt;assign varname=expr&gt;</tt> directive, or in <tt>${expr}</tt> directive, or in <tt>otherexpr == expr</tt>, or in <tt>otherexpr != expr</tt>, or in <tt>hash[expr]</tt>, or in <tt>expr[keyOrIndex]</tt> (since 2.3.20), or in <tt>expr.key</tt> (since 2.3.20), then it's treated as empty string. </li> <li>as argument of <tt>&lt;list expr as item&gt;</tt> or <tt>&lt;foreach item in expr&gt;</tt>, the loop body is not executed (as if it were a 0-length list) </li> <li>as argument of <tt>&lt;if&gt;</tt> directive, or on other places where a boolean expression is expected, it's treated as false </li> </ul> </li> <li>Non-boolean models are accepted in <tt>&lt;if&gt;</tt> directive, or as operands of logical operators. "Empty" models (zero-length string, empty sequence or hash) are evaluated as false, all others are evaluated as true.</li> <li>When boolean value is treated as a string (i.e. output in <tt>${...}</tt> directive, or concatenated with other string), true values are converted to string "true", false values are converted to empty string. Except, if the value of the setting is <tt>2</tt>, it will be formatted according the <tt>boolean_format</tt> setting, just like in 2.3.20 and later. </li> <li>Scalar models supplied to <tt>&lt;list&gt;</tt> and <tt>&lt;foreach&gt;</tt> are treated as a one-element list consisting of the passed model. </li> <li>Paths parameter of <tt>&lt;include&gt;</tt> will be interpreted as absolute path. </li> </ul> In all other aspects, the engine is a 2.1 engine even in compatibility mode - you don't lose any of the new functionality by enabling it.
 */
- (jboolean)isClassicCompatible;

/**
 @brief Removes a named custom attribute for this configurable.
 Note that this is different than setting the custom attribute value to null. If you set the value to null, #getCustomAttribute(String) will return null, while if you remove the attribute, it will return the value of the attribute in the parent configurable (if there is a parent configurable, that is).
 @param name the name of the custom attribute
 */
- (void)removeCustomAttributeWithNSString:(NSString *)name;

/**
 @brief Specifies if <code>?
 api</code> can be used in templates. Defaults to <code>false</code> so that updating FreeMarker won't decrease the security of existing applications.
 @since 2.3.22
 */
- (void)setAPIBuiltinEnabledWithBoolean:(jboolean)value;

/**
 @brief Sets the arithmetic engine used to perform arithmetic operations.
 The default is ArithmeticEngine#BIGDECIMAL_ENGINE .
 */
- (void)setArithmeticEngineWithFreemarkerCoreArithmeticEngine:(FreemarkerCoreArithmeticEngine *)arithmeticEngine;

/**
 @brief Sets whether the output Writer is automatically flushed at the end of Template#process(Object,Writer) (and its overloads).
 The default is <code>true</code> . <p>Using <code>false</code> is needed for example when a Web page is composed from several boxes (like portlets, GUI panels, etc.) that aren't inserted with <tt>#include</tt> (or with similar directives) into a master FreeMarker template, rather they are all processed with a separate Template#process(Object,Writer) call. In a such scenario the automatic flushes would commit the HTTP response after each box, hence interfering with full-page buffering, and also possibly decreasing performance with too frequent and too early response buffer flushes.
 @since 2.3.17
 */
- (void)setAutoFlushWithBoolean:(jboolean)autoFlush;

/**
 @brief The string value for the boolean <code>true</code> and <code>false</code> values, intended for human audience (not for a computer language), separated with comma.
 For example, <code>"yes,no"</code> . Note that white-space is significant, so <code>"yes, no"</code> is WRONG (unless you want that leading space before "no"). <p>For backward compatibility the default is <code>"true,false"</code> , but using that value is denied for automatic boolean-to-string conversion (like <code>${myBoolean}</code> will fail with it), only <code>myBool?string</code> will allow it, which is deprecated since FreeMarker 2.3.20. <p>Note that automatic boolean-to-string conversion only exists since FreeMarker 2.3.20. Earlier this setting only influenced the result of <code>myBool?string</code> .
 */
- (void)setBooleanFormatWithNSString:(NSString *)booleanFormat;

/**
 @brief Toggles the "Classic Compatible" mode.
 For a comprehensive description of this mode, see #isClassicCompatible() .
 */
- (void)setClassicCompatibleWithBoolean:(jboolean)classicCompatibility;

/**
 @brief Same as #setClassicCompatible(boolean) , but allows some extra values.
 @param classicCompatibility  <code>0</code> means <code>false</code> , <code>1</code> means <code>true</code> , <code>2</code> means <code>true</code> but with emulating bugs in early 2.x classic-compatibility mode. Currently <code>2</code> affects how booleans are converted to string; with <code>1</code> it's always <code>"true"</code> / <code>""</code> , but with <code>2</code> it's <code>"true"</code> / <code>"false"</code> for values wrapped by BeansWrapper as then Boolean#toString() prevails. Note that <code>someBoolean?string</code> will always consistently format the boolean according the <code>boolean_format</code> setting, just like in FreeMarker 2.3 and later.
 */
- (void)setClassicCompatibleAsIntWithInt:(jint)classicCompatibility;

/**
 @brief Sets a named custom attribute for this configurable.
 @param name the name of the custom attribute
 @param value the value of the custom attribute. You can set the value to null, however note that there is a semantic difference between an attribute set to null and an attribute that is not present, see #removeCustomAttribute(String) .
 */
- (void)setCustomAttributeWithNSString:(NSString *)name
                                withId:(id)value;

/**
 @brief Sets the format used to convert java.util.Date -s to string-s that are date (no time part) values, also the format that <code>someString?
 date</code> will use to parse strings. <p>For the possible values see #setDateTimeFormat(String) . <p>Defaults to <code>""</code> , which means "use the FreeMarker default", which is currently <code>"code"</code> .
 */
- (void)setDateFormatWithNSString:(NSString *)dateFormat;

/**
 @brief Sets the format used to convert java.util.Date -s to string-s that are date-time (timestamp) values, also the format that <code>someString?
 datetime</code> will use to parse strings. <p>The possible setting values are (the quotation marks aren't part of the value itself): <ul> <li><p>Patterns accepted by Java's SimpleDateFormat , for example <code>"dd.MM.yyyy HH:mm:ss"</code> (where <code>HH</code> means 24 hours format) or <code>"MM/dd/yyyy hh:mm:ss a"</code> (where <code>a</code> prints AM or PM, if the current language is English). <li><p> <code>"xs"</code> for XML Schema format, or <code>"iso"</code> for ISO 8601:2004 format. These formats allow various additional options, separated with space, like in <code>"iso m nz"</code> (or with <code>_</code> , like in <code>"iso_m_nz"</code> ; this is useful in a case like <code>lastModified?string.iso_m_nz</code> ). The options and their meanings are: <ul> <li><p>Accuracy options:<br> <code>ms</code> = Milliseconds, always shown with all 3 digits, even if it's all 0-s. Example: <code>13:45:05.800</code> <br> <code>s</code> = Seconds (fraction seconds are dropped even if non-0), like <code>13:45:05</code> <br> <code>m</code> = Minutes, like <code>13:45</code> . This isn't allowed for "xs".<br> <code>h</code> = Hours, like <code>13</code> . This isn't allowed for "xs".<br> Neither = Up to millisecond accuracy, but trailing millisecond 0-s are removed, also the whole milliseconds part if it would be 0 otherwise. Example: <code>13:45:05.8</code> <li><p>Time zone offset visibility options:<br> <code>fz</code> = "Force Zone", always show time zone offset (even for for java.sql.Date java.sql.Date and java.sql.Time java.sql.Time values). But, because ISO 8601 doesn't allow for dates (means date without time of the day) to show the zone offset, this option will have no effect in the case of <code>"iso"</code> with dates.<br> <code>nz</code> = "No Zone", never show time zone offset<br> Neither = always show time zone offset, except for java.sql.Date java.sql.Date and java.sql.Time java.sql.Time , and for <code>"iso"</code> date values. <li><p>Time zone options:<br> <code>u</code> = Use UTC instead of what the <code>time_zone</code> setting suggests. However, java.sql.Date java.sql.Date and java.sql.Time java.sql.Time aren't affected by this (see #setSQLDateAndTimeTimeZone(TimeZone) to understand why)<br> <code>fu</code> = "Force UTC", that is, use UTC instead of what the <code>time_zone</code> or the <code>sql_date_and_time_time_zone</code> setting suggests. This also effects java.sql.Date java.sql.Date and java.sql.Time java.sql.Time values<br> Neither = Use the time zone suggested by the <code>time_zone</code> or the <code>sql_date_and_time_time_zone</code> configuration setting ( #setTimeZone(TimeZone) and #setSQLDateAndTimeTimeZone(TimeZone) ). </ul> <p>The options can be specified in any order.</p> <p>Options from the same category are mutually exclusive, like using <code>m</code> and <code>s</code> together is an error. <p>The accuracy and time zone offset visibility options don't influence parsing, only formatting. For example, even if you use "iso m nz", "2012-01-01T15:30:05.125+01" will be parsed successfully and with milliseconds accuracy. The time zone options (like "u") influence what time zone is chosen only when parsing a string that doesn't contain time zone offset. <p>Parsing with <code>"iso"</code> understands both extend format and basic format, like <code>20141225T235018</code> . It doesn't, however, support the parsing of all kind of ISO 8601 strings: if there's a date part, it must use year, month and day of the month values (not week of the year), and the day can't be omitted. <p>The output of <code>"iso"</code> is deliberately so that it's also a good representation of the value with XML Schema format, except for 0 and negative years, where it's impossible. Also note that the time zone offset is omitted for date values in the <code>"iso"</code> format, while it's preserved for the <code>"xs"</code> format. <li><p> <code>"short"</code> , <code>"medium"</code> , <code>"long"</code> , or <code>"full"</code> , which that has locale-dependent meaning defined by the Java platform (see in the documentation of java.text.DateFormat ). For date-time values, you can specify the length of the date and time part independently, be separating them with <code>_</code> , like <code>"short_medium"</code> . ( <code>"medium"</code> means <code>"medium_medium"</code> for date-time values.) </ul> <p>Defaults to <code>""</code> , which means "use the FreeMarker default", which is currently <code>"code"</code> .
 */
- (void)setDateTimeFormatWithNSString:(NSString *)dateTimeFormat;

/**
 @brief Sets the default locale used for number and date formatting (among others), also the locale used for searching localized template variations when no locale was explicitly requested.
 */
- (void)setLocaleWithJavaUtilLocale:(JavaUtilLocale *)locale;

/**
 @brief Specifies if TemplateException -s thrown by template processing are logged by FreeMarker or not.
 The default is <code>true</code> for backward compatibility, but that results in logging the exception twice in properly written applications, because there the TemplateException thrown by the public FreeMarker API is also logged by the caller (even if only as the cause exception of a higher level exception). Hence, in modern applications it should be set to <code>false</code> . Note that this setting has no effect on the logging of exceptions caught by <code>#attempt</code> ; those are always logged, no mater what (because those exceptions won't bubble up until the API caller).
 @since 2.3.22
 */
- (void)setLogTemplateExceptionsWithBoolean:(jboolean)value;

/**
 @brief Sets the TemplateClassResolver that is used when the <code>new</code> built-in is called in a template.
 That is, when a template contains the <code>"com.example.SomeClassName"?new</code> expression, this object will be called to resolve the <code>"com.example.SomeClassName"</code> string to a class. The default value is TemplateClassResolver#UNRESTRICTED_RESOLVER in FreeMarker 2.3.x, and TemplateClassResolver#SAFER_RESOLVER starting from FreeMarker 2.4.0. If you allow users to upload templates, it's important to use a custom restrictive TemplateClassResolver .
 @since 2.3.17
 */
- (void)setNewBuiltinClassResolverWithFreemarkerCoreTemplateClassResolver:(id<FreemarkerCoreTemplateClassResolver>)newBuiltinClassResolver;

/**
 @brief Sets the default number format used to convert numbers to strings.
 Currently, this is either a java.text.DecimalFormat pattern (like <code>"0.##"</code> ), or one of the following special values: <ul> <li> <code>"number"</code> : The number format returned by NumberFormat#getNumberInstance(Locale) </li> <li> <code>"currency"</code> : The number format returned by NumberFormat#getCurrencyInstance(Locale) </li> <li> <code>"percent"</code> : The number format returned by NumberFormat#getPercentInstance(Locale) </li> <li> <code>"computer"</code> : The number format used by FTL's <code>c</code> built-in (like in <code>someNumber?c</code> ).</li> </ul> <p>Defaults to <tt>"number"</tt>.
 */
- (void)setNumberFormatWithNSString:(NSString *)numberFormat;

/**
 @brief Sets the object wrapper used to wrap objects to TemplateModel -s.
 The default is ObjectWrapper#DEFAULT_WRAPPER .
 */
- (void)setObjectWrapperWithFreemarkerTemplateObjectWrapper:(id<FreemarkerTemplateObjectWrapper>)objectWrapper;

/**
 @brief Informs FreeMarker about the charset used for the output.
 As FreeMarker outputs character stream (not byte stream), it's not aware of the output charset unless the software that encloses it tells it with this setting. Some templates may use FreeMarker features that require this information. Setting this to <code>null</code> means that the output encoding is not known. <p>Defaults to <code>null</code> (unknown).
 */
- (void)setOutputEncodingWithNSString:(NSString *)outputEncoding;

/**
 @brief Sets a FreeMarker setting by a name and string value.
 If you can configure FreeMarker directly with Java (or other programming language), you should use the dedicated setter methods instead (like #setObjectWrapper(ObjectWrapper) . This meant to be used if you get the settings from somewhere as text. Regardless, below you will find an overview of the settings available no matter how you set them. <p>Note: As of FreeMarker 2.3.23, setting names can be written in camel case too. For example, instead of <code>date_format</code> you can also use <code>dateFormat</code> . It's likely that camel case will become to the recommended convention in the future. <p>The list of settings commonly supported in all Configurable subclasses: <ul> <li><p> <code>"locale"</code> : See #setLocale(Locale) . <br>String value: local codes with the usual format in Java, such as <code>"en_US"</code> . <li><p> <code>"classic_compatible"</code> : See #setClassicCompatible(boolean) and Configurable#setClassicCompatibleAsInt(int) . <br>String value: <code>"true"</code> , <code>"false"</code> , also since 2.3.20 <code>0</code> or <code>1</code> or <code>2</code> . (Also accepts <code>"yes"</code> , <code>"no"</code> , <code>"t"</code> , <code>"f"</code> , <code>"y"</code> , <code>"n"</code> .) Case insensitive. <li><p> <code>"template_exception_handler"</code> : See #setTemplateExceptionHandler(TemplateExceptionHandler) . <br>String value: If the value contains dot, then it's interpreted as an <a href="#fm_obe">object builder expression</a>. If the value does not contain dot, then it must be one of these predefined values (case insensitive): <code>"rethrow"</code> (means TemplateExceptionHandler#RETHROW_HANDLER ), <code>"debug"</code> (means TemplateExceptionHandler#DEBUG_HANDLER ), <code>"html_debug"</code> (means TemplateExceptionHandler#HTML_DEBUG_HANDLER ), <code>"ignore"</code> (means TemplateExceptionHandler#IGNORE_HANDLER ), <code>"default"</code> (only allowed for Configuration instances) for the default. <li><p> <code>"arithmetic_engine"</code> : See #setArithmeticEngine(ArithmeticEngine) . <br>String value: If the value contains dot, then it's interpreted as an <a href="#fm_obe">object builder expression</a>. If the value does not contain dot, then it must be one of these special values (case insensitive): <code>"bigdecimal"</code> , <code>"conservative"</code> . <li><p> <code>"object_wrapper"</code> : See #setObjectWrapper(ObjectWrapper) . <br>String value: If the value contains dot, then it's interpreted as an <a href="#fm_obe">object builder expression</a>, with the addition that BeansWrapper , DefaultObjectWrapper and SimpleObjectWrapper can be referred without package name. For example, these strings are valid values: <code>"DefaultObjectWrapper(2.3.21)"</code> , <code>"BeansWrapper(2.3.21, simpleMapWrapper=true)"</code> . <br>If the value does not contain dot, then it must be one of these special values (case insensitive): <code>"default"</code> means the default of Configuration (the default depends on the <code>Configuration#Configuration(Version) incompatible_improvements</code> , but a bug existed in 2.3.21 where that was ignored), <code>"default_2_3_0"</code> (means the deprecated ObjectWrapper#DEFAULT_WRAPPER ) <code>"simple"</code> (means the deprecated ObjectWrapper#SIMPLE_WRAPPER ), <code>"beans"</code> (means the deprecated BeansWrapper#BEANS_WRAPPER or BeansWrapperBuilder#build() ), <code>"jython"</code> (means freemarker.ext.jython.JythonWrapper#DEFAULT_WRAPPER ) <li><p> <code>"number_format"</code> : See #setNumberFormat(String) . <li><p> <code>"boolean_format"</code> : See #setBooleanFormat(String) . <li><p> <code>"date_format", "time_format", "datetime_format"</code> : See #setDateFormat(String) , #setTimeFormat(String) , #setDateTimeFormat(String) . <li><p> <code>"time_zone"</code> : See #setTimeZone(TimeZone) . <br>String value: With the format as TimeZone#getTimeZone defines it. Also, since 2.3.21 <code>"JVM default"</code> can be used that will be replaced with the actual JVM default time zone when #setSetting(String,String) is called. For example <code>"GMT-8:00"</code> or <code>"America/Los_Angeles"</code> <br>If you set this setting, consider setting <code>sql_date_and_time_time_zone</code> too (see below)! <li><p> <code>sql_date_and_time_time_zone</code> : See #setSQLDateAndTimeTimeZone(TimeZone) . Since 2.3.21. <br>String value: With the format as TimeZone#getTimeZone defines it. Also, <code>"JVM default"</code> can be used that will be replaced with the actual JVM default time zone when #setSetting(String,String) is called. Also <code>"null"</code> can be used, which has the same effect as #setSQLDateAndTimeTimeZone(TimeZone) setSQLDateAndTimeTimeZone(null) . <li><p> <code>"output_encoding"</code> : See #setOutputEncoding(String) . <li><p> <code>"url_escaping_charset"</code> : See #setURLEscapingCharset(String) . <li><p> <code>"auto_flush"</code> : See #setAutoFlush(boolean) . Since 2.3.17. <br>String value: <code>"true"</code> , <code>"false"</code> , <code>"y"</code> ,  etc. <li><p> <code>"new_builtin_class_resolver"</code> : See #setNewBuiltinClassResolver(TemplateClassResolver) . Since 2.3.17. The value must be one of these (ignore the quotation marks): <ol> <li><p> <code>"unrestricted"</code> : Use TemplateClassResolver#UNRESTRICTED_RESOLVER <li><p> <code>"safer"</code> : Use TemplateClassResolver#SAFER_RESOLVER <li><p> <code>"allows_nothing"</code> : Use TemplateClassResolver#ALLOWS_NOTHING_RESOLVER <li><p>Something that contains colon will use OptInTemplateClassResolver and is expected to store comma separated values (possibly quoted) segmented with <code>"allowed_classes:"</code> and/or <code>"trusted_templates:"</code> . Examples of valid values: <table style="width: auto; border-collapse: collapse" border="1" summary="trusted_template value examples"> <tr> <th>Setting value <th>Meaning <tr> <td> <code>allowed_classes: com.example.C1, com.example.C2, trusted_templates: lib/\*, safe.ftl</code>  <td> Only allow instantiating the <code>com.example.C1</code> and <code>com.example.C2</code> classes. But, allow templates within the <code>lib/</code> directory (like <code>lib/foo/bar.ftl</code> ) and template <code>safe.ftl</code> (that does not match <code>foo/safe.ftl</code> , only exactly <code>safe.ftl</code> ) to instantiate anything that TemplateClassResolver#SAFER_RESOLVER allows. <tr> <td> <code>allowed_classes: com.example.C1, com.example.C2</code> <td>Only allow instantiating the <code>com.example.C1</code> and <code>com.example.C2</code> classes. There are no trusted templates. <tr> <td> <code>trusted_templates: lib/\*, safe.ftl</code>  <td> Do not allow instantiating any classes, except in templates inside <code>lib/</code> or in template <code>safe.ftl</code> . </table> <p>For more details see OptInTemplateClassResolver . <li><p>Otherwise if the value contains dot, it's interpreted as an <a href="#fm_obe">object builder expression</a>. </ol> <li><p> <code>"show_error_tips"</code> : See #setShowErrorTips(boolean) . Since 2.3.21. <br>String value: <code>"true"</code> , <code>"false"</code> , <code>"y"</code> ,  etc. <li><p> <code>api_builtin_enabled</code> : See #setAPIBuiltinEnabled(boolean) . Since 2.3.22. <br>String value: <code>"true"</code> , <code>"false"</code> , <code>"y"</code> ,  etc. </ul> <p> Configuration (a subclass of Configurable ) also understands these:</p> <ul> <li><p> <code>"auto_import"</code> : See Configuration#setAutoImports(Map) <br>String value is something like: <br> <code>/lib/form.ftl as f, /lib/widget as w, "/lib/odd name.ftl" as odd</code> <li><p> <code>"auto_include"</code> : Sets the list of auto-includes. See Configuration#setAutoIncludes(List) <br>String value is something like: <br> <code>/include/common.ftl, "/include/evil name.ftl"</code> <li><p> <code>"default_encoding"</code> : See Configuration#setDefaultEncoding(String) . <br>As the default value is the system default, which can change from one server to another, <b>you should always set this!</b> <li><p> <code>"localized_lookup"</code> : See Configuration#setLocalizedLookup . <br>String value: <code>"true"</code> , <code>"false"</code> (also the equivalents: <code>"yes"</code> , <code>"no"</code> , <code>"t"</code> , <code>"f"</code> , <code>"y"</code> , <code>"n"</code> ). Case insensitive. <li><p> <code>"strict_syntax"</code> : See Configuration#setStrictSyntaxMode . Deprecated. <br>String value: <code>"true"</code> , <code>"false"</code> , <code>yes</code> , etc. <li><p> <code>"whitespace_stripping"</code> : See Configuration#setWhitespaceStripping . <br>String value: <code>"true"</code> , <code>"false"</code> , <code>yes</code> , etc. <li><p> <code>"cache_storage"</code> : See Configuration#setCacheStorage . <br>String value: If the value contains dot, then it's interpreted as an <a href="#fm_obe">object builder expression</a>. If the value does not contain dot, then a freemarker.cache.MruCacheStorage will be used with the maximum strong and soft sizes specified with the setting value. Examples of valid setting values: <table style="width: auto; border-collapse: collapse" border="1" summary="cache_storage value examples"> <tr><th>Setting value<th>max. strong size<th>max. soft size <tr><td> <code>"strong:50, soft:500"</code> <td>50<td>500 <tr><td> <code>"strong:100, soft"</code> <td>100<td> <code>Integer.MAX_VALUE</code> <tr><td> <code>"strong:100"</code> <td>100<td>0 <tr><td> <code>"soft:100"</code> <td>0<td>100 <tr><td> <code>"strong"</code> <td> <code>Integer.MAX_VALUE</code> <td>0 <tr><td> <code>"soft"</code> <td>0<td> <code>Integer.MAX_VALUE</code> </table> <p>The value is not case sensitive. The order of <tt>soft</tt> and <tt>strong</tt> entries is not significant. <li><p> <code>"template_update_delay"</code> : Template update delay in <b>seconds</b> (not in milliseconds) if no unit is specified; see Configuration#setTemplateUpdateDelayMilliseconds(long) for more. <br>String value: Valid positive integer, optionally followed by a time unit (recommended). The default unit is seconds. It's strongly recommended to specify the unit for clarity, like in "500 ms" or "30 s". Supported units are: "s" (seconds), "ms" (milliseconds), "m" (minutes), "h" (hours). The whitespace between the unit and the number is optional. Units are only supported since 2.3.23. <li><p> <code>"tag_syntax"</code> : See Configuration#setTagSyntax(int) . <br>String value: Must be one of <code>"auto_detect"</code> , <code>"angle_bracket"</code> , and <code>"square_bracket"</code> . <li><p> <code>"naming_convention"</code> : See Configuration#setNamingConvention(int) . <br>String value: Must be one of <code>"auto_detect"</code> , <code>"legacy"</code> , and <code>"camel_case"</code> . <li><p> <code>"incompatible_improvements"</code> : See Configuration#setIncompatibleImprovements(Version) . <br>String value: version number like <code>2.3.20</code> . <li><p> <code>"incompatible_enhancements"</code> : See: Configuration#setIncompatibleEnhancements(String) . This setting name is deprecated, use <code>"incompatible_improvements"</code> instead. <li><p> <code>"template_loader"</code> : See: Configuration#setTemplateLoader(TemplateLoader) . <br>String value: <code>"default"</code> (case insensitive) for the default, or else interpreted as an <a href="#fm_obe">object builder expression</a>. <li><p> <code>"template_lookup_strategy"</code> : See: Configuration#setTemplateLookupStrategy(freemarker.cache.TemplateLookupStrategy) . <br>String value: <code>"default"</code> (case insensitive) for the default, or else interpreted as an <a href="#fm_obe">object builder expression</a>. <li><p> <code>"template_name_format"</code> : See: Configuration#setTemplateNameFormat(freemarker.cache.TemplateNameFormat) . <br>String value: <code>"default"</code> (case insensitive) for the default, <code>"default_2_3_0"</code> for freemarker.cache.TemplateNameFormat#DEFAULT_2_3_0 , <code>"default_2_4_0"</code> for freemarker.cache.TemplateNameFormat#DEFAULT_2_4_0 . </ul> <p><a name="fm_obe"></a>Regarding <em>object builder expressions</em> (used by the setting values where it was indicated): <ul> <li><p>Before FreeMarker 2.3.21 it had to be a fully qualified class name, and nothing else.</li> <li><p>Since 2.3.21, the generic syntax is: <tt><i>className</i>(<i>constrArg1</i>, <i>constrArg2</i>, ... <i>constrArgN</i>, <i>propName1</i>=<i>propValue1</i>, <i>propName2</i>=<i>propValue2</i>, ... <i>propNameN</i>=<i>propValueN</i>)</tt>, where <tt><i>className</i></tt> is the fully qualified class name of the instance to create (except if we have builder class or <tt>INSTANCE</tt> field around, but see that later), <tt><i>constrArg</i></tt>-s are the values of constructor arguments, and <tt><i>propName</i>=<i>propValue</i></tt>-s set JavaBean properties (like <tt>x=1</tt> means <tt>setX(1)</tt>) on the created instance. You can have any number of constructor arguments and property setters, including 0. Constructor arguments must precede any property setters. </li> <li> Example: <tt>com.example.MyObjectWrapper(1, 2, exposeFields=true, cacheSize=5000)</tt> is nearly equivalent with this Java code: <tt>obj = new com.example.MyObjectWrapper(1, 2); obj.setExposeFields(true); obj.setCacheSize(5000);</tt> </li> <li> <p>If you have no constructor arguments and property setters, and the <tt><i>className</i></tt> class has a public static <code>INSTANCE</code> field, the value of that filed will be the value of the expression, and the constructor won't be called. Note that if you use the backward compatible syntax, where these's no parenthesis after the class name, then it will not look for <code>INSTANCE</code> . </li> <li> <p>If there exists a class named <tt><i>className</i>Builder</tt>, then that class will be instantiated instead with the given constructor arguments, and the JavaBean properties of that builder instance will be set. After that, the public <tt>build()</tt> method of the instance will be called, whose return value will be the value of the whole expression. (The builder class and the <tt>build()</tt> method is simply found by name, there's no special interface to implement.) Note that if you use the backward compatible syntax, where these's no parenthesis after the class name, then it will not look for builder class. </li> <li> <p>Currently, the values of arguments and properties can only be one of these: <ul> <li>A numerical literal, like <code>123</code> or <code>-1.5</code> . Like in FTL, there are no numerical types, the value will be automatically converted to the type of the target.</li> <li>A boolean literal: <code>true</code> or <code>false</code> <li>The null literal: <code>null</code> <li>A string literal with FTL syntax, except that  it can't contain <tt>${...}</tt>-s and <tt>#{...}</tt>-s. Examples: <code>"Line 1\nLine 2"</code> or <code>r"C:\temp"</code> . <li>An object builder expression. That is, object builder expressions can be nested into each other. </ul> </li> <li> <p>The top-level object builder expressions may omit <code>()</code> . In that case, for backward compatibility, the <code>INSTANCE</code> field and the builder class is not searched, so the instance will be always created with its parameterless constructor. (This behavior will possibly change in 2.4.) The <code>()</code> can't be omitted for nested expressions. </li> <li> <p>The classes and methods that the expression meant to access must be all public. </li> </ul>
 @param name the name of the setting.
 @param value the string that describes the new value of the setting.
 @throws UnknownSettingException if the name is wrong.
 @throws TemplateException if the new value of the setting can't be set for any other reasons.
 */
- (void)setSettingWithNSString:(NSString *)name
                  withNSString:(NSString *)value;

/**
 @brief Reads a setting list (key and element pairs) from the input stream.
 The stream has to follow the usual <code>.properties</code> format.
 @throws TemplateException if the stream contains invalid keys, or invalid setting values, or any other error occurs while changing the settings.
 @throws IOException if an error occurred when reading from the input stream.
 */
- (void)setSettingsWithJavaIoInputStream:(JavaIoInputStream *)propsIn;

/**
 @brief Set the settings stored in a <code>Properties</code> object.
 @throws TemplateException if the <code>Properties</code> object contains invalid keys, or invalid setting values, or any other error occurs while changing the settings.
 */
- (void)setSettingsWithJavaUtilProperties:(JavaUtilProperties *)props;

/**
 @brief Sets if tips should be shown in error messages of errors arising during template processing.
 The default is <code>true</code> .
 @since 2.3.21
 */
- (void)setShowErrorTipsWithBoolean:(jboolean)showTips;

/**
 @brief Sets the time zone used when dealing with java.sql.Date java.sql.Date and java.sql.Time java.sql.Time values.
 It defaults to <code>null</code> for backward compatibility, but in most application this should be set to the JVM default time zone (server default time zone), because that's what most JDBC drivers will use when constructing the java.sql.Date java.sql.Date and java.sql.Time java.sql.Time values. If this setting is <code>null</code> , FreeMarker will use the value of ( #getTimeZone() ) for java.sql.Date java.sql.Date and java.sql.Time java.sql.Time values, which often gives bad results. <p>This setting doesn't influence the formatting of other kind of values (like of java.sql.Timestamp java.sql.Timestamp or plain java.util.Date java.util.Date values). <p>To decide what value you need, a few things has to be understood: <ul> <li>Date-only and time-only values in SQL-oriented databases are usually store calendar and clock field values directly (year, month, day, or hour, minute, seconds (with decimals)), as opposed to a set of points on the physical time line. Thus, unlike SQL timestamps, these values usually aren't meant to be shown differently depending on the time zone of the audience. <li>When a JDBC query has to return a date-only or time-only value, it has to convert it to a point on the physical time line, because that's what java.util.Date and its subclasses store (milliseconds since the epoch). Obviously, this is impossible to do. So JDBC just chooses a physical time which, when rendered <em>with the JVM default time zone</em>, will give the same field values as those stored in the database. (Actually, you can give JDBC a calendar, and so it can use other time zones too, but most application won't care using those overloads.) For example, assume that the system time zone is GMT+02:00. Then, 2014-07-12 in the database will be translated to physical time 2014-07-11 22:00:00 UTC, because that rendered in GMT+02:00 gives 2014-07-12 00:00:00. Similarly, 11:57:00 in the database will be translated to physical time 1970-01-01 09:57:00 UTC. Thus, the physical time stored in the returned value depends on the default system time zone of the JDBC client, not just on the content in the database. (This used to be the default behavior of ORM-s, like Hibernate, too.) <li>The value of the <code>time_zone</code> FreeMarker configuration setting sets the time zone used for the template output. For example, when a web page visitor has a preferred time zone, the web application framework may calls Environment#setTimeZone(TimeZone) with that time zone. Thus, the visitor will see java.sql.Timestamp java.sql.Timestamp and plain java.util.Date java.util.Date values as they look in his own time zone. While this is desirable for those types, as they meant to represent physical points on the time line, this is not necessarily desirable for date-only and time-only values. When <code>sql_date_and_time_time_zone</code> is <code>null</code> , <code>time_zone</code> is used for rendering all kind of date/time/dateTime values, including java.sql.Date java.sql.Date and java.sql.Time java.sql.Time , and then if, for example, <code>time_zone</code> is GMT+00:00, the values from the earlier examples will be shown as 2014-07-11 (one day off) and 09:57:00 (2 hours off). While those are the time zone correct renderings, those values probably was meant to shown "as is". <li>You may wonder why this setting isn't simply "SQL time zone", since the time zone related behavior of JDBC applies to java.sql.Timestamp java.sql.Timestamp too. FreeMarker assumes that you have set up your application so that time stamps coming from the database go through the necessary conversion to store the correct distance from the epoch (1970-01-01 00:00:00 UTC), as requested by java.util.Date . In that case the time stamp can be safely rendered in different time zones, and thus it needs no special treatment. </ul>
 @param tz Maybe <code>null</code> , in which case java.sql.Date java.sql.Date and java.sql.Time java.sql.Time values will be formatted in the time zone returned by #getTimeZone() . (Note that since <code>null</code> is an allowed value for this setting, it will not cause #getSQLDateAndTimeTimeZone() to fall back to the parent configuration.)
 @since 2.3.21
 */
- (void)setSQLDateAndTimeTimeZoneWithJavaUtilTimeZone:(JavaUtilTimeZone *)tz;

- (void)setStrictBeanModelsWithBoolean:(jboolean)strict;

/**
 @brief Sets the exception handler used to handle exceptions occurring inside templates.
 The default is TemplateExceptionHandler#DEBUG_HANDLER . The recommended values are: <ul> <li>In production systems: TemplateExceptionHandler#RETHROW_HANDLER <li>During development of HTML templates: TemplateExceptionHandler#HTML_DEBUG_HANDLER <li>During development of non-HTML templates: TemplateExceptionHandler#DEBUG_HANDLER </ul> <p>All of these will let the exception propagate further, so that you can catch it around Template#process(Object,Writer) for example. The difference is in what they print on the output before they do that. <p>Note that the TemplateExceptionHandler is not meant to be used for generating HTTP error pages. Neither is it meant to be used to roll back the printed output. These should be solved outside template processing when the exception raises from Template#process(Object,Writer) Template.process . TemplateExceptionHandler meant to be used if you want to include special content <em>in</em> the template output, or if you want to suppress certain exceptions.
 */
- (void)setTemplateExceptionHandlerWithFreemarkerTemplateTemplateExceptionHandler:(id<FreemarkerTemplateTemplateExceptionHandler>)templateExceptionHandler;

/**
 @brief Sets the format used to convert java.util.Date -s to string-s that are time (no date part) values, also the format that <code>someString?
 time</code> will use to parse strings. <p>For the possible values see #setDateTimeFormat(String) . <p>Defaults to <code>""</code> , which means "use the FreeMarker default", which is currently <code>"medium"</code> .
 */
- (void)setTimeFormatWithNSString:(NSString *)timeFormat;

/**
 @brief Sets the time zone to use when formatting date/time values.
 Defaults to the system time zone ( TimeZone#getDefault() ), regardless of the "locale" FreeMarker setting, so in a server application you probably want to set it explicitly in the Environment to match the preferred time zone of target audience (like the Web page visitor). <p>If you or the templates set the time zone, you should probably also set #setSQLDateAndTimeTimeZone(TimeZone) !
 */
- (void)setTimeZoneWithJavaUtilTimeZone:(JavaUtilTimeZone *)timeZone;

/**
 @brief Sets the URL escaping charset.
 If not set ( <code>null</code> ), the output encoding ( #setOutputEncoding(String) ) will be used for URL escaping. Defaults to <code>null</code> .
 */
- (void)setURLEscapingCharsetWithNSString:(NSString *)urlEscapingCharset;

#pragma mark Protected

/**
 @brief Intended to be called from inside FreeMarker only.
 Creates a top-level configurable, one that doesn't inherit from a parent, and thus stores the default values. Called by the Configuration constructor.
 */
- (instancetype)initWithFreemarkerTemplateVersion:(FreemarkerTemplateVersion *)incompatibleImprovements;

- (id)clone;

- (void)doAutoImportsAndIncludesWithFreemarkerCoreEnvironment:(FreemarkerCoreEnvironment *)env;

/**
 @param name The wrong name
 @return The corrected name, or <code>null</code> if there's no known correction
 @since 2.3.21
 */
- (NSString *)getCorrectedNameForUnknownSettingWithNSString:(NSString *)name;

- (FreemarkerCoreEnvironment *)getEnvironment;

- (FreemarkerTemplateTemplateException *)invalidSettingValueExceptionWithNSString:(NSString *)name
                                                                     withNSString:(NSString *)value;

- (JavaUtilHashMap *)parseAsImportListWithNSString:(NSString *)text;

- (JavaUtilArrayList *)parseAsListWithNSString:(NSString *)text;

- (JavaUtilArrayList *)parseAsSegmentedListWithNSString:(NSString *)text;

/**
 @since 2.3.21
 */
- (FreemarkerTemplateTemplateException *)settingValueAssignmentExceptionWithNSString:(NSString *)name
                                                                        withNSString:(NSString *)value
                                                               withJavaLangThrowable:(JavaLangThrowable *)cause;

/**
 @brief Creates the exception that should be thrown when a setting name isn't recognized.
 */
- (FreemarkerTemplateTemplateException *)unknownSettingExceptionWithNSString:(NSString *)name;

#pragma mark Package-Private

- (NSString *)formatBooleanWithBoolean:(jboolean)value
                           withBoolean:(jboolean)fallbackToTrueFalse;

/**
 @brief Internal entry point for getting unnamed custom attributes
 */
- (id)getCustomAttributeWithId:(id)key
withFreemarkerCoreCustomAttribute:(FreemarkerCoreCustomAttribute *)attr;

/**
 @brief Same as #getTrueStringValue() but with <code>false</code> .
 @since 2.3.20
 */
- (NSString *)getFalseStringValue;

/**
 @brief Returns the possible setting names.
 */
- (id<JavaUtilSet>)getSettingNamesWithBoolean:(jboolean)camelCase;

/**
 @brief Returns the string to which <code>true</code> is converted to for human audience, or <code>null</code> if automatic coercion to string is not allowed.
 The default value is <code>null</code> . <p>This value is deduced from the <code>"boolean_format"</code> setting. Confusingly, for backward compatibility (at least until 2.4) that defaults to <code>"true,false"</code> , yet this defaults to <code>null</code> . That's so because <code>"true,false"</code> is treated exceptionally, as that default is a historical mistake in FreeMarker, since it targets computer language output, not human writing. Thus it's ignored.
 @since 2.3.20
 */
- (NSString *)getTrueStringValue;

/**
 @brief Internal entry point for setting unnamed custom attributes
 */
- (void)setCustomAttributeWithId:(id)key
                          withId:(id)value;

/**
 @brief Reparenting support.
 This is used by Environment when it includes a template - the included template becomes the parent configurable during its evaluation.
 */
- (void)setParentWithFreemarkerCoreConfigurable:(FreemarkerCoreConfigurable *)parent;

@end

J2OBJC_STATIC_INIT(FreemarkerCoreConfigurable)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_C_TRUE_FALSE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, C_TRUE_FALSE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_LOCALE_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, LOCALE_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_LOCALE_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, LOCALE_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_LOCALE_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, LOCALE_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_NUMBER_FORMAT_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, NUMBER_FORMAT_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_NUMBER_FORMAT_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, NUMBER_FORMAT_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_NUMBER_FORMAT_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, NUMBER_FORMAT_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_TIME_FORMAT_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, TIME_FORMAT_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_TIME_FORMAT_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, TIME_FORMAT_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_TIME_FORMAT_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, TIME_FORMAT_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_DATE_FORMAT_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, DATE_FORMAT_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_DATE_FORMAT_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, DATE_FORMAT_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_DATE_FORMAT_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, DATE_FORMAT_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_DATETIME_FORMAT_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, DATETIME_FORMAT_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_DATETIME_FORMAT_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, DATETIME_FORMAT_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_DATETIME_FORMAT_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, DATETIME_FORMAT_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_TIME_ZONE_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, TIME_ZONE_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_TIME_ZONE_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, TIME_ZONE_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_TIME_ZONE_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, TIME_ZONE_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_SQL_DATE_AND_TIME_TIME_ZONE_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, SQL_DATE_AND_TIME_TIME_ZONE_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_SQL_DATE_AND_TIME_TIME_ZONE_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, SQL_DATE_AND_TIME_TIME_ZONE_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_SQL_DATE_AND_TIME_TIME_ZONE_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, SQL_DATE_AND_TIME_TIME_ZONE_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_CLASSIC_COMPATIBLE_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, CLASSIC_COMPATIBLE_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_CLASSIC_COMPATIBLE_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, CLASSIC_COMPATIBLE_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_CLASSIC_COMPATIBLE_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, CLASSIC_COMPATIBLE_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_TEMPLATE_EXCEPTION_HANDLER_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, TEMPLATE_EXCEPTION_HANDLER_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_TEMPLATE_EXCEPTION_HANDLER_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, TEMPLATE_EXCEPTION_HANDLER_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_TEMPLATE_EXCEPTION_HANDLER_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, TEMPLATE_EXCEPTION_HANDLER_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_ARITHMETIC_ENGINE_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, ARITHMETIC_ENGINE_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_ARITHMETIC_ENGINE_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, ARITHMETIC_ENGINE_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_ARITHMETIC_ENGINE_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, ARITHMETIC_ENGINE_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_OBJECT_WRAPPER_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, OBJECT_WRAPPER_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_OBJECT_WRAPPER_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, OBJECT_WRAPPER_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_OBJECT_WRAPPER_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, OBJECT_WRAPPER_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_BOOLEAN_FORMAT_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, BOOLEAN_FORMAT_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_BOOLEAN_FORMAT_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, BOOLEAN_FORMAT_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_BOOLEAN_FORMAT_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, BOOLEAN_FORMAT_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_OUTPUT_ENCODING_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, OUTPUT_ENCODING_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_OUTPUT_ENCODING_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, OUTPUT_ENCODING_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_OUTPUT_ENCODING_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, OUTPUT_ENCODING_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_URL_ESCAPING_CHARSET_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, URL_ESCAPING_CHARSET_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_URL_ESCAPING_CHARSET_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, URL_ESCAPING_CHARSET_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_URL_ESCAPING_CHARSET_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, URL_ESCAPING_CHARSET_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_STRICT_BEAN_MODELS_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, STRICT_BEAN_MODELS_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_STRICT_BEAN_MODELS_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, STRICT_BEAN_MODELS_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_STRICT_BEAN_MODELS_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, STRICT_BEAN_MODELS_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_AUTO_FLUSH_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, AUTO_FLUSH_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_AUTO_FLUSH_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, AUTO_FLUSH_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_AUTO_FLUSH_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, AUTO_FLUSH_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_NEW_BUILTIN_CLASS_RESOLVER_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, NEW_BUILTIN_CLASS_RESOLVER_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_NEW_BUILTIN_CLASS_RESOLVER_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, NEW_BUILTIN_CLASS_RESOLVER_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_NEW_BUILTIN_CLASS_RESOLVER_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, NEW_BUILTIN_CLASS_RESOLVER_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_SHOW_ERROR_TIPS_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, SHOW_ERROR_TIPS_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_SHOW_ERROR_TIPS_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, SHOW_ERROR_TIPS_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_SHOW_ERROR_TIPS_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, SHOW_ERROR_TIPS_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_API_BUILTIN_ENABLED_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, API_BUILTIN_ENABLED_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_API_BUILTIN_ENABLED_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, API_BUILTIN_ENABLED_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_API_BUILTIN_ENABLED_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, API_BUILTIN_ENABLED_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_LOG_TEMPLATE_EXCEPTIONS_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, LOG_TEMPLATE_EXCEPTIONS_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_LOG_TEMPLATE_EXCEPTIONS_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, LOG_TEMPLATE_EXCEPTIONS_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_LOG_TEMPLATE_EXCEPTIONS_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, LOG_TEMPLATE_EXCEPTIONS_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerCoreConfigurable_STRICT_BEAN_MODELS_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerCoreConfigurable, STRICT_BEAN_MODELS_, NSString *)

FOUNDATION_EXPORT void FreemarkerCoreConfigurable_init(FreemarkerCoreConfigurable *self);

FOUNDATION_EXPORT FreemarkerCoreConfigurable *new_FreemarkerCoreConfigurable_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerCoreConfigurable_initWithFreemarkerTemplateVersion_(FreemarkerCoreConfigurable *self, FreemarkerTemplateVersion *incompatibleImprovements);

FOUNDATION_EXPORT FreemarkerCoreConfigurable *new_FreemarkerCoreConfigurable_initWithFreemarkerTemplateVersion_(FreemarkerTemplateVersion *incompatibleImprovements) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerCoreConfigurable_initWithFreemarkerCoreConfigurable_(FreemarkerCoreConfigurable *self, FreemarkerCoreConfigurable *parent);

FOUNDATION_EXPORT FreemarkerCoreConfigurable *new_FreemarkerCoreConfigurable_initWithFreemarkerCoreConfigurable_(FreemarkerCoreConfigurable *parent) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerCoreConfigurable)

/**
 @brief The setting name was not recognized.
 */
@interface FreemarkerCoreConfigurable_UnknownSettingException : FreemarkerCore_MiscTemplateException

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerCoreConfigurable_UnknownSettingException)

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerCoreConfigurable_UnknownSettingException)

/**
 @brief The setting name was recognized, but its value couldn't be parsed or the setting couldn't be set for some other reason.
 This exception always has a cause exception.
 @since 2.3.21
 */
@interface FreemarkerCoreConfigurable_SettingValueAssignmentException : FreemarkerCore_MiscTemplateException

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerCoreConfigurable_SettingValueAssignmentException)

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerCoreConfigurable_SettingValueAssignmentException)

#endif // _FreemarkerCoreConfigurable_H_
