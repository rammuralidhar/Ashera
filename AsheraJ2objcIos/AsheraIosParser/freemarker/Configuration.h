//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ramm/git/Ashera/AsheraAndroidParser/freemarker/freemarker/template/Configuration.java
//

#ifndef _FreemarkerTemplateConfiguration_H_
#define _FreemarkerTemplateConfiguration_H_

#include "Configurable.h"
#include "J2ObjC_header.h"

@class FreemarkerCacheTemplateLookupStrategy;
@class FreemarkerCacheTemplateNameFormat;
@class FreemarkerCoreEnvironment;
@class FreemarkerTemplateTemplate;
@class FreemarkerTemplateVersion;
@class IOSClass;
@class JavaIoFile;
@class JavaLangClassLoader;
@class JavaUtilLocale;
@protocol FreemarkerCacheCacheStorage;
@protocol FreemarkerCacheTemplateLoader;
@protocol FreemarkerTemplateObjectWrapper;
@protocol FreemarkerTemplateTemplateExceptionHandler;
@protocol FreemarkerTemplateTemplateHashModelEx;
@protocol FreemarkerTemplateTemplateModel;
@protocol JavaUtilList;
@protocol JavaUtilMap;
@protocol JavaUtilSet;

#define FreemarkerTemplateConfiguration_AUTO_DETECT_TAG_SYNTAX 0
#define FreemarkerTemplateConfiguration_ANGLE_BRACKET_TAG_SYNTAX 1
#define FreemarkerTemplateConfiguration_SQUARE_BRACKET_TAG_SYNTAX 2
#define FreemarkerTemplateConfiguration_AUTO_DETECT_NAMING_CONVENTION 10
#define FreemarkerTemplateConfiguration_LEGACY_NAMING_CONVENTION 11
#define FreemarkerTemplateConfiguration_CAMEL_CASE_NAMING_CONVENTION 12

/**
 @brief <b>The main entry point into the FreeMarker API</b>; encapsulates the configuration settings of FreeMarker, also serves as a central template-loading and caching service.
 <p>This class is meant to be used in a singleton pattern. That is, you create an instance of this at the beginning of the application life-cycle, set its #setSetting(String,String) configuration settings there (either with the setter methods like #setTemplateLoader(TemplateLoader) or by loading a <code>.properties</code> file), and then use that single instance everywhere in your application. Frequently re-creating Configuration is a typical and grave mistake from performance standpoint, as the Configuration holds the template cache, and often also the class introspection cache, which then will be lost. (Note that, naturally, having multiple long-lived instances, like one per component that internally uses FreeMarker is fine.) <p>The basic usage pattern is like: <pre> // Where the application is initialized; in general you do this ONLY ONCE in the application life-cycle! Configuration cfg = new Configuration(VERSION_<i>X</i>_<i>Y</i>_<i>Z</i>)); // Where X, Y, Z enables the not-100%-backward-compatible fixes introduced in // FreeMarker version X.Y.Z  and earlier (see #Configuration(Version) ). cfg.set<i>SomeSetting</i>(...); cfg.set<i>OtherSetting</i>(...); ... // Later, whenever the application needs a template (so you may do this a lot, and from multiple threads): Template Template myTemplate = cfg. #getTemplate(String) getTemplate ("myTemplate.html"); myTemplate. Template#process(Object,java.io.Writer) process (dataModel, out);</pre> <p>A couple of settings that you should not leave on its default value are: <ul> <li> #setTemplateLoader(TemplateLoader) template_loader : The default value is deprecated and in fact quite useless. (For the most common cases you can use the convenience methods, #setDirectoryForTemplateLoading(File) and #setClassForTemplateLoading(Class,String) and #setClassLoaderForTemplateLoading(ClassLoader,String) too.) <li> #setDefaultEncoding(String) default_encoding : The default value is system dependent, which makes it fragile on servers, so it should be set explicitly, like to "UTF-8" nowadays. <li> #setTemplateExceptionHandler(TemplateExceptionHandler) template_exception_handler : For developing HTML pages, the most convenient value is TemplateExceptionHandler#HTML_DEBUG_HANDLER . For production, TemplateExceptionHandler#RETHROW_HANDLER is safer to use. <!-- 2.4: recommend the new object wrapper here --> </ul> <p>A Configuration object is thread-safe only after you have stopped modifying the configuration settings, and you have <b>safely published</b> it (see JSR 133 and related literature) to other threads. Generally, you set everything directly after you have instantiated the Configuration object, then you don't change the settings anymore, so then it's safe to make it accessible (again, via a "safe publication" technique) from multiple threads. The methods that aren't for modifying settings, like #getTemplate(String) , are thread-safe.
 */
@interface FreemarkerTemplateConfiguration : FreemarkerCoreConfigurable < NSCopying >

#pragma mark Public

/**
 */
- (instancetype)init;

/**
 @brief Creates a new instance and sets which of the non-backward-compatible bugfixes/improvements should be enabled.
 Note that the specified versions corresponds to the <code>incompatible_improvements</code> configuration setting, and can be changed later, with #setIncompatibleImprovements(Version) for example. <p><b>About the "incompatible improvements" setting</b> <p>This setting value is the FreeMarker version number where the not 100% backward compatible bug fixes and improvements that you want to enable were already implemented. In new projects you should set this to the FreeMarker version that you are actually using. In older projects it's also usually better to keep this high, however you better check the changes activated (find them below), at least if not only the 3rd version number (the micro version) of <code>incompatibleImprovements</code> is increased. Generally, as far as you only increase the last version number of this setting, the changes are always low risk. The default value is 2.3.0 to maximize backward compatibility, but that value isn't recommended. <p>Bugfixes and improvements that are fully backward compatible, also those that are important security fixes, are enabled regardless of the incompatible improvements setting. <p>An important consequence of setting this setting is that now your application will check if the stated minimum FreeMarker version requirement is met. Like if you set this setting to 2.3.22, but accidentally the application is deployed with FreeMarker 2.3.21, then FreeMarker will fail, telling that a higher version is required. After all, the fixes/improvements you have requested aren't available on a lower version. <p>Note that as FreeMarker's minor (2nd) or major (1st) version number increments, it's possible that emulating some of the old bugs will become unsupported, that is, even if you set this setting to a low value, it silently wont bring back the old behavior anymore. Information about that will be present here. <p>Currently the effects of this setting are: <ul> <li><p> 2.3.0: This is the lowest supported value, the version used in older projects. This is the default in the FreeMarker 2.3.x series. </li> <li><p> 2.3.19 (or higher): Bug fix: Wrong <code>#</code> tags were printed as static text instead of causing parsing error when there was no correct <code>#</code> or <code>@@</code> tag earlier in the same template. </li> <li><p> 2.3.20 (or higher): <code>?html</code> will escape apostrophe-quotes just like <code>?xhtml</code> does. Utilizing this is highly recommended, because otherwise if interpolations are used inside attribute values that use apostrophe-quotation (<tt>&lt;foo bar='${val}'&gt;</tt>) instead of plain quotation mark (<tt>&lt;foo bar="${val}"&gt;</tt>), they might produce HTML/XML that's not well-formed. Note that <code>?html</code> didn't do this because long ago there was no cross-browser way of doing this, but it's not a concern anymore. </li> <li><p> 2.3.21 (or higher): <ul> <li><p> The <em>default</em> of the <code>object_wrapper</code> setting ( #getObjectWrapper() ) changes from ObjectWrapper#DEFAULT_WRAPPER to another almost identical DefaultObjectWrapper singleton, returned by DefaultObjectWrapperBuilder#build() . The new default object wrapper's "incompatible improvements" version is set to the same as of the Configuration . See BeansWrapper#BeansWrapper(Version) for further details. Furthermore, the new default object wrapper doesn't allow changing its settings; setter methods throw IllegalStateException ). (If anything tries to call setters on the old default in your application, that's a dangerous bug that won't remain hidden now. As the old default is a singleton too, potentially shared by independently developed components, most of them expects the out-of-the-box behavior from it (and the others are necessarily buggy). Also, then concurrency glitches can occur (and even pollute the class introspection cache) because the singleton is modified after publishing to other threads.) Furthermore the new default object wrapper shares class introspection cache with other BeansWrapper -s created with BeansWrapperBuilder , which has an impact as BeansWrapper#clearClassIntrospecitonCache() will be disallowed; see more about it there. </li> <li><p> The <code>?iso_...</code> built-ins won't show the time zone offset for java.sql.Time values anymore, because most databases store time values that aren't in any time zone, but just store hour, minute, second, and decimal second field values. If you still want to show the offset (like for PostgreSQL "time with time zone" columns you should), you can force showing the time zone offset by using <code>myTime?string.iso_fz</code> (and its other variants). </li> <li><p> <code>?is_enumerable</code> correctly returns <code>false</code> for Java methods get from Java objects that are wrapped with BeansWrapper and its subclasses, like DefaultObjectWrapper . Although method values implement TemplateSequenceModel (because of a historical design quirk in BeansWrapper ), trying to <code>#list</code> them will cause error, hence they aren't enumerable. </li> <li><p> <code>?c</code> will return <code>"INF"</code> , <code>"-INF"</code> and <code>"NaN"</code> for positive/negative infinity and IEEE floating point Not-a-Number, respectively. These are the XML Schema compatible representations of these special values. Earlier it has returned what DecimalFormat did with US locale, none of which was understood by any (common) computer language. </li> <li><p> FTL hash literals that repeat keys now only have the key once with <code>?keys</code> , and only has the last value associated to that key with <code>?values</code> . This is consistent with the behavior of <code>hash[key]</code> and how maps work in Java. </li> <li><p>In most cases (where FreeMarker is able to do that), for TemplateLoader -s that use URLConnection , <code>URLConnection#setUseCaches(boolean)</code> will called with <code>false</code> , so that only FreeMarker will do caching, not the URL scheme's handler. See URLTemplateLoader#setURLConnectionUsesCaches(Boolean) for more details. </li> <li><p> The default of the <code>template_loader</code> setting ( Configuration#getTemplateLoader() ) changes to <code>null</code> , which means that FreeMarker will not find any templates. Earlier the default was a FileTemplateLoader that used the current directory as the root. This was dangerous and fragile as you usually don't have good control over what the current directory will be. Luckily, the old default almost never looked for the templates at the right place anyway, so pretty much all applications had to set the <code>template_loader</code> setting, so it's unlikely that changing the default breaks your application. </li> <li><p> Right-unlimited ranges become readable (like listable), so <code><#list 1.. as i>...</#list></code> works. Earlier they were only usable for slicing (like <code>hits[10..]</code> ). </li> <li><p> Empty ranges return Constants#EMPTY_SEQUENCE instead of an empty SimpleSequence . This is in theory backward compatible, as the API only promises to give something that implements TemplateSequenceModel . </li> <li><p> Unclosed comments ( <code><#-- ...</code> ) and <code>#noparse</code> -s won't be silently closed at the end of template anymore, but cause a parsing error instead. </li> </ul> </li> <li><p> 2.3.22 (or higher): <ul> <li><p> DefaultObjectWrapper has some substantial changes with <code>incompatibleImprovements</code> 2.3.22; check them out at DefaultObjectWrapper#DefaultObjectWrapper(Version) . It's important to know that if you set the <code>object_wrapper</code> setting (to an other value than <code>"default"</code> ), rather than leaving it on its default value, the <code>object_wrapper</code> won't inherit the <code>incompatibleImprovements</code> of the Configuration . In that case, if you want the 2.3.22 improvements of DefaultObjectWrapper , you have to set it in the DefaultObjectWrapper object itself too! (Note that it's OK to use a DefaultObjectWrapper with a different <code>incompatibleImprovements</code> version number than that of the Configuration , if that's really what you want.) </li> <li><p> In templates, <code>.template_name</code> will <em>always</em> return the main (top level) template's name. It won't be affected by <code>#include</code> and <code>#nested</code> anymore. This is unintended, a bug with <code>incompatible_improvement</code> 2.3.22 (a consequence of the lower level fixing described in the next point). The old behavior of <code>.template_name</code> is restored if you set <code>incompatible_improvement</code> to 2.3.23 (while Configurable#getParent() ) of Environment keeps the changed behavior shown in the next point). </li> <li><p> <code>#include</code> and <code>#nested</code> doesn't change the parent Template (see Configurable#getParent() ) of the Environment anymore to the Template that's included or whose namespace <code>#nested</code> "returns" to. Thus, the parent of Environment will be now always the main Template . (The main Template is the Template whose <code>process</code> or <code>createProcessingEnvironment</code> method was called to initiate the output generation.) Note that apart from the effect on FTL's <code>.template_name</code> (see previous point), this should only matter if you have set settings directly on Template objects, and almost nobody does that. Also note that macro calls have never changed the Environment parent to the Template that contains the macro definition, so this mechanism was always broken. As now we consistently never change the parent, the behavior when calling macros didn't change. </li> <li><p> When using <code>freemarker.ext.servlet.FreemarkerServlet</code> : <ul> <li> <p>When using custom JSP tag libraries: Fixes bug where some kind of values, when put into the JSP <em>page</em> scope (via <code>#global</code> or via the JSP <code>PageContext</code> API) and later read back with the JSP <code>PageContext</code> API (typically in a custom JSP tag), might come back as FreeMarker TemplateModel objects instead of as objects with a standard Java type. Other Servlet scopes aren't affected. It's highly unlikely that something expects the presence of this bug. The affected values are of the FTL types listed below, and to trigger the bug, they either had to be created directly in the template (like as an FTL literal or with <code>?date</code> / <code>time</code> / <code>datetime</code> ), or you had to use DefaultObjectWrapper or SimpleObjectWrapper (or a subclass of them): <ul> <li>FTL date/time/date-time values may came back as SimpleDate -s, now they come back as java.util.Date java.util.Date -s instead.</li> <li>FTL sequence values may came back as SimpleSequence -s, now they come back as java.util.List -s as expected. This at least stands assuming that the Configuration#setSetting(String,String) object_wrapper configuration setting is a subclass of BeansWrapper (such as DefaultObjectWrapper , which is the default), but that's practically always the case in applications that use FreeMarker's JSP extension (otherwise it can still work, but it depends on the quality and capabilities of the ObjectWrapper implementation).</li> <li>FTL hash values may came back as SimpleHash -es, now they come back as java.util.Map -s as expected (again, assuming that the object wrapper is a subclass of BeansWrapper , like preferably DefaultObjectWrapper , which is also the default). </li> <li>FTL collection values may came back as SimpleCollection -s, now they come back as java.util.Collection -s as expected (again, assuming that the object wrapper is a subclass of BeansWrapper , like preferably DefaultObjectWrapper ).</li> </ul> </li> <li><p> Initial <code>"["</code> in the <code>TemplatePath</code> init-param has special meaning; it's used for specifying multiple comma separated locations, like in <code><param-value>[ WEB-INF/templates, classpath:com/example/myapp/templates ]</param-value></code> </li> <li><p> Initial <tt>"{"</tt> in the <code>TemplatePath</code> init-param is reserved for future purposes, and thus will throw exception. </li> </ul> </li> </ul> </li> <li><p> 2.3.23 (or higher): <ul> <li><p> Fixed a loophole in the implementation of the long existing parse-time rule that says that <code>#break</code> , in the FTL source code itself, must occur nested inside a breakable directive, such as <code>#list</code> or <code>#switch</code> . This check could be circumvented with <code>#macro</code> or <code>#function</code> , like this: <code><#list 1..1 as x><#macro callMeLater><#break></#macro></#list><@@callMeLater /></code> . After activating this fix, this will be a parse time error. </li> <li><p> If you have used <code>incompatible_improvements</code> 2.3.22 earlier, know that there the behavior of the <code>.template_name</code> special variable used in templates was accidentally altered, but now it's restored to be backward compatible with 2.3.0. (Ironically, the restored legacy behavior itself is broken when it comes to macro invocations, we just keep it for backward compatibility. If you need fixed behavior, use <code>.current_template_name</code> or <code>.main_template_name</code> instead.) </li> </ul> </li> </ul>
 @throws IllegalArgumentException If <code>incompatibleImmprovements</code> refers to a version that wasn't released yet when the currently used FreeMarker version was released, or is less than 2.3.0, or is <code>null</code> .
 @since 2.3.21
 */
- (instancetype)initWithFreemarkerTemplateVersion:(FreemarkerTemplateVersion *)incompatibleImprovements;

/**
 @brief Adds an invisible <code>#import <i>templateName</i> as <i>namespaceVarName</i></code> at the beginning of all templates.
 The order of the imports will be the same as the order in which they were added with this method.
 */
- (void)addAutoImportWithNSString:(NSString *)namespaceVarName
                     withNSString:(NSString *)templateName;

/**
 @brief Adds an invisible <code>#include <i>templateName</i> as <i>namespaceVarName</i></code> at the beginning of all templates.
 The order of the inclusions will be the same as the order in which they were added with this method.
 */
- (void)addAutoIncludeWithNSString:(NSString *)templateName;

/**
 @brief Clears language-to-encoding map.
 */
- (void)clearEncodingMap;

/**
 @brief Removes all shared sharedVariables, except the predefined ones (compress, html_escape, etc.).
 */
- (void)clearSharedVariables;

/**
 @brief Removes all entries from the template cache, thus forcing reloading of templates on subsequent <code>getTemplate</code> calls.
 <p>This method is thread-safe and can be called while the engine processes templates.
 */
- (void)clearTemplateCache;

- (id)clone;

/**
 @brief The getter pair of #setCacheStorage(CacheStorage) .
 @since 2.3.20
 */
- (id<FreemarkerCacheCacheStorage>)getCacheStorage;

/**
 @brief Returns the default (singleton) Configuration object.
 Note that you can create as many separate configurations as you wish; this global instance is provided for convenience, or when you have no reason to use a separate instance.
 */
+ (FreemarkerTemplateConfiguration *)getDefaultConfiguration;

/**
 @brief Gets the default encoding for converting bytes to characters when reading template files in a locale for which no explicit encoding was specified.
 Defaults to the default system encoding.
 */
- (NSString *)getDefaultEncoding;

/**
 @brief Returns the default object wrapper for a given "incompatible_improvements" version.
 @since 2.3.21
 */
+ (id<FreemarkerTemplateObjectWrapper>)getDefaultObjectWrapperWithFreemarkerTemplateVersion:(FreemarkerTemplateVersion *)incompatibleImprovements;

/**
 @brief Gets the preferred character encoding for the given locale, or the default encoding if no encoding is set explicitly for the specified locale.
 You can associate encodings with locales using #setEncoding(Locale,String) or #loadBuiltInEncodingMap() .
 */
- (NSString *)getEncodingWithJavaUtilLocale:(JavaUtilLocale *)locale;

/**
 */
- (NSString *)getIncompatibleEnhancements;

/**
 @return Never <code>null</code> .
 @since 2.3.20
 */
- (FreemarkerTemplateVersion *)getIncompatibleImprovements;

/**
 @brief The getter pair of #setLocalizedLookup(boolean) .
 <p>This method is thread-safe and can be called while the engine works.
 */
- (jboolean)getLocalizedLookup;

/**
 @brief The getter pair of #setNamingConvention(int) .
 @since 2.3.23
 */
- (jint)getNamingConvention;

/**
 */
- (jint)getParsedIncompatibleEnhancements;

/**
 @brief Gets a shared variable.
 Shared sharedVariables are sharedVariables that are available to all templates. When a template is processed, and an identifier is undefined in the data model, a shared variable object with the same identifier is then looked up in the configuration. There are several predefined sharedVariables that are always available through this method, see the FreeMarker manual for a comprehensive list of them.
 */
- (id<FreemarkerTemplateTemplateModel>)getSharedVariableWithNSString:(NSString *)name;

/**
 @brief Returns the set containing the names of all defined shared sharedVariables.
 The method returns a new Set object on each call that is completely disconnected from the Configuration. That is, modifying the set will have no effect on the Configuration object.
 */
- (id<JavaUtilSet>)getSharedVariableNames;

/**
 @brief The getter pair of #setStrictSyntaxMode .
 */
- (jboolean)getStrictSyntaxMode;

/**
 @brief Returns the names of the directives that are predefined by FreeMarker.
 These are the things that you call like <tt>&lt;#directiveName ...&gt;</tt>.
 @return Set of String -s.
 @since 2.3.21
 */
- (id<JavaUtilSet>)getSupportedBuiltInDirectiveNames;

/**
 @brief Returns the names of the supported "built-ins".
 These are the ( <code>expr?builtin_name</code> -like things). As of this writing, this information doesn't depend on the configuration options, so it could be a static method, but to be future-proof, it's an instance method.
 @return Set of String -s.
 @since 2.3.20
 */
- (id<JavaUtilSet>)getSupportedBuiltInNames;

/**
 @brief The getter pair of #setTagSyntax(int) .
 */
- (jint)getTagSyntax;

/**
 @brief Retrieves the template with the given name from the template cache, loading it into the cache first if it's missing/staled.
 <p> This is a shorthand for #getTemplate(String,Locale,Object,String,boolean,boolean) getTemplate(name, null, null, null, true, false) ; see more details there. <p> See Configuration for an example of basic usage.
 */
- (FreemarkerTemplateTemplate *)getTemplateWithNSString:(NSString *)name;

/**
 @brief Shorthand for #getTemplate(String,Locale,Object,String,boolean,boolean) getTemplate(name, locale, null, null, true, false) .
 */
- (FreemarkerTemplateTemplate *)getTemplateWithNSString:(NSString *)name
                                     withJavaUtilLocale:(JavaUtilLocale *)locale;

/**
 @brief Retrieves the template with the given name (and according the specified further parameters) from the template cache, loading it into the cache first if it's missing/staled.
 <p> This method is thread-safe. <p> See Configuration for an example of basic usage.
 @param name The name or path of the template, which is not a real path, but interpreted inside the current TemplateLoader . Can't be <code>null</code> . The exact syntax of the name depends on the underlying TemplateLoader , but the cache makes some assumptions. First, the name is expected to be a hierarchical path, with path components separated by a slash character (not with backslash!). The path (the name) given here must <em>not</em> begin with slash; it's always interpreted relative to the "template root directory". Then, the <code>..</code> and <code>.</code> path meta-elements will be resolved. For example, if the name is <code>a/../b/./c.ftl</code> , then it will be simplified to <code>b/c.ftl</code> . The rules regarding this are the same as with conventional UN*X paths. The path must not reach outside the template root directory, that is, it can't be something like <code>"../templates/my.ftl"</code> (not even if this path happens to be equivalent with <code>"/my.ftl"</code> ). Furthermore, the path is allowed to contain at most one path element whose name is <code>*</code> (asterisk). This path meta-element triggers the <i>acquisition mechanism</i>. If the template is not found in the location described by the concatenation of the path left to the asterisk (called base path) and the part to the right of the asterisk (called resource path), the cache will attempt to remove the rightmost path component from the base path ("go up one directory") and concatenate that with the resource path. The process is repeated until either a template is found, or the base path is completely exhausted.
 @param locale The requested locale of the template. This is what Template#getLocale() on the resulting Template will return. This parameter can be <code>null</code> since 2.3.22, in which case it defaults to Configuration#getLocale() (note that Template#getLocale() will give the default value, not <code>null</code> ). This parameter also drives localized template lookup. Assuming that you have specified <code>en_US</code> as the locale and <code>myTemplate.ftl</code> as the name of the template, and the default TemplateLookupStrategy is used and <code>#setLocalizedLookup(boolean) localized_lookup</code> is <code>true</code> , FreeMarker will first try to retrieve <code>myTemplate_en_US.html</code> , then <code>myTemplate.en.ftl</code> , and finally <code>myTemplate.ftl</code> . Note that that the template's locale will be <code>en_US</code> even if it only finds <code>myTemplate.ftl</code> .
 @param customLookupCondition This value can be used by a custom TemplateLookupStrategy ; has no effect with the default one. Can be <code>null</code> (though it's up to the custom TemplateLookupStrategy if it allows that). This object will be used as part of the cache key, so it must to have a proper Object#equals(Object) and Object#hashCode() method. It also should have reasonable Object#toString() , as it's possibly quoted in error messages. The expected type is up to the custom TemplateLookupStrategy . See also: TemplateLookupContext#getCustomLookupCondition() .
 @param encoding The charset used to interpret the template source code bytes (if it's read from a binary source). Can be <code>null</code> since 2.3.22, will default to Configuration#getEncoding(Locale) where <code>Locale</code> is the <code>locale</code> parameter (when <code>locale</code> was <code>null</code> too, the its default value is used instead).
 @param parseAsFTL If <code>true</code> , the loaded template is parsed and interpreted normally, as a regular FreeMarker template. If <code>false</code> , the loaded template is treated as a static text, so <code>${...}</code>, <code><#...></code> etc. will not have special meaning in it.
 @param ignoreMissing If <code>true</code> , the method won't throw TemplateNotFoundException if the template doesn't exist, instead it returns <code>null</code> . Other kind of exceptions won't be suppressed.
 @return the requested template; maybe <code>null</code> when the <code>ignoreMissing</code> parameter is <code>true</code> .
 @throws TemplateNotFoundException If the template could not be found. Note that this exception extends IOException .
 @throws MalformedTemplateNameException If the template name given was in violation with the TemplateNameFormat in use. Note that this exception extends IOException .
 @throws ParseException (extends <code>IOException</code>) if the template is syntactically bad. Note that this exception extends IOException .
 @throws IOException If there was some other problem with reading the template "file". Note that the other exceptions extend IOException , so this should be catched the last.
 @since 2.3.22
 */
- (FreemarkerTemplateTemplate *)getTemplateWithNSString:(NSString *)name
                                     withJavaUtilLocale:(JavaUtilLocale *)locale
                                                 withId:(id)customLookupCondition
                                           withNSString:(NSString *)encoding
                                            withBoolean:(jboolean)parseAsFTL
                                            withBoolean:(jboolean)ignoreMissing;

/**
 @brief Shorthand for #getTemplate(String,Locale,Object,String,boolean,boolean) getTemplate(name, locale, null, encoding, true, false) .
 */
- (FreemarkerTemplateTemplate *)getTemplateWithNSString:(NSString *)name
                                     withJavaUtilLocale:(JavaUtilLocale *)locale
                                           withNSString:(NSString *)encoding;

/**
 @brief Shorthand for #getTemplate(String,Locale,Object,String,boolean,boolean) getTemplate(name, locale, null, encoding, parseAsFTL, false) .
 */
- (FreemarkerTemplateTemplate *)getTemplateWithNSString:(NSString *)name
                                     withJavaUtilLocale:(JavaUtilLocale *)locale
                                           withNSString:(NSString *)encoding
                                            withBoolean:(jboolean)parseAsFTL;

/**
 @brief Shorthand for #getTemplate(String,Locale,Object,String,boolean,boolean) getTemplate(name, locale, null, encoding, parseAsFTL, ignoreMissing) .
 @since 2.3.21
 */
- (FreemarkerTemplateTemplate *)getTemplateWithNSString:(NSString *)name
                                     withJavaUtilLocale:(JavaUtilLocale *)locale
                                           withNSString:(NSString *)encoding
                                            withBoolean:(jboolean)parseAsFTL
                                            withBoolean:(jboolean)ignoreMissing;

/**
 @brief Shorthand for #getTemplate(String,Locale,Object,String,boolean,boolean) getTemplate(name, null, null, encoding, true, false) .
 */
- (FreemarkerTemplateTemplate *)getTemplateWithNSString:(NSString *)name
                                           withNSString:(NSString *)encoding;

/**
 @brief The getter pair of #setTemplateLoader(TemplateLoader) .
 */
- (id<FreemarkerCacheTemplateLoader>)getTemplateLoader;

/**
 @brief The getter pair of #setTemplateLookupStrategy(TemplateLookupStrategy) .
 */
- (FreemarkerCacheTemplateLookupStrategy *)getTemplateLookupStrategy;

/**
 @brief The getter pair of #setTemplateNameFormat(TemplateNameFormat) .
 */
- (FreemarkerCacheTemplateNameFormat *)getTemplateNameFormat;

/**
 @brief The getter pair of #setTemplateUpdateDelayMilliseconds(long) .
 @since 2.3.23
 */
- (jlong)getTemplateUpdateDelayMilliseconds;

/**
 @brief Returns the FreeMarker version information, most importantly the major.minor.micro version numbers.
 On FreeMarker version numbering rules: <ul> <li>For final/stable releases the version number is like major.minor.micro, like 2.3.19. (Historically, when micro was 0 the version strings was like major.minor instead of the proper major.minor.0, but that's not like that anymore.) <li>When only the micro version is increased, compatibility with previous versions with the same major.minor is kept. Thus <tt>freemarker.jar</tt> can be replaced in an existing application without breaking it.</li> <li>For non-final/unstable versions (that almost nobody uses), the format is: <ul> <li>Starting from 2.3.20: major.minor.micro-extraInfo, like 2.3.20-nightly_20130506T123456Z, 2.4.0-RC01. The major.minor.micro always indicates the target we move towards, so 2.3.20-nightly or 2.3.20-M01 is after 2.3.19 and will eventually become to 2.3.20. "PRE", "M" and "RC" (uppercase!) means "preview", "milestone" and "release candidate" respectively, and is always followed by a 2 digit 0-padded counter, like M03 is the 3rd milestone release of a given major.minor.micro.</li> <li>Before 2.3.20: The extraInfo wasn't preceded by a "-". Instead of "nightly" there was "mod", where the major.minor.micro part has indicated where are we coming from, so 2.3.19mod (read as: 2.3.19 modified) was after 2.3.19 but before 2.3.20. Also, "pre" and "rc" was lowercase, and was followd by a number without 0-padding.</li> </ul> </ul>
 @since 2.3.20
 */
+ (FreemarkerTemplateVersion *)getVersion;

/**
 @brief Returns FreeMarker version number string.
 */
+ (NSString *)getVersionNumber;

/**
 @brief Gets whether the FTL parser will try to remove superfluous white-space around certain FTL tags.
 */
- (jboolean)getWhitespaceStripping;

/**
 @brief Tells if #setCacheStorage(CacheStorage) (or equivalent) was already called on this instance.
 @since 2.3.22
 */
- (jboolean)isCacheStorageExplicitlySet;

/**
 @brief Tells if #setLogTemplateExceptions(boolean) (or equivalent) was already called on this instance.
 @since 2.3.22
 */
- (jboolean)isLogTemplateExceptionsExplicitlySet;

/**
 @brief Tells if #setObjectWrapper(ObjectWrapper) (or equivalent) was already called on this instance.
 @since 2.3.22
 */
- (jboolean)isObjectWrapperExplicitlySet;

/**
 @brief Tells if #setTemplateExceptionHandler(TemplateExceptionHandler) (or equivalent) was already called on this instance.
 @since 2.3.22
 */
- (jboolean)isTemplateExceptionHandlerExplicitlySet;

/**
 @brief Tells if #setTemplateLoader(TemplateLoader) (or equivalent) was already called on this instance.
 @since 2.3.22
 */
- (jboolean)isTemplateLoaderExplicitlySet;

/**
 @brief Tells if #setTemplateLookupStrategy(TemplateLookupStrategy) (or equivalent) was already called on this instance.
 @since 2.3.22
 */
- (jboolean)isTemplateLookupStrategyExplicitlySet;

/**
 @brief Tells if #setTemplateNameFormat(TemplateNameFormat) (or equivalent) was already called on this instance.
 @since 2.3.22
 */
- (jboolean)isTemplateNameFormatExplicitlySet;

/**
 @brief Loads a preset language-to-encoding map, similarly as if you have called #clearEncodingMap() and then did multiple #setEncoding(Locale,String) calls.
 It assumes the usual character encodings for most languages. The previous content of the encoding map will be lost. This default map currently contains the following mappings: <table style="width: auto; border-collapse: collapse" border="1" summary="preset language to encoding mapping"> <tr><td>ar</td><td>ISO-8859-6</td></tr> <tr><td>be</td><td>ISO-8859-5</td></tr> <tr><td>bg</td><td>ISO-8859-5</td></tr> <tr><td>ca</td><td>ISO-8859-1</td></tr> <tr><td>cs</td><td>ISO-8859-2</td></tr> <tr><td>da</td><td>ISO-8859-1</td></tr> <tr><td>de</td><td>ISO-8859-1</td></tr> <tr><td>el</td><td>ISO-8859-7</td></tr> <tr><td>en</td><td>ISO-8859-1</td></tr> <tr><td>es</td><td>ISO-8859-1</td></tr> <tr><td>et</td><td>ISO-8859-1</td></tr> <tr><td>fi</td><td>ISO-8859-1</td></tr> <tr><td>fr</td><td>ISO-8859-1</td></tr> <tr><td>hr</td><td>ISO-8859-2</td></tr> <tr><td>hu</td><td>ISO-8859-2</td></tr> <tr><td>is</td><td>ISO-8859-1</td></tr> <tr><td>it</td><td>ISO-8859-1</td></tr> <tr><td>iw</td><td>ISO-8859-8</td></tr> <tr><td>ja</td><td>Shift_JIS</td></tr> <tr><td>ko</td><td>EUC-KR</td></tr> <tr><td>lt</td><td>ISO-8859-2</td></tr> <tr><td>lv</td><td>ISO-8859-2</td></tr> <tr><td>mk</td><td>ISO-8859-5</td></tr> <tr><td>nl</td><td>ISO-8859-1</td></tr> <tr><td>no</td><td>ISO-8859-1</td></tr> <tr><td>pl</td><td>ISO-8859-2</td></tr> <tr><td>pt</td><td>ISO-8859-1</td></tr> <tr><td>ro</td><td>ISO-8859-2</td></tr> <tr><td>ru</td><td>ISO-8859-5</td></tr> <tr><td>sh</td><td>ISO-8859-5</td></tr> <tr><td>sk</td><td>ISO-8859-2</td></tr> <tr><td>sl</td><td>ISO-8859-2</td></tr> <tr><td>sq</td><td>ISO-8859-2</td></tr> <tr><td>sr</td><td>ISO-8859-5</td></tr> <tr><td>sv</td><td>ISO-8859-1</td></tr> <tr><td>tr</td><td>ISO-8859-9</td></tr> <tr><td>uk</td><td>ISO-8859-5</td></tr> <tr><td>zh</td><td>GB2312</td></tr> <tr><td>zh_TW</td><td>Big5</td></tr> </table>
 */
- (void)loadBuiltInEncodingMap;

/**
 @brief Removes an auto-import; see #addAutoImport(String,String) .
 Does nothing if the auto-import doesn't exist.
 */
- (void)removeAutoImportWithNSString:(NSString *)namespaceVarName;

/**
 @brief Removes a template from the auto-include list; see #addAutoInclude(String) .
 Does nothing if the template is not there.
 */
- (void)removeAutoIncludeWithNSString:(NSString *)templateName;

/**
 @brief Equivalent to <tt>removeTemplateFromCache(name, thisCfg.getLocale(), thisCfg.getEncoding(thisCfg.getLocale()), true)</tt>.
 @since 2.3.19
 */
- (void)removeTemplateFromCacheWithNSString:(NSString *)name;

/**
 @brief Equivalent to <tt>removeTemplateFromCache(name, locale, thisCfg.getEncoding(locale), true)</tt>.
 @since 2.3.19
 */
- (void)removeTemplateFromCacheWithNSString:(NSString *)name
                         withJavaUtilLocale:(JavaUtilLocale *)locale;

/**
 @brief Equivalent to <tt>removeTemplateFromCache(name, locale, encoding, true)</tt>.
 @since 2.3.19
 */
- (void)removeTemplateFromCacheWithNSString:(NSString *)name
                         withJavaUtilLocale:(JavaUtilLocale *)locale
                               withNSString:(NSString *)encoding;

/**
 @brief Removes a template from the template cache, hence forcing the re-loading of it when it's next time requested.
 This is to give the application finer control over cache updating than #setTemplateUpdateDelay(int) alone does. <p>For the meaning of the parameters, see #getTemplate(String,Locale,String,boolean) . <p>This method is thread-safe and can be called while the engine processes templates.
 @since 2.3.19
 */
- (void)removeTemplateFromCacheWithNSString:(NSString *)name
                         withJavaUtilLocale:(JavaUtilLocale *)locale
                               withNSString:(NSString *)encoding
                                withBoolean:(jboolean)parse;

/**
 @brief Equivalent to <tt>removeTemplateFromCache(name, thisCfg.getLocale(), encoding, true)</tt>.
 @since 2.3.19
 */
- (void)removeTemplateFromCacheWithNSString:(NSString *)name
                               withNSString:(NSString *)encoding;

/**
 @brief Adds all object in the hash as shared variable to the configuration; it's like doing several #setSharedVariable(String,Object) calls, one for each hash entry.
 It doesn't remove the already added shared variable before doing this. <p>Never use <tt>TemplateModel</tt> implementation that is not thread-safe for shared shared variable values, if the configuration is used by multiple threads! It is the typical situation for Servlet based Web sites. <p>This method is <b>not</b> thread safe; use it with the same restrictions as those that modify setting values.
 @param hash a hash model whose objects will be copied to the configuration with same names as they are given in the hash. If a shared variable with these names already exist, it will be replaced with those from the map.
 */
- (void)setAllSharedVariablesWithFreemarkerTemplateTemplateHashModelEx:(id<FreemarkerTemplateTemplateHashModelEx>)hash_;

/**
 @brief Removes all auto-imports, then calls #addAutoImport(String,String) for each Map -entry (the entry key is the <code>namespaceVarName</code> ).
 The order of the auto-imports will be the same as Map#keySet() returns the keys, thus, it's not the best idea to use a HashMap (although the order of imports doesn't mater for properly designed libraries).
 */
- (void)setAutoImportsWithJavaUtilMap:(id<JavaUtilMap>)map;

/**
 @brief Removes all auto-includes, then calls #addAutoInclude(String) for each List items.
 */
- (void)setAutoIncludesWithJavaUtilList:(id<JavaUtilList>)templateNames;

/**
 @brief Sets the CacheStorage used for caching Template -s; the earlier content of the template cache will be dropt.
 The default is a SoftCacheStorage . If the total size of the Template objects is significant but most templates are used rarely, using a MruCacheStorage instead might be advisable. If you don't want caching at all, use freemarker.cache.NullCacheStorage (you can't use <code>null</code> ). <p>Note that setting the cache storage will re-create the template cache, so all its content will be lost.
 */
- (void)setCacheStorageWithFreemarkerCacheCacheStorage:(id<FreemarkerCacheCacheStorage>)cacheStorage;

/**
 @brief Sets the class whose Class#getResource(String) method will be used to load templates, from the inside the package specified.
 See ClassTemplateLoader#ClassTemplateLoader(Class,String) for more details.
 @param basePackagePath Separate steps with <code>"/"</code> , not <code>"."</code> , and note that it matters if this starts with <code>/</code> or not. See ClassTemplateLoader#ClassTemplateLoader(Class,String) for more details.
 */
- (void)setClassForTemplateLoadingWithIOSClass:(IOSClass *)resourceLoaderClass
                                  withNSString:(NSString *)basePackagePath;

/**
 @brief Sets the ClassLoader whose ClassLoader#getResource(String) method will be used to load templates, from the inside the package specified.
 See ClassTemplateLoader#ClassTemplateLoader(Class,String) for more details.
 @param basePackagePath Separate steps with <code>"/"</code> , not <code>"."</code> . See ClassTemplateLoader#ClassTemplateLoader(Class,String) for more details.
 @since 2.3.22
 */
- (void)setClassLoaderForTemplateLoadingWithJavaLangClassLoader:(JavaLangClassLoader *)classLoader
                                                   withNSString:(NSString *)basePackagePath;

/**
 @brief Sets the Configuration object that will be retrieved from future calls to #getDefaultConfiguration() .
 */
+ (void)setDefaultConfigurationWithFreemarkerTemplateConfiguration:(FreemarkerTemplateConfiguration *)config;

/**
 @brief Sets the charset used for decoding byte sequences to character sequences when reading template files in a locale for which no explicit encoding was specified via #setEncoding(Locale,String) .
 Note that by default there is no locale specified for any locale, so the default encoding is always in effect. <p>Defaults to the default system encoding, which can change from one server to another, so <b>you should always set this setting</b>. If you don't know what charset your should chose, <code>"UTF-8"</code> is usually a good choice. <p>Note that individual templates may specify their own charset by starting with <tt>&lt;#ftl encoding="..."&gt;</tt>
 @param encoding The name of the charset, such as <code>"UTF-8"</code> or <code>"ISO-8859-1"</code>
 */
- (void)setDefaultEncodingWithNSString:(NSString *)encoding;

/**
 @brief Sets the file system directory from which to load templates.
 This is equivalent to <code>setTemplateLoader(new FileTemplateLoader(dir))</code> , so see FileTemplateLoader#FileTemplateLoader(File) for more details. Note that FreeMarker can load templates from non-file-system sources too. See #setTemplateLoader(TemplateLoader) from more details.
 */
- (void)setDirectoryForTemplateLoadingWithJavaIoFile:(JavaIoFile *)dir;

/**
 @brief Sets the character set encoding to use for templates of a given locale.
 If there is no explicit encoding set for some locale, then the default encoding will be used, what you can set with #setDefaultEncoding .
 */
- (void)setEncodingWithJavaUtilLocale:(JavaUtilLocale *)locale
                         withNSString:(NSString *)encoding;

/**
 */
- (void)setIncompatibleEnhancementsWithNSString:(NSString *)version_;

/**
 @brief Use #Configuration(Version) instead if possible; see the meaning of the parameter there.
 If the default value of a setting depends on the <code>incompatibleImprovements</code> and the value of that setting was never set in this Configuration object through the public API, its value will be set to the default value appropriate for the new <code>incompatibleImprovements</code> . (This adjustment of a setting value doesn't count as setting that setting, so setting <code>incompatibleImprovements</code> for multiple times also works as expected.) Note that if the <code>template_loader</code> have to be changed because of this, the template cache will be emptied.
 @throws IllegalArgumentException If <code>incompatibleImmprovements</code> refers to a version that wasn't released yet when the currently used FreeMarker version was released, or is less than 2.3.0, or is <code>null</code> .
 @since 2.3.20
 */
- (void)setIncompatibleImprovementsWithFreemarkerTemplateVersion:(FreemarkerTemplateVersion *)incompatibleImprovements;

/**
 @brief Enables/disables localized template lookup.
 Enabled by default. <p> With the default TemplateLookupStrategy , localized lookup works like this: Let's say your locale setting is <code>Locale("en", "AU")</code> , and you call Configuration#getTemplate(String) cfg.getTemplate("foo.ftl") . Then FreeMarker will look for the template under these names, stopping at the first that exists: <code>"foo_en_AU.ftl"</code> , <code>"foo_en.ftl"</code> , <code>"foo.ftl"</code> . See the description of the default value at #setTemplateLookupStrategy(TemplateLookupStrategy) for a more details. If you need to generate different template names, use #setTemplateLookupStrategy(TemplateLookupStrategy) with your custom TemplateLookupStrategy . <p>Note that changing the value of this setting causes the template cache to be emptied so that old lookup results won't be reused (since 2.3.22). <p> Historical note: Despite what the API documentation said earlier, this method is <em>not</em> thread-safe. While setting it can't cause any serious problems, and in fact it works well on most hardware, it's not guaranteed that FreeMarker will see the update in all threads.
 */
- (void)setLocalizedLookupWithBoolean:(jboolean)localizedLookup;

/**
 @since 2.3.22
 */
- (void)setLogTemplateExceptionsWithBoolean:(jboolean)value;

/**
 @brief Sets the naming convention used for the identifiers that are part of the template language.
 The available naming conventions are legacy (directive (tag) names are all-lower-case <code>likethis</code> , others are snake case <code>like_this</code> ), and camel case ( <code>likeThis</code> ). The default is auto-detect, which detects the naming convention used and enforces that same naming convention for the whole template. <p> This setting doesn't influence what naming convention is used for the setting names outside templates. Also, it won't ever convert the names of user-defined things, like of data-model members, or the names of user defined macros/functions. It only influences the names of the built-in directives ( <code>#elseIf</code> VS <code>elseif</code> ), built-ins ( <code>?upper_case</code> VS <code>?upperCase</code> ), special variables ( <code>.data_model</code> VS <code>.dataModel</code> ). <p> Which convention to use: FreeMarker prior to 2.3.23 has only supported Configuration#LEGACY_NAMING_CONVENTION , so that's how most templates and examples out there are written as of 2015. But as templates today are mostly written by programmers and often access Java API-s which already use camel case, Configuration#CAMEL_CASE_NAMING_CONVENTION is the recommended option for most projects. However, it's no necessary to make a application-wide decision; see auto-detection below. <p> FreeMarker will decide the naming convention automatically for each template individually when this setting is set to #AUTO_DETECT_NAMING_CONVENTION (which is the default). The naming convention of a template is decided when the first core (non-user-defined) identifier is met during parsing (not during processing) where the naming convention is relevant (like for <code>s?upperCase</code> or <code>s?upper_case</code> it's relevant, but for <code>s?length</code> it isn't). At that point, the naming convention of the template is decided, and any later core identifier that uses a different convention will be a parsing error. As the naming convention is decided per template, it's not a problem if a template and the other template it <code>#include</code> -s/ <code>#import</code> uses a different convention. <p> FreeMarker always enforces the same naming convention to be used consistently within the same template "file". Additionally, when this setting is set to non- #AUTO_DETECT_NAMING_CONVENTION , the selected naming convention is enforced on all templates. Thus such a setup can be used to enforce an application-wide naming convention. <p> Non-strict tags (a long deprecated syntax from FreeMarker 1, activated via #setStrictSyntaxMode(boolean) ) are only recognized as FTL tags when they are using the Configuration#LEGACY_NAMING_CONVENTION syntax, regardless of this setting. As they aren't exempt from the naming convention consistency enforcement, generally, you can't use strict Configuration#CAMEL_CASE_NAMING_CONVENTION tags mixed with non-strict tags.
 @param namingConvention One of the #AUTO_DETECT_NAMING_CONVENTION or #LEGACY_NAMING_CONVENTION #CAMEL_CASE_NAMING_CONVENTION .
 @throws IllegalArgumentException If the parameter isn't one of the valid constants.
 @since 2.3.23
 */
- (void)setNamingConventionWithInt:(jint)namingConvention;

- (void)setObjectWrapperWithFreemarkerTemplateObjectWrapper:(id<FreemarkerTemplateObjectWrapper>)objectWrapper;

/**
 @brief Sets the servlet context from which to load templates.
 This is equivalent to <code>setTemplateLoader(new WebappTemplateLoader(sctxt, path))</code> or <code>setTemplateLoader(new WebappTemplateLoader(sctxt))</code> if <code>path</code> was <code>null</code> , so see <code>freemarker.cache.WebappTemplateLoader</code> for more details.
 @param servletContext the <code>javax.servlet.ServletContext</code> object. (The declared type is Object to prevent class loading error when using FreeMarker in an environment where there's no servlet classes available.)
 @param path the path relative to the ServletContext.
 */
- (void)setServletContextForTemplateLoadingWithId:(id)servletContext
                                     withNSString:(NSString *)path;

- (void)setSettingWithNSString:(NSString *)name
                  withNSString:(NSString *)value;

/**
 @brief Adds shared variable to the configuration; It uses Configurable#getObjectWrapper() to wrap the <code>value</code> , so it's important that the object wrapper is set before this.
 <p>This method is <b>not</b> thread safe; use it with the same restrictions as those that modify setting values. <p>The added value should be thread safe, if you are running templates from multiple threads with this configuration.
 @throws TemplateModelException If some of the variables couldn't be wrapped via #getObjectWrapper() .
 */
- (void)setSharedVariableWithNSString:(NSString *)name
                               withId:(id)value;

/**
 @brief Adds a shared variable to the configuration.
 Shared sharedVariables are sharedVariables that are visible as top-level sharedVariables for all templates which use this configuration, if the data model does not contain a variable with the same name. <p>Never use <tt>TemplateModel</tt> implementation that is not thread-safe for shared sharedVariables, if the configuration is used by multiple threads! It is the typical situation for Servlet based Web sites. <p>This method is <b>not</b> thread safe; use it with the same restrictions as those that modify setting values.
 @param name the name used to access the data object from your template. If a shared variable with this name already exists, it will replace that.
 */
- (void)setSharedVariableWithNSString:(NSString *)name
  withFreemarkerTemplateTemplateModel:(id<FreemarkerTemplateTemplateModel>)tm;

/**
 @brief Replaces all shared variables (removes all previously added ones).
 <p>The values in the map can be TemplateModel -s or plain Java objects which will be immediately converted to TemplateModel with the ObjectWrapper returned by #getObjectWrapper() . If #setObjectWrapper(ObjectWrapper) is called later, this conversion will be re-applied. Thus, ignoring some extra resource usage, it doesn't mater if in what order are #setObjectWrapper(ObjectWrapper) and #setSharedVaribles(Map) called. This is essential when you don't have control over the order in which the setters are called. <p>The values in the map must be thread safe, if you are running templates from multiple threads with this configuration. This means that both the plain Java object and the TemplateModel -s created from them by the ObjectWrapper must be thread safe. (The standard ObjectWrapper -s of FreeMarker create thread safe TemplateModel -s.) The Map itself need not be thread-safe. <p>This setter method has no getter pair because of the tricky relation ship with #setSharedVariable(String,Object) .
 @throws TemplateModelException If some of the variables couldn't be wrapped via #getObjectWrapper() .
 @since 2.3.21
 */
- (void)setSharedVariblesWithJavaUtilMap:(id<JavaUtilMap>)map;

/**
 @brief Sets whether directives such as <code>if</code> , <code>else</code> , etc must be written as <code>#if</code> , <code>#else</code> , etc.
 Defaults to <code>true</code> . <p>When this is <code>true</code> , any tag not starting with &lt;# or &lt;/# or &lt;@@ or &lt;/@@ is considered as plain text and will go to the output as is. Tag starting with &lt;# or &lt;/# must be valid FTL tag, or else the template is invalid (i.e. &lt;#noSuchDirective&gt; is an error).
 */
- (void)setStrictSyntaxModeWithBoolean:(jboolean)b;

/**
 @brief Determines the syntax of the template files (angle bracket VS square bracket) that has no <code>#ftl</code> in it.
 The <code>tagSyntax</code> parameter must be one of: <ul> <li> Configuration#AUTO_DETECT_TAG_SYNTAX : use the syntax of the first FreeMarker tag (can be anything, like <tt>#list</tt>, <tt>#include</tt>, user defined, etc.) <li> Configuration#ANGLE_BRACKET_TAG_SYNTAX : use the angle bracket syntax (the normal syntax) <li> Configuration#SQUARE_BRACKET_TAG_SYNTAX : use the square bracket syntax </ul> <p>In FreeMarker 2.3.x Configuration#ANGLE_BRACKET_TAG_SYNTAX is the default for better backward compatibility. Starting from 2.4.x Configuration#AUTO_DETECT_TAG_SYNTAX is the default, so it's recommended to use that even for 2.3.x. <p>This setting is ignored for the templates that have <code>ftl</code> directive in it. For those templates the syntax used for the <code>ftl</code> directive determines the syntax.
 */
- (void)setTagSyntaxWithInt:(jint)tagSyntax;

- (void)setTemplateExceptionHandlerWithFreemarkerTemplateTemplateExceptionHandler:(id<FreemarkerTemplateTemplateExceptionHandler>)templateExceptionHandler;

/**
 @brief Sets a TemplateLoader that is used to look up and load templates; as a side effect the template cache will be emptied.
 By providing your own TemplateLoader implementation, you can load templates from whatever kind of storages, like from relational databases, NoSQL-storages, etc. <p>Convenience methods exists to install commonly used loaders, instead of using this method: #setClassForTemplateLoading(Class,String) , #setClassLoaderForTemplateLoading(ClassLoader,String) , #setDirectoryForTemplateLoading(File) , and #setServletContextForTemplateLoading(Object,String) . <p>You can chain several TemplateLoader -s together with MultiTemplateLoader . <p>Default value: You should always set the template loader instead of relying on the default value. (But if you still care what it is, before "incompatible improvements" 2.3.21 it's a FileTemplateLoader that uses the current directory as its root; as it's hard tell what that directory will be, it's not very useful and dangerous. Starting with "incompatible improvements" 2.3.21 the default is <code>null</code> .)
 */
- (void)setTemplateLoaderWithFreemarkerCacheTemplateLoader:(id<FreemarkerCacheTemplateLoader>)templateLoader;

/**
 @brief Sets a TemplateLookupStrategy that is used to look up templates based on the requested name; as a side effect the template cache will be emptied.
 The default value is TemplateLookupStrategy#DEFAULT_2_3_0 .
 @since 2.3.22
 */
- (void)setTemplateLookupStrategyWithFreemarkerCacheTemplateLookupStrategy:(FreemarkerCacheTemplateLookupStrategy *)templateLookupStrategy;

/**
 @brief Sets the template name format used.
 The default is TemplateNameFormat#DEFAULT_2_3_0 , while the recommended value for new projects is TemplateNameFormat#DEFAULT_2_4_0 .
 @since 2.3.22
 */
- (void)setTemplateNameFormatWithFreemarkerCacheTemplateNameFormat:(FreemarkerCacheTemplateNameFormat *)templateNameFormat;

/**
 @brief Sets the time in seconds that must elapse before checking whether there is a newer version of a template "file" than the cached one.
 <p> Historical note: Despite what the API documentation said earlier, this method is <em>not</em> thread-safe. While it works well on most hardware, it's not guaranteed that FreeMarker will see the update in all threads, and theoretically it's also possible that it will see a value that's a binary mixture of the new and the old one.
 */
- (void)setTemplateUpdateDelayWithInt:(jint)seconds;

/**
 @brief Sets the time in milliseconds that must elapse before checking whether there is a newer version of a template "file" exists than the cached one.
 Defaults to 5000 ms. <p> When you get a template via #getTemplate(String) (or some of its overloads). FreeMarker will try to get the template from the template cache. If the template is found, and at least this amount of time was elapsed since the template last modification date was checked, FreeMarker will re-check the last modification date (this could mean I/O), possibly reloading the template and updating the cache as a consequence (can mean even more I/O). The #getTemplate(String) (or some of its overloads) call will only return after this all is done, so it will return the fresh template.
 @since 2.3.23
 */
- (void)setTemplateUpdateDelayMillisecondsWithLong:(jlong)millis;

/**
 @brief Sets whether the FTL parser will try to remove superfluous white-space around certain FTL tags.
 */
- (void)setWhitespaceStrippingWithBoolean:(jboolean)b;

/**
 @brief Resets the setting to its default, as it was never set.
 This means that when you change the <code>incompatibe_improvements</code> setting later, the default will also change as appropriate. Also #isCacheStorageExplicitlySet() will return <code>false</code> .
 @since 2.3.22
 */
- (void)unsetCacheStorage;

/**
 @brief Resets the setting to its default, as it was never set.
 This means that when you change the <code>incompatibe_improvements</code> setting later, the default will also change as appropriate. Also #isTemplateExceptionHandlerExplicitlySet() will return <code>false</code> .
 @since 2.3.22
 */
- (void)unsetLogTemplateExceptions;

/**
 @brief Resets the setting to its default, as it was never set.
 This means that when you change the <code>incompatibe_improvements</code> setting later, the default will also change as appropriate. Also #isObjectWrapperExplicitlySet() will return <code>false</code> .
 @since 2.3.22
 */
- (void)unsetObjectWrapper;

/**
 @brief Resets the setting to its default, as it was never set.
 This means that when you change the <code>incompatibe_improvements</code> setting later, the default will also change as appropriate. Also #isTemplateExceptionHandlerExplicitlySet() will return <code>false</code> .
 @since 2.3.22
 */
- (void)unsetTemplateExceptionHandler;

/**
 @brief Resets the setting to its default, as it was never set.
 This means that when you change the <code>incompatibe_improvements</code> setting later, the default will also change as appropriate. Also #isTemplateLoaderExplicitlySet() will return <code>false</code> .
 @since 2.3.22
 */
- (void)unsetTemplateLoader;

/**
 @brief Resets the setting to its default, as it was never set.
 This means that when you change the <code>incompatibe_improvements</code> setting later, the default will also change as appropriate. Also #isTemplateLookupStrategyExplicitlySet() will return <code>false</code> .
 @since 2.3.22
 */
- (void)unsetTemplateLookupStrategy;

/**
 @brief Resets the setting to its default, as it was never set.
 This means that when you change the <code>incompatibe_improvements</code> setting later, the default will also change as appropriate. Also #isTemplateNameFormatExplicitlySet() will return <code>false</code> .
 @since 2.3.22
 */
- (void)unsetTemplateNameFormat;

#pragma mark Protected

- (void)doAutoImportsAndIncludesWithFreemarkerCoreEnvironment:(FreemarkerCoreEnvironment *)env;

- (NSString *)getCorrectedNameForUnknownSettingWithNSString:(NSString *)name;

#pragma mark Package-Private

+ (id<FreemarkerCacheCacheStorage>)createDefaultCacheStorageWithFreemarkerTemplateVersion:(FreemarkerTemplateVersion *)incompatibleImprovements;

+ (id<FreemarkerCacheCacheStorage>)createDefaultCacheStorageWithFreemarkerTemplateVersion:(FreemarkerTemplateVersion *)incompatibleImprovements
                                                          withFreemarkerCacheCacheStorage:(id<FreemarkerCacheCacheStorage>)existingCacheStorage;

+ (id<FreemarkerCacheTemplateLoader>)createDefaultTemplateLoaderWithFreemarkerTemplateVersion:(FreemarkerTemplateVersion *)incompatibleImprovements;

+ (jboolean)getDefaultLogTemplateExceptionsWithFreemarkerTemplateVersion:(FreemarkerTemplateVersion *)incompatibleImprovements;

+ (id<FreemarkerTemplateTemplateExceptionHandler>)getDefaultTemplateExceptionHandlerWithFreemarkerTemplateVersion:(FreemarkerTemplateVersion *)incompatibleImprovements;

+ (FreemarkerCacheTemplateLookupStrategy *)getDefaultTemplateLookupStrategyWithFreemarkerTemplateVersion:(FreemarkerTemplateVersion *)incompatibleImprovements;

+ (FreemarkerCacheTemplateNameFormat *)getDefaultTemplateNameFormatWithFreemarkerTemplateVersion:(FreemarkerTemplateVersion *)incompatibleImprovements;

- (id<JavaUtilSet>)getSettingNamesWithBoolean:(jboolean)camelCase;

@end

J2OBJC_STATIC_INIT(FreemarkerTemplateConfiguration)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_DEFAULT_ENCODING_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, DEFAULT_ENCODING_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_DEFAULT_ENCODING_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, DEFAULT_ENCODING_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_DEFAULT_ENCODING_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, DEFAULT_ENCODING_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_LOCALIZED_LOOKUP_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, LOCALIZED_LOOKUP_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_LOCALIZED_LOOKUP_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, LOCALIZED_LOOKUP_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_LOCALIZED_LOOKUP_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, LOCALIZED_LOOKUP_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_STRICT_SYNTAX_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, STRICT_SYNTAX_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_STRICT_SYNTAX_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, STRICT_SYNTAX_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_STRICT_SYNTAX_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, STRICT_SYNTAX_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_WHITESPACE_STRIPPING_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, WHITESPACE_STRIPPING_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_WHITESPACE_STRIPPING_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, WHITESPACE_STRIPPING_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_WHITESPACE_STRIPPING_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, WHITESPACE_STRIPPING_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_CACHE_STORAGE_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, CACHE_STORAGE_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_CACHE_STORAGE_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, CACHE_STORAGE_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_CACHE_STORAGE_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, CACHE_STORAGE_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_TEMPLATE_UPDATE_DELAY_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, TEMPLATE_UPDATE_DELAY_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_TEMPLATE_UPDATE_DELAY_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, TEMPLATE_UPDATE_DELAY_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_TEMPLATE_UPDATE_DELAY_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, TEMPLATE_UPDATE_DELAY_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_AUTO_IMPORT_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, AUTO_IMPORT_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_AUTO_IMPORT_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, AUTO_IMPORT_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_AUTO_IMPORT_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, AUTO_IMPORT_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_AUTO_INCLUDE_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, AUTO_INCLUDE_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_AUTO_INCLUDE_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, AUTO_INCLUDE_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_AUTO_INCLUDE_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, AUTO_INCLUDE_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_TAG_SYNTAX_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, TAG_SYNTAX_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_TAG_SYNTAX_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, TAG_SYNTAX_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_TAG_SYNTAX_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, TAG_SYNTAX_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_NAMING_CONVENTION_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, NAMING_CONVENTION_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_NAMING_CONVENTION_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, NAMING_CONVENTION_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_NAMING_CONVENTION_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, NAMING_CONVENTION_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_TEMPLATE_LOADER_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, TEMPLATE_LOADER_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_TEMPLATE_LOADER_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, TEMPLATE_LOADER_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_TEMPLATE_LOADER_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, TEMPLATE_LOADER_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_TEMPLATE_LOOKUP_STRATEGY_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, TEMPLATE_LOOKUP_STRATEGY_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_TEMPLATE_LOOKUP_STRATEGY_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, TEMPLATE_LOOKUP_STRATEGY_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_TEMPLATE_LOOKUP_STRATEGY_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, TEMPLATE_LOOKUP_STRATEGY_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_TEMPLATE_NAME_FORMAT_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, TEMPLATE_NAME_FORMAT_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_TEMPLATE_NAME_FORMAT_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, TEMPLATE_NAME_FORMAT_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_TEMPLATE_NAME_FORMAT_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, TEMPLATE_NAME_FORMAT_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_INCOMPATIBLE_IMPROVEMENTS_KEY_SNAKE_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, INCOMPATIBLE_IMPROVEMENTS_KEY_SNAKE_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_INCOMPATIBLE_IMPROVEMENTS_KEY_CAMEL_CASE_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, INCOMPATIBLE_IMPROVEMENTS_KEY_CAMEL_CASE_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_INCOMPATIBLE_IMPROVEMENTS_KEY_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, INCOMPATIBLE_IMPROVEMENTS_KEY_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_INCOMPATIBLE_IMPROVEMENTS_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, INCOMPATIBLE_IMPROVEMENTS_, NSString *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_INCOMPATIBLE_ENHANCEMENTS_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, INCOMPATIBLE_ENHANCEMENTS_, NSString *)

J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, AUTO_DETECT_TAG_SYNTAX, jint)

J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, ANGLE_BRACKET_TAG_SYNTAX, jint)

J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, SQUARE_BRACKET_TAG_SYNTAX, jint)

J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, AUTO_DETECT_NAMING_CONVENTION, jint)

J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, LEGACY_NAMING_CONVENTION, jint)

J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, CAMEL_CASE_NAMING_CONVENTION, jint)

FOUNDATION_EXPORT FreemarkerTemplateVersion *FreemarkerTemplateConfiguration_VERSION_2_3_0_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, VERSION_2_3_0_, FreemarkerTemplateVersion *)

FOUNDATION_EXPORT FreemarkerTemplateVersion *FreemarkerTemplateConfiguration_VERSION_2_3_19_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, VERSION_2_3_19_, FreemarkerTemplateVersion *)

FOUNDATION_EXPORT FreemarkerTemplateVersion *FreemarkerTemplateConfiguration_VERSION_2_3_20_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, VERSION_2_3_20_, FreemarkerTemplateVersion *)

FOUNDATION_EXPORT FreemarkerTemplateVersion *FreemarkerTemplateConfiguration_VERSION_2_3_21_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, VERSION_2_3_21_, FreemarkerTemplateVersion *)

FOUNDATION_EXPORT FreemarkerTemplateVersion *FreemarkerTemplateConfiguration_VERSION_2_3_22_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, VERSION_2_3_22_, FreemarkerTemplateVersion *)

FOUNDATION_EXPORT FreemarkerTemplateVersion *FreemarkerTemplateConfiguration_VERSION_2_3_23_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, VERSION_2_3_23_, FreemarkerTemplateVersion *)

FOUNDATION_EXPORT FreemarkerTemplateVersion *FreemarkerTemplateConfiguration_DEFAULT_INCOMPATIBLE_IMPROVEMENTS_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, DEFAULT_INCOMPATIBLE_IMPROVEMENTS_, FreemarkerTemplateVersion *)

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_DEFAULT_INCOMPATIBLE_ENHANCEMENTS_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, DEFAULT_INCOMPATIBLE_ENHANCEMENTS_, NSString *)

FOUNDATION_EXPORT jint FreemarkerTemplateConfiguration_PARSED_DEFAULT_INCOMPATIBLE_ENHANCEMENTS_;
J2OBJC_STATIC_FIELD_GETTER(FreemarkerTemplateConfiguration, PARSED_DEFAULT_INCOMPATIBLE_ENHANCEMENTS_, jint)

FOUNDATION_EXPORT void FreemarkerTemplateConfiguration_init(FreemarkerTemplateConfiguration *self);

FOUNDATION_EXPORT FreemarkerTemplateConfiguration *new_FreemarkerTemplateConfiguration_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerTemplateConfiguration_initWithFreemarkerTemplateVersion_(FreemarkerTemplateConfiguration *self, FreemarkerTemplateVersion *incompatibleImprovements);

FOUNDATION_EXPORT FreemarkerTemplateConfiguration *new_FreemarkerTemplateConfiguration_initWithFreemarkerTemplateVersion_(FreemarkerTemplateVersion *incompatibleImprovements) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT id<FreemarkerCacheTemplateLoader> FreemarkerTemplateConfiguration_createDefaultTemplateLoaderWithFreemarkerTemplateVersion_(FreemarkerTemplateVersion *incompatibleImprovements);

FOUNDATION_EXPORT FreemarkerCacheTemplateLookupStrategy *FreemarkerTemplateConfiguration_getDefaultTemplateLookupStrategyWithFreemarkerTemplateVersion_(FreemarkerTemplateVersion *incompatibleImprovements);

FOUNDATION_EXPORT FreemarkerCacheTemplateNameFormat *FreemarkerTemplateConfiguration_getDefaultTemplateNameFormatWithFreemarkerTemplateVersion_(FreemarkerTemplateVersion *incompatibleImprovements);

FOUNDATION_EXPORT id<FreemarkerCacheCacheStorage> FreemarkerTemplateConfiguration_createDefaultCacheStorageWithFreemarkerTemplateVersion_withFreemarkerCacheCacheStorage_(FreemarkerTemplateVersion *incompatibleImprovements, id<FreemarkerCacheCacheStorage> existingCacheStorage);

FOUNDATION_EXPORT id<FreemarkerCacheCacheStorage> FreemarkerTemplateConfiguration_createDefaultCacheStorageWithFreemarkerTemplateVersion_(FreemarkerTemplateVersion *incompatibleImprovements);

FOUNDATION_EXPORT id<FreemarkerTemplateTemplateExceptionHandler> FreemarkerTemplateConfiguration_getDefaultTemplateExceptionHandlerWithFreemarkerTemplateVersion_(FreemarkerTemplateVersion *incompatibleImprovements);

FOUNDATION_EXPORT jboolean FreemarkerTemplateConfiguration_getDefaultLogTemplateExceptionsWithFreemarkerTemplateVersion_(FreemarkerTemplateVersion *incompatibleImprovements);

FOUNDATION_EXPORT FreemarkerTemplateConfiguration *FreemarkerTemplateConfiguration_getDefaultConfiguration();

FOUNDATION_EXPORT void FreemarkerTemplateConfiguration_setDefaultConfigurationWithFreemarkerTemplateConfiguration_(FreemarkerTemplateConfiguration *config);

FOUNDATION_EXPORT NSString *FreemarkerTemplateConfiguration_getVersionNumber();

FOUNDATION_EXPORT FreemarkerTemplateVersion *FreemarkerTemplateConfiguration_getVersion();

FOUNDATION_EXPORT id<FreemarkerTemplateObjectWrapper> FreemarkerTemplateConfiguration_getDefaultObjectWrapperWithFreemarkerTemplateVersion_(FreemarkerTemplateVersion *incompatibleImprovements);

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerTemplateConfiguration)

#endif // _FreemarkerTemplateConfiguration_H_
