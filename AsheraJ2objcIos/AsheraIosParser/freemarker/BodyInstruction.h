//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ramm/git/Ashera/AsheraAndroidParser/freemarker/freemarker/core/BodyInstruction.java
//

#ifndef _FreemarkerCoreBodyInstruction_H_
#define _FreemarkerCoreBodyInstruction_H_

#include "J2ObjC_header.h"
#include "LocalContext.h"
#include "TemplateElement.h"

@class FreemarkerCoreEnvironment;
@class FreemarkerCoreEnvironment_Namespace;
@class FreemarkerCoreMacro_Context;
@class FreemarkerCoreParameterRole;
@protocol FreemarkerTemplateTemplateModel;
@protocol JavaUtilCollection;
@protocol JavaUtilList;

/**
 @brief An instruction that processes the nested block within a macro instruction.
 */
@interface FreemarkerCoreBodyInstruction : FreemarkerCoreTemplateElement

#pragma mark Protected

- (NSString *)dumpWithBoolean:(jboolean)canonical;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilList:(id<JavaUtilList>)bodyParameters;

/**
 @brief There is actually a subtle but essential point in the code below.
 A macro operates in the context in which it's defined. However, a nested block within a macro instruction is defined in the context in which the macro was invoked. So, we actually need to temporarily switch the namespace and macro context back to what it was before macro invocation to implement this properly. I (JR) realized this thanks to some incisive comments from Daniel Dekany.
 */
- (void)acceptWithFreemarkerCoreEnvironment:(FreemarkerCoreEnvironment *)env;

- (id<JavaUtilList>)getBodyParameters;

- (NSString *)getNodeTypeSymbol;

- (jint)getParameterCount;

- (FreemarkerCoreParameterRole *)getParameterRoleWithInt:(jint)idx;

- (id)getParameterValueWithInt:(jint)idx;

- (jboolean)isNestedBlockRepeater;

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerCoreBodyInstruction)

FOUNDATION_EXPORT void FreemarkerCoreBodyInstruction_initWithJavaUtilList_(FreemarkerCoreBodyInstruction *self, id<JavaUtilList> bodyParameters);

FOUNDATION_EXPORT FreemarkerCoreBodyInstruction *new_FreemarkerCoreBodyInstruction_initWithJavaUtilList_(id<JavaUtilList> bodyParameters) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerCoreBodyInstruction)

@interface FreemarkerCoreBodyInstruction_Context : NSObject < FreemarkerCoreLocalContext > {
 @public
  FreemarkerCoreMacro_Context *invokingMacroContext_;
  FreemarkerCoreEnvironment_Namespace *bodyVars_;
}

#pragma mark Public

- (id<FreemarkerTemplateTemplateModel>)getLocalVariableWithNSString:(NSString *)name;

- (id<JavaUtilCollection>)getLocalVariableNames;

#pragma mark Package-Private

- (instancetype)initWithFreemarkerCoreBodyInstruction:(FreemarkerCoreBodyInstruction *)outer$
                        withFreemarkerCoreEnvironment:(FreemarkerCoreEnvironment *)env;

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerCoreBodyInstruction_Context)

J2OBJC_FIELD_SETTER(FreemarkerCoreBodyInstruction_Context, invokingMacroContext_, FreemarkerCoreMacro_Context *)
J2OBJC_FIELD_SETTER(FreemarkerCoreBodyInstruction_Context, bodyVars_, FreemarkerCoreEnvironment_Namespace *)

FOUNDATION_EXPORT void FreemarkerCoreBodyInstruction_Context_initWithFreemarkerCoreBodyInstruction_withFreemarkerCoreEnvironment_(FreemarkerCoreBodyInstruction_Context *self, FreemarkerCoreBodyInstruction *outer$, FreemarkerCoreEnvironment *env);

FOUNDATION_EXPORT FreemarkerCoreBodyInstruction_Context *new_FreemarkerCoreBodyInstruction_Context_initWithFreemarkerCoreBodyInstruction_withFreemarkerCoreEnvironment_(FreemarkerCoreBodyInstruction *outer$, FreemarkerCoreEnvironment *env) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerCoreBodyInstruction_Context)

#endif // _FreemarkerCoreBodyInstruction_H_
