//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ramm/git/Ashera/AsheraAndroidParser/freemarker/freemarker/core/ThreadInterruptionSupportTemplatePostProcessor.java
//

#ifndef _FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor_H_
#define _FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor_H_

#include "J2ObjC_header.h"
#include "TemplateElement.h"
#include "TemplatePostProcessor.h"
#include "java/lang/RuntimeException.h"

@class FreemarkerCoreEnvironment;
@class FreemarkerCoreParameterRole;
@class FreemarkerTemplateTemplate;

/**
 @brief Not yet public; subject to change.
 <p> Known compatibility risks when using this post-processor: <ul> <li> TemplateDateModel -s that care to explicitly check if their nested content is <code>null</code> might start to complain that you have specified a body despite that the directive doesn't support that. Directives should use NestedContentNotSupportedException#check(freemarker.template.TemplateDirectiveBody) instead of a simple <code>null</code> -check to avoid this problem.</li> <li> Software that uses DirectiveCallPlace#isNestedOutputCacheable() will always get <code>false</code> , because interruption checks ( ThreadInterruptionCheck elements) are, obviously, not cacheable. This should only impact the performance. <li> Software that investigates the AST will see the injected ThreadInterruptionCheck elements. As of this writing the AST API-s aren't published, also such software need to be able to deal with new kind of elements anyway, so this shouldn't be a problem. </ul>
 */
@interface FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor : FreemarkerCoreTemplatePostProcessor

#pragma mark Public

- (void)postProcessWithFreemarkerTemplateTemplate:(FreemarkerTemplateTemplate *)t;

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor)

FOUNDATION_EXPORT void FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor_init(FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor *self);

FOUNDATION_EXPORT FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor *new_FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor)

/**
 @brief Check if the current thread's "interrupted" flag is set, and throws TemplateProcessingThreadInterruptedException if it is.
 We inject this to some points in the AST.
 */
@interface FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor_ThreadInterruptionCheck : FreemarkerCoreTemplateElement

#pragma mark Protected

- (NSString *)dumpWithBoolean:(jboolean)canonical;

#pragma mark Package-Private

- (void)acceptWithFreemarkerCoreEnvironment:(FreemarkerCoreEnvironment *)env;

- (NSString *)getNodeTypeSymbol;

- (jint)getParameterCount;

- (FreemarkerCoreParameterRole *)getParameterRoleWithInt:(jint)idx;

- (id)getParameterValueWithInt:(jint)idx;

- (jboolean)isNestedBlockRepeater;

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor_ThreadInterruptionCheck)

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor_ThreadInterruptionCheck)

/**
 @brief Indicates that the template processing thread's "interrupted" flag was found to be set.
 <p>ATTENTION: This is used by https://github.com/kenshoo/freemarker-online. Don't break backward compatibility without updating that project too!
 */
@interface FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor_TemplateProcessingThreadInterruptedException : JavaLangRuntimeException

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor_TemplateProcessingThreadInterruptedException)

FOUNDATION_EXPORT void FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor_TemplateProcessingThreadInterruptedException_init(FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor_TemplateProcessingThreadInterruptedException *self);

FOUNDATION_EXPORT FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor_TemplateProcessingThreadInterruptedException *new_FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor_TemplateProcessingThreadInterruptedException_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor_TemplateProcessingThreadInterruptedException)

#endif // _FreemarkerCoreThreadInterruptionSupportTemplatePostProcessor_H_
