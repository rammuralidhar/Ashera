//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ramm/git/Ashera/AsheraAndroidParser/freemarker/freemarker/template/utility/StringUtil.java
//

#ifndef _FreemarkerTemplateUtilityStringUtil_H_
#define _FreemarkerTemplateUtilityStringUtil_H_

#include "J2ObjC_header.h"

@class FreemarkerCoreEnvironment;
@class IOSCharArray;
@class IOSObjectArray;
@class JavaUtilLocale;
@protocol JavaUtilMap;

/**
 @brief Some text related utilities.
 */
@interface FreemarkerTemplateUtilityStringUtil : NSObject

#pragma mark Public

- (instancetype)init;

+ (NSString *)capitalizeWithNSString:(NSString *)s;

/**
 @brief Removes the line-break from the end of the string.
 */
+ (NSString *)chompWithNSString:(NSString *)s;

+ (JavaUtilLocale *)deduceLocaleWithNSString:(NSString *)input;

/**
 @brief Converts a 0-length string to null, leaves the string as is otherwise.
 @param s maybe <code>null</code> .
 */
+ (NSString *)emptyToNullWithNSString:(NSString *)s;

/**
 @brief Creates a <em>quoted</em> FTL string literal from a string, using escaping where necessary.
 The result either uses regular quotation marks (UCS 0x22) or apostrophe-quotes (UCS 0x27), depending on the string content. (Currently, apostrophe-quotes will be chosen exactly when the string contains regular quotation character and doesn't contain apostrophe-quote character.)
 @param s The value that should be converted to an FTL string literal whose evaluated value equals to <code>s</code>
 @since 2.3.22
 */
+ (NSString *)ftlQuoteWithNSString:(NSString *)s;

/**
 @brief FTL string literal decoding. \\, \", \', \n, \t, \r, \b and \f will be replaced according to Java rules.
 In additional, it knows \g, \l, \a and \{ which are replaced with &lt;, &gt;, &amp; and { respectively. \x works as hexadecimal character code escape. The character codes are interpreted according to UCS basic plane (Unicode). "f\x006Fo", "f\x06Fo" and "f\x6Fo" will be "foo". "f\x006F123" will be "foo123" as the maximum number of digits is 4. All other \X (where X is any character not mentioned above or End-of-string) will cause a ParseException.
 @param s String literal <em>without</em> the surrounding quotation marks
 @return String with all escape sequences resolved
 @throws ParseException if there string contains illegal escapes
 */
+ (NSString *)FTLStringLiteralDecWithNSString:(NSString *)s;

/**
 @brief Escapes a string according the FTL string literal escaping rules; it doesn't add the quotation marks.
 As this method doesn't know if the string literal is quoted with reuglar quotation marks or apostrophe quute, it will escape both.
 */
+ (NSString *)FTLStringLiteralEncWithNSString:(NSString *)s;

/**
 @brief Escapes a string according the FTL string literal escaping rules, assuming the literal is quoted with <code>quotation</code> ; it doesn't add the quotation marks itself.
 @param quotation Either <code>'"'</code> or <code>'\''</code> . It's assumed that the string literal whose part we calculate is enclosed within this kind of quotation mark. Thus, the other kind of quotation character will not be escaped in the result.
 @since 2.3.22
 */
+ (NSString *)FTLStringLiteralEncWithNSString:(NSString *)s
                                     withChar:(jchar)quotation;

+ (jboolean)getYesNoWithNSString:(NSString *)s;

/**
 @brief HTML encoding (does not convert line breaks and apostrophe-quote).
 Replaces all '&gt;' '&lt;' '&amp;' and '"' with entity reference, but not "'" (apostrophe-quote). The last is not escaped as back then when this was written some user agents didn't understood "&amp;apos;" nor "&amp;#39;".
 */
+ (NSString *)HTMLEncWithNSString:(NSString *)s;

/**
 @brief Tells if a character can occur in an FTL identifier expression (without escaping) as other than the first character.
 @since 2.3.22
 */
+ (jboolean)isFTLIdentifierPartWithChar:(jchar)c;

/**
 @brief Tells if a character can occur on the beginning of an FTL identifier expression (without escaping).
 @since 2.3.22
 */
+ (jboolean)isFTLIdentifierStartWithChar:(jchar)c;

/**
 @brief Tells if String#trim() will return a 0-length string for the String equivalent of the argument.
 @since 2.3.22
 */
+ (jboolean)isTrimmableToEmptyWithCharArray:(IOSCharArray *)text;

/**
 @brief Like #isTrimmableToEmpty(char[]) , but acts on a sub-array that starts at <code>start</code> (inclusive index).
 @since 2.3.23
 */
+ (jboolean)isTrimmableToEmptyWithCharArray:(IOSCharArray *)text
                                    withInt:(jint)start;

/**
 @brief Like #isTrimmableToEmpty(char[]) , but acts on a sub-array that starts at <code>start</code> (inclusive index) and ends at <code>end</code> (exclusive index).
 @since 2.3.23
 */
+ (jboolean)isTrimmableToEmptyWithCharArray:(IOSCharArray *)text
                                    withInt:(jint)start
                                    withInt:(jint)end;

/**
 @return whether the name is a valid XML tagname. (This routine might only be 99% accurate. Should maybe REVISIT)
 */
+ (jboolean)isXMLIDWithNSString:(NSString *)name;

/**
 @brief Escapes a String to be safely insertable into a JavaScript string literal; for more see #jsStringEnc(String,boolean) jsStringEnc(s, false) .
 */
+ (NSString *)javaScriptStringEncWithNSString:(NSString *)s;

/**
 @brief Escapes the <code>String</code> with the escaping rules of Java language string literals, so it's safe to insert the value into a string literal.
 The resulting string will not be quoted. <p>All characters under UCS code point 0x20 will be escaped. Where they have no dedicated escape sequence in Java, they will be replaced with hexadecimal escape (<tt>\</tt><tt>u<i>XXXX</i></tt>).
 */
+ (NSString *)javaStringEncWithNSString:(NSString *)s;

/**
 @brief Converts the parameter with <code>toString</code> (if it's not <code>null</code>) and passes it to #jQuote(String) .
 */
+ (NSString *)jQuoteWithId:(id)obj;

/**
 @brief Quotes string as Java Language string literal.
 Returns string <code>"null"</code> if <code>s</code> is <code>null</code>.
 */
+ (NSString *)jQuoteWithNSString:(NSString *)s;

/**
 @brief Converts the parameter with <code>toString</code> (if not <code>null</code>)and passes it to #jQuoteNoXSS(String) .
 */
+ (NSString *)jQuoteNoXSSWithId:(id)obj;

/**
 @brief Same as #jQuoteNoXSS(String) but also escapes <code>'&lt;'</code> as <code>\</code><code>u003C</code>.
 This is used for log messages to prevent XSS on poorly written Web-based log viewers.
 */
+ (NSString *)jQuoteNoXSSWithNSString:(NSString *)s;

/**
 @brief Escapes a String to be safely insertable into a JSON string literal; for more see #jsStringEnc(String,boolean) jsStringEnc(s, true) .
 */
+ (NSString *)jsonStringEncWithNSString:(NSString *)s;

/**
 @brief Escapes a String to be safely insertable into a JavaScript or a JSON string literal.
 The resulting string will <em>not</em> be quoted; the caller must ensure that they are there in the final output. Note that for JSON, the quotation marks must be <code>"</code> , not <code>'</code> , because JSON doesn't escape <code>'</code> . <p>The escaping rules guarantee that if the inside of the literal is from one or more touching sections of strings escaped with this, no character sequence will occur that closes the string literal or has special meaning in HTML/XML that can terminate the script section. (If, however, the escaped section is preceded by or followed by strings from other sources, this can't be guaranteed in some rare cases. Like <tt>x = "&lt;/${a?js_string}"</tt> might closes the "script" element if <code>a</code> is is <code>"script>"</code> .) The escaped characters are: <table style="width: auto; border-collapse: collapse" border="1" summary="Characters escaped by jsStringEnc"> <tr> <th>Input <th>Output <tr> <td><tt>"</tt> <td><tt>\"</tt> <tr> <td><tt>'</tt> if not in JSON-mode <td><tt>\'</tt> <tr> <td><tt>\</tt> <td><tt>\\</tt> <tr> <td><tt>/</tt> if the method can't know that it won't be directly after <tt>&lt;</tt> <td><tt>\/</tt> <tr> <td><tt>&gt;</tt> if the method can't know that it won't be directly after <tt>]]</tt> or <tt>--</tt> <td>JavaScript: <tt>\&gt;</tt>; JSON: <tt>\</tt><tt>u003E</tt> <tr> <td><tt>&lt;</tt> if the method can't know that it won't be directly followed by <tt>!</tt> or <tt>?</tt> <td><tt><tt>\</tt>u003C</tt> <tr> <td> u0000-u001f (UNICODE control characters - disallowed by JSON)<br> u007f-u009f (UNICODE control characters - disallowed by JSON) <td><tt>\n</tt>, <tt>\r</tt> and such, or if there's no such dedicated escape: JavaScript: <tt>\x<i>XX</i></tt>, JSON: <tt>\<tt>u</tt><i>XXXX</i></tt> <tr> <td> u2028 (Line separator - source code line-break in ECMAScript)<br> u2029 (Paragraph separator - source code line-break in ECMAScript)<br> <td><tt>\<tt>u</tt><i>XXXX</i></tt> </table>
 @since 2.3.20
 */
+ (NSString *)jsStringEncWithNSString:(NSString *)s
                          withBoolean:(jboolean)json;

/**
 @brief Pads the string at the left with spaces until it reaches the desired length.
 If the string is longer than this length, then it returns the unchanged string.
 @param s the string that will be padded.
 @param minLength the length to reach.
 */
+ (NSString *)leftPadWithNSString:(NSString *)s
                          withInt:(jint)minLength;

/**
 @brief Pads the string at the left with the specified character until it reaches the desired length.
 If the string is longer than this length, then it returns the unchanged string.
 @param s the string that will be padded.
 @param minLength the length to reach.
 @param filling the filling pattern.
 */
+ (NSString *)leftPadWithNSString:(NSString *)s
                          withInt:(jint)minLength
                         withChar:(jchar)filling;

/**
 @brief Pads the string at the left with a filling pattern until it reaches the desired length.
 If the string is longer than this length, then it returns the unchanged string. For example: <code>leftPad('ABC', 9, '1234')</code> returns <code>"123412ABC"</code>.
 @param s the string that will be padded.
 @param minLength the length to reach.
 @param filling the filling pattern. Must be at least 1 characters long. Can't be <code>null</code>.
 */
+ (NSString *)leftPadWithNSString:(NSString *)s
                          withInt:(jint)minLength
                     withNSString:(NSString *)filling;

/**
 @return whether the qname matches the combination of nodeName, nsURI, and environment prefix settings.
 */
+ (jboolean)matchesNameWithNSString:(NSString *)qname
                       withNSString:(NSString *)nodeName
                       withNSString:(NSString *)nsURI
      withFreemarkerCoreEnvironment:(FreemarkerCoreEnvironment *)env;

/**
 @brief Parses a name-value pair list, where the pairs are separated with comma, and the name and value is separated with colon.
 The keys and values can contain only letters, digits and <tt>_</tt>. They can't be quoted. White-space around the keys and values are ignored. The value can be omitted if <code>defaultValue</code> is not null. When a value is omitted, then the colon after the key must be omitted as well. The same key can't be used for multiple times.
 @param s the string to parse. For example: <code>"strong:100, soft:900"</code>.
 @param defaultValue the value used when the value is omitted in a key-value pair.
 @return the map that contains the name-value pairs.
 @throws java.text.ParseException if the string is not a valid name-value pair list.
 */
+ (id<JavaUtilMap>)parseNameValuePairListWithNSString:(NSString *)s
                                         withNSString:(NSString *)defaultValue;

/**
 @brief Same as #replace(String,String,String,boolean,boolean) with two <code>false</code> parameters.
 @since 2.3.20
 */
+ (NSString *)replaceWithNSString:(NSString *)text
                     withNSString:(NSString *)oldSub
                     withNSString:(NSString *)newSub;

/**
 @brief Replaces all occurrences of a sub-string in a string.
 @param text The string where it will replace <code>oldsub</code> with <code>newsub</code>.
 @return String The string after the replacements.
 */
+ (NSString *)replaceWithNSString:(NSString *)text
                     withNSString:(NSString *)oldsub
                     withNSString:(NSString *)newsub
                      withBoolean:(jboolean)caseInsensitive
                      withBoolean:(jboolean)firstOnly;

/**
 @brief Pads the string at the right with spaces until it reaches the desired length.
 If the string is longer than this length, then it returns the unchanged string.
 @param s the string that will be padded.
 @param minLength the length to reach.
 */
+ (NSString *)rightPadWithNSString:(NSString *)s
                           withInt:(jint)minLength;

/**
 @brief Pads the string at the right with the specified character until it reaches the desired length.
 If the string is longer than this length, then it returns the unchanged string.
 @param s the string that will be padded.
 @param minLength the length to reach.
 @param filling the filling pattern.
 */
+ (NSString *)rightPadWithNSString:(NSString *)s
                           withInt:(jint)minLength
                          withChar:(jchar)filling;

/**
 @brief Pads the string at the right with a filling pattern until it reaches the desired length.
 If the string is longer than this length, then it returns the unchanged string. For example: <code>rightPad('ABC', 9, '1234')</code> returns <code>"ABC412341"</code>. Note that the filling pattern is started as if you overlay <code>"123412341"</code> with the left-aligned <code>"ABC"</code>, so it starts with <code>"4"</code>.
 @param s the string that will be padded.
 @param minLength the length to reach.
 @param filling the filling pattern. Must be at least 1 characters long. Can't be <code>null</code>.
 */
+ (NSString *)rightPadWithNSString:(NSString *)s
                           withInt:(jint)minLength
                      withNSString:(NSString *)filling;

/**
 @brief Rich Text Format encoding (does not replace line breaks).
 Escapes all '\' '{' '}' and '"'
 */
+ (NSString *)RTFEncWithNSString:(NSString *)s;

/**
 @brief Splits a string at the specified character.
 */
+ (IOSObjectArray *)splitWithNSString:(NSString *)s
                             withChar:(jchar)c;

/**
 @brief Splits a string at the specified string.
 */
+ (IOSObjectArray *)splitWithNSString:(NSString *)s
                         withNSString:(NSString *)sep
                          withBoolean:(jboolean)caseInsensitive;

/**
 @brief Same as #toUpperABC(int) , but produces lower case result, like <code>"ab"</code> .
 @since 2.3.22
 */
+ (NSString *)toLowerABCWithInt:(jint)n;

/**
 @brief Converts <code>1</code> , <code>2</code> , <code>3</code> and so forth to <code>"A"</code> , <code>"B"</code> , <code>"C"</code> and so fort.
 When reaching <code>"Z"</code> , it continues like <code>"AA"</code> , <code>"AB"</code> , etc. The lowest supported number is 1, but there's no upper limit.
 @throws IllegalArgumentException If the argument is 0 or less.
 @since 2.3.22
 */
+ (NSString *)toUpperABCWithInt:(jint)n;

/**
 @brief Behaves exactly like String#trim() , but works on arrays.
 If the resulting array would have the same content after trimming, it returns the original array instance. Otherwise it returns a new array instance (or CollectionUtils#EMPTY_CHAR_ARRAY ).
 @since 2.3.22
 */
+ (IOSCharArray *)trimWithCharArray:(IOSCharArray *)cs;

/**
 @brief Tries to run <code>toString()</code> , but if that fails, returns a <code>"[com.example.SomeClass.toString() failed: " + e + "]"</code> instead.
 Also, it returns <code>null</code> for <code>null</code> parameter.
 @since 2.3.20
 */
+ (NSString *)tryToStringWithId:(id)object;

/**
 @brief URL encoding (like%20this) for query parameter values, path <em>segments</em>, fragments; this encodes all characters that are reserved anywhere.
 */
+ (NSString *)URLEncWithNSString:(NSString *)s
                    withNSString:(NSString *)charset;

/**
 @brief Like #URLEnc(String,String) but doesn't escape the slash character ( <code>/</code> ).
 This can be used to encode a path only if you know that no folder or file name will contain <code>/</code> character (not in the path, but in the name itself), which usually stands, as the commonly used OS-es don't allow that.
 @since 2.3.21
 */
+ (NSString *)URLPathEncWithNSString:(NSString *)s
                        withNSString:(NSString *)charset;

/**
 @brief Converts a version number string to an integer for easy comparison.
 The version number must start with numbers separated with dots. There can be any number of such dot-separated numbers, but only the first three will be considered. After the numbers arbitrary text can follow, and will be ignored. The string will be trimmed before interpretation.
 @return major * 1000000 + minor * 1000 + micro
 */
+ (jint)versionStringToIntWithNSString:(NSString *)version_;

/**
 @brief XHTML Encoding.
 Replaces all '&gt;' '&lt;' '&amp;', "'" and '"' with entity reference suitable for XHTML decoding in common user agents (including legacy user agents, which do not decode "&amp;apos;" to "'", so "&amp;#39;" is used instead [see http://www.w3.org/TR/xhtml1/#C_16])
 */
+ (NSString *)XHTMLEncWithNSString:(NSString *)s;

/**
 @brief XML Encoding.
 Replaces all '&gt;' '&lt;' '&amp;', "'" and '"' with entity reference
 */
+ (NSString *)XMLEncWithNSString:(NSString *)s;

/**
 @brief XML encoding without replacing apostrophes.
 */
+ (NSString *)XMLEncNAWithNSString:(NSString *)s;

/**
 @brief XML encoding without replacing apostrophes and quotation marks and greater-thans (except in <code>]]></code> ).
 */
+ (NSString *)XMLEncNQGWithNSString:(NSString *)s;

/**
 @brief XML encoding for attributes values quoted with <tt>"</tt> (not with <tt>'</tt>!).
 Also can be used for HTML attributes that are quoted with <tt>"</tt>.
 */
+ (NSString *)XMLEncQAttrWithNSString:(NSString *)s;

@end

J2OBJC_STATIC_INIT(FreemarkerTemplateUtilityStringUtil)

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_HTMLEncWithNSString_(NSString *s);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_XMLEncWithNSString_(NSString *s);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_XHTMLEncWithNSString_(NSString *s);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_XMLEncNAWithNSString_(NSString *s);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_XMLEncQAttrWithNSString_(NSString *s);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_XMLEncNQGWithNSString_(NSString *s);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_RTFEncWithNSString_(NSString *s);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_URLEncWithNSString_withNSString_(NSString *s, NSString *charset);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_URLPathEncWithNSString_withNSString_(NSString *s, NSString *charset);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_FTLStringLiteralEncWithNSString_withChar_(NSString *s, jchar quotation);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_FTLStringLiteralEncWithNSString_(NSString *s);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_FTLStringLiteralDecWithNSString_(NSString *s);

FOUNDATION_EXPORT JavaUtilLocale *FreemarkerTemplateUtilityStringUtil_deduceLocaleWithNSString_(NSString *input);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_capitalizeWithNSString_(NSString *s);

FOUNDATION_EXPORT jboolean FreemarkerTemplateUtilityStringUtil_getYesNoWithNSString_(NSString *s);

FOUNDATION_EXPORT IOSObjectArray *FreemarkerTemplateUtilityStringUtil_splitWithNSString_withChar_(NSString *s, jchar c);

FOUNDATION_EXPORT IOSObjectArray *FreemarkerTemplateUtilityStringUtil_splitWithNSString_withNSString_withBoolean_(NSString *s, NSString *sep, jboolean caseInsensitive);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_replaceWithNSString_withNSString_withNSString_(NSString *text, NSString *oldSub, NSString *newSub);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_replaceWithNSString_withNSString_withNSString_withBoolean_withBoolean_(NSString *text, NSString *oldsub, NSString *newsub, jboolean caseInsensitive, jboolean firstOnly);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_chompWithNSString_(NSString *s);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_emptyToNullWithNSString_(NSString *s);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_jQuoteWithId_(id obj);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_jQuoteWithNSString_(NSString *s);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_jQuoteNoXSSWithId_(id obj);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_jQuoteNoXSSWithNSString_(NSString *s);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_ftlQuoteWithNSString_(NSString *s);

FOUNDATION_EXPORT jboolean FreemarkerTemplateUtilityStringUtil_isFTLIdentifierStartWithChar_(jchar c);

FOUNDATION_EXPORT jboolean FreemarkerTemplateUtilityStringUtil_isFTLIdentifierPartWithChar_(jchar c);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_javaStringEncWithNSString_(NSString *s);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_javaScriptStringEncWithNSString_(NSString *s);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_jsonStringEncWithNSString_(NSString *s);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_jsStringEncWithNSString_withBoolean_(NSString *s, jboolean json);

FOUNDATION_EXPORT id<JavaUtilMap> FreemarkerTemplateUtilityStringUtil_parseNameValuePairListWithNSString_withNSString_(NSString *s, NSString *defaultValue);

FOUNDATION_EXPORT jboolean FreemarkerTemplateUtilityStringUtil_isXMLIDWithNSString_(NSString *name);

FOUNDATION_EXPORT jboolean FreemarkerTemplateUtilityStringUtil_matchesNameWithNSString_withNSString_withNSString_withFreemarkerCoreEnvironment_(NSString *qname, NSString *nodeName, NSString *nsURI, FreemarkerCoreEnvironment *env);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_leftPadWithNSString_withInt_(NSString *s, jint minLength);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_leftPadWithNSString_withInt_withChar_(NSString *s, jint minLength, jchar filling);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_leftPadWithNSString_withInt_withNSString_(NSString *s, jint minLength, NSString *filling);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_rightPadWithNSString_withInt_(NSString *s, jint minLength);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_rightPadWithNSString_withInt_withChar_(NSString *s, jint minLength, jchar filling);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_rightPadWithNSString_withInt_withNSString_(NSString *s, jint minLength, NSString *filling);

FOUNDATION_EXPORT jint FreemarkerTemplateUtilityStringUtil_versionStringToIntWithNSString_(NSString *version_);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_tryToStringWithId_(id object);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_toUpperABCWithInt_(jint n);

FOUNDATION_EXPORT NSString *FreemarkerTemplateUtilityStringUtil_toLowerABCWithInt_(jint n);

FOUNDATION_EXPORT IOSCharArray *FreemarkerTemplateUtilityStringUtil_trimWithCharArray_(IOSCharArray *cs);

FOUNDATION_EXPORT jboolean FreemarkerTemplateUtilityStringUtil_isTrimmableToEmptyWithCharArray_(IOSCharArray *text);

FOUNDATION_EXPORT jboolean FreemarkerTemplateUtilityStringUtil_isTrimmableToEmptyWithCharArray_withInt_(IOSCharArray *text, jint start);

FOUNDATION_EXPORT jboolean FreemarkerTemplateUtilityStringUtil_isTrimmableToEmptyWithCharArray_withInt_withInt_(IOSCharArray *text, jint start, jint end);

FOUNDATION_EXPORT void FreemarkerTemplateUtilityStringUtil_init(FreemarkerTemplateUtilityStringUtil *self);

FOUNDATION_EXPORT FreemarkerTemplateUtilityStringUtil *new_FreemarkerTemplateUtilityStringUtil_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerTemplateUtilityStringUtil)

#endif // _FreemarkerTemplateUtilityStringUtil_H_
