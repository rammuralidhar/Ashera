//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ramm/git/Ashera/AsheraAndroidParser/freemarker/freemarker/core/TemplateDateFormatFactory.java
//

#ifndef _FreemarkerCoreTemplateDateFormatFactory_H_
#define _FreemarkerCoreTemplateDateFormatFactory_H_

#include "J2ObjC_header.h"

@class FreemarkerCoreTemplateDateFormat;
@class JavaUtilTimeZone;

/**
 @brief Creates TemplateDateFormat -s for a fixed time zone, and if it producers formatters that are sensitive to locale, for a fixed locale.
 Thus, FreeMarker should maintain a separate instance for each time zone that's frequently used, or if #isLocaleBound() is <code>true</code> , for each TimeZone - Locale permutation that's frequently used. Reusing the factories is useful as some factories cache instances internally for the <code>dateType</code> - <code>formatDescriptor</code> pairs. <p> TemplateDateFormatFactory -es need not be thread-safe. Currently (2.3.21) they are (re)used only from within a single Environment instance.
 */
@interface FreemarkerCoreTemplateDateFormatFactory : NSObject

#pragma mark Public

- (instancetype)initWithJavaUtilTimeZone:(JavaUtilTimeZone *)timeZone;

/**
 @brief Returns the TemplateDateFormat for the <code>dateType</code> and <code>formatDescriptor</code> given via the arguments, and the <code>TimeZone</code> and <code>Locale</code> (if that's relevant) to which the TemplateDateFormatFactory belongs to.
 @param dateType  TemplateDateModel#DATE , TemplateDateModel#TIME , TemplateDateModel#DATETIME or TemplateDateModel#UNKNOWN . Supporting TemplateDateModel#UNKNOWN is not necessary, in which case the method should throw an UnknownDateTypeFormattingUnsupportedException exception.
 @param zonelessInput Indicates that the input Java Date is not from a time zone aware source. When this is <code>true</code> , the formatters shouldn't override the time zone provided to its constructor or factory method (most formatters don't do that anyway), and it shouldn't show the time zone, if it can hide it (like a SimpleDateFormat pattern-based formatter may can't do that, as the pattern prescribes what to show). <p>As of FreeMarker 2.3.21, this is <code>true</code> exactly when the date is an SQL "date without time of the day" (i.e., a java.sql.Date java.sql.Date ) or an SQL "time of the day" value (i.e., a java.sql.Time java.sql.Time , although this rule can change in future, depending on configuration settings and such, so you should rely on this rule, just accept what this parameter says.
 @param formatDescriptor The string used as <code>..._format</code> the configuration setting value (among others), like <code>"iso m"</code> or <code>"dd.MM.yyyy HH:mm"</code> . The implementation is only supposed to understand a particular kind of format descriptor, for which FreeMarker routes to this factory. (Like, the ISOTemplateDateFormatFactory is only called for format descriptors that start with "iso".)
 @throws ParseException if the <code>formatDescriptor</code> is malformed
 @throws TemplateModelException if the <code>dateType</code> is unsupported by the formatter
 @throws UnknownDateTypeFormattingUnsupportedException if <code>dateType</code> is TemplateDateModel#UNKNOWN , and that's unsupported by the formatter implementation.
 */
- (FreemarkerCoreTemplateDateFormat *)getWithInt:(jint)dateType
                                     withBoolean:(jboolean)zonelessInput
                                    withNSString:(NSString *)formatDescriptor;

- (JavaUtilTimeZone *)getTimeZone;

/**
 @brief Whether this factory is sensitive to Locale ; if the created TemplateDateFormat -s are, then the factory should be too <code>true</code> .
 */
- (jboolean)isLocaleBound;

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerCoreTemplateDateFormatFactory)

FOUNDATION_EXPORT void FreemarkerCoreTemplateDateFormatFactory_initWithJavaUtilTimeZone_(FreemarkerCoreTemplateDateFormatFactory *self, JavaUtilTimeZone *timeZone);

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerCoreTemplateDateFormatFactory)

#endif // _FreemarkerCoreTemplateDateFormatFactory_H_
