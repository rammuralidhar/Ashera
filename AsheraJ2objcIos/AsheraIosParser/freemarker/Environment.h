//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ramm/git/Ashera/AsheraAndroidParser/freemarker/freemarker/core/Environment.java
//

#ifndef _FreemarkerCoreEnvironment_H_
#define _FreemarkerCoreEnvironment_H_

#include "Configurable.h"
#include "J2ObjC_header.h"
#include "SimpleHash.h"
#include "TemplateDirectiveBody.h"

@class FreemarkerCoreBodyInstruction_Context;
@class FreemarkerCoreEnvironment_Namespace;
@class FreemarkerCoreExpression;
@class FreemarkerCoreIteratorBlock_IterationContext;
@class FreemarkerCoreMacro;
@class FreemarkerCoreMacro_Context;
@class FreemarkerCoreRecoveryBlock;
@class FreemarkerCoreTemplateDateFormat;
@class FreemarkerCoreTemplateElement;
@class FreemarkerTemplateConfiguration;
@class FreemarkerTemplateTemplate;
@class IOSClass;
@class IOSObjectArray;
@class JavaIoPrintWriter;
@class JavaIoWriter;
@class JavaLangStringBuffer;
@class JavaTextCollator;
@class JavaTextNumberFormat;
@class JavaUtilArrayList;
@class JavaUtilLocale;
@class JavaUtilTimeZone;
@protocol FreemarkerCoreDirectiveCallPlace;
@protocol FreemarkerTemplateTemplateDateModel;
@protocol FreemarkerTemplateTemplateDirectiveModel;
@protocol FreemarkerTemplateTemplateExceptionHandler;
@protocol FreemarkerTemplateTemplateHashModel;
@protocol FreemarkerTemplateTemplateModel;
@protocol FreemarkerTemplateTemplateNodeModel;
@protocol FreemarkerTemplateTemplateSequenceModel;
@protocol FreemarkerTemplateTemplateTransformModel;
@protocol FreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory;
@protocol JavaUtilList;
@protocol JavaUtilMap;
@protocol JavaUtilSet;

/**
 @brief Object that represents the runtime environment during template processing.
 For every invocation of a <tt>Template.process()</tt> method, a new instance of this object is created, and then discarded when <tt>process()</tt> returns. This object stores the set of temporary variables created by the template, the value of settings set by the template, the reference to the data model root, etc. Everything that is needed to fulfill the template processing job. <p>Data models that need to access the <tt>Environment</tt> object that represents the template processing on the current thread can use the #getCurrentEnvironment() method. <p>If you need to modify or read this object before or after the <tt>process</tt> call, use Template#createProcessingEnvironment(Object rootMap,Writer out,ObjectWrapper wrapper)
 */
@interface FreemarkerCoreEnvironment : FreemarkerCoreConfigurable

#pragma mark Public

- (instancetype)initWithFreemarkerTemplateTemplate:(FreemarkerTemplateTemplate *)template_
           withFreemarkerTemplateTemplateHashModel:(id<FreemarkerTemplateTemplateHashModel>)rootDataModel
                                  withJavaIoWriter:(JavaIoWriter *)outArg;

/**
 @brief A hook that Jython uses.
 */
- (id)__getitem__WithNSString:(NSString *)key;

/**
 @brief A hook that Jython uses.
 */
- (void)__setitem__WithNSString:(NSString *)key
                         withId:(id)o;

/**
 @brief Compares two TemplateModel -s according the rules of the FTL "==" operator.
 @since 2.3.20
 */
- (jboolean)applyEqualsOperatorWithFreemarkerTemplateTemplateModel:(id<FreemarkerTemplateTemplateModel>)leftValue
                               withFreemarkerTemplateTemplateModel:(id<FreemarkerTemplateTemplateModel>)rightValue;

/**
 @brief Compares two TemplateModel -s according the rules of the FTL "==" operator, except that if the two types are incompatible, they are treated as non-equal instead of throwing an exception.
 Comparing dates of different types (date-only VS time-only VS date-time) will still throw an exception, however.
 @since 2.3.20
 */
- (jboolean)applyEqualsOperatorLenientWithFreemarkerTemplateTemplateModel:(id<FreemarkerTemplateTemplateModel>)leftValue
                                      withFreemarkerTemplateTemplateModel:(id<FreemarkerTemplateTemplateModel>)rightValue;

/**
 @brief Compares two TemplateModel -s according the rules of the FTL "&gt;" operator.
 @since 2.3.20
 */
- (jboolean)applyGreaterThanOperatorWithFreemarkerTemplateTemplateModel:(id<FreemarkerTemplateTemplateModel>)leftValue
                                    withFreemarkerTemplateTemplateModel:(id<FreemarkerTemplateTemplateModel>)rightValue;

/**
 @brief Compares two TemplateModel -s according the rules of the FTL "&lt;" operator.
 @since 2.3.20
 */
- (jboolean)applyLessThanOperatorWithFreemarkerTemplateTemplateModel:(id<FreemarkerTemplateTemplateModel>)leftValue
                                 withFreemarkerTemplateTemplateModel:(id<FreemarkerTemplateTemplateModel>)rightValue;

/**
 @brief Compares two TemplateModel -s according the rules of the FTL "&lt;" operator.
 @since 2.3.20
 */
- (jboolean)applyLessThanOrEqualsOperatorWithFreemarkerTemplateTemplateModel:(id<FreemarkerTemplateTemplateModel>)leftValue
                                         withFreemarkerTemplateTemplateModel:(id<FreemarkerTemplateTemplateModel>)rightValue;

/**
 @brief Compares two TemplateModel -s according the rules of the FTL "&gt;=" operator.
 @since 2.3.20
 */
- (jboolean)applyWithGreaterThanOrEqualsOperatorWithFreemarkerTemplateTemplateModel:(id<FreemarkerTemplateTemplateModel>)leftValue
                                                withFreemarkerTemplateTemplateModel:(id<FreemarkerTemplateTemplateModel>)rightValue;

/**
 @brief Returns the NumberFormat used for the <tt>c</tt> built-in.
 This is always US English <code>"0.################"</code>, without grouping and without superfluous decimal separator.
 */
- (JavaTextNumberFormat *)getCNumberFormat;

- (FreemarkerTemplateConfiguration *)getConfiguration;

/**
 @brief Gets the currently executing <em>custom</em> directive's call place information, or <code>null</code> if there's no executing custom directive.
 This currently only works for calls made from templates with the <code><@@...></code> syntax. This should only be called from the TemplateDirectiveModel that was invoked with <code><@@...></code> , otherwise its return value is not defined by this API (it's usually <code>null</code> ).
 @since 2.3.22
 */
- (id<FreemarkerCoreDirectiveCallPlace>)getCurrentDirectiveCallPlace;

/**
 @brief Retrieves the environment object associated with the current thread, or <code>null</code> if there's no template processing going on in this thread.
 Data model implementations that need access to the environment can call this method to obtain the environment object that represents the template processing that is currently running on the current thread.
 */
+ (FreemarkerCoreEnvironment *)getCurrentEnvironment;

/**
 @brief Returns the current namespace.
 This corresponds to the FTL <code>.namespace</code> hash. Initially, the current name space is the main namespace, but when inside an <code>#import</code> -ed template, it will change to the namespace of that import. Note that <code>#include</code> doesn't affect the namespace, so if you are in an <code>#import</code> -ed template and then from there do an <code>#include</code> , the current namespace will remain the namespace of the <code>#import</code> .
 */
- (FreemarkerCoreEnvironment_Namespace *)getCurrentNamespace;

/**
 @brief Returns the Template that we are "lexically" inside at the moment.
 This template will change when entering an <code>#include</code> or calling a macro or function in another template, or returning to yet another template with <code>#nested</code> . As such, it's useful in TemplateDirectiveModel to find out if from where the directive was called from.
 @since 2.3.23
 */
- (FreemarkerTemplateTemplate *)getCurrentTemplate;

- (id<FreemarkerTemplateTemplateNodeModel>)getCurrentVisitorNode;

/**
 @brief Returns the data-model (also known as the template context in some other template engines).
 */
- (id<FreemarkerTemplateTemplateHashModel>)getDataModel;

/**
 @return the default node namespace for the current FTL namespace
 */
- (NSString *)getDefaultNS;

/**
 @brief Returns the name-space that contains the globally visible non-data-model variables (usually created with <code>&lt;#global ...
 &gt;</code> ).
 */
- (FreemarkerCoreEnvironment_Namespace *)getGlobalNamespace;

/**
 @brief Returns the globally visible variable of the given name (or null).
 This is correspondent to FTL <code>.globals.<i>name</i></code>. This will first look at variables that were assigned globally via: &lt;#global ...&gt; and then at the data model exposed to the template.
 */
- (id<FreemarkerTemplateTemplateModel>)getGlobalVariableWithNSString:(NSString *)name;

/**
 @brief Returns the read-only hash of globally visible variables.
 This is the correspondent of FTL <code>.globals</code> hash. That is, you see the variables created with <code>&lt;#global ...&gt;</code>, and the variables of the data-model. To create new global variables, use #setGlobalVariable setGlobalVariable .
 */
- (id<FreemarkerTemplateTemplateHashModel>)getGlobalVariables;

/**
 @brief Returns a set of variable names that are known at the time of call.
 This includes names of all shared variables in the Configuration , names of all global variables that were assigned during the template processing, names of all variables in the current name-space, names of all local variables and loop variables. If the passed root data model implements the TemplateHashModelEx interface, then all names it retrieves through a call to TemplateHashModelEx#keys() method are returned as well. The method returns a new Set object on each call that is completely disconnected from the Environment. That is, modifying the set will have no effect on the Environment object.
 */
- (id<JavaUtilSet>)getKnownVariableNames;

/**
 @brief Returns the loop or macro local variable corresponding to this variable name.
 Possibly null. (Note that the misnomer is kept for backward compatibility: loop variables are not local variables according to our terminology.)
 */
- (id<FreemarkerTemplateTemplateModel>)getLocalVariableWithNSString:(NSString *)name;

/**
 @brief Returns the main namespace.
 This corresponds to the FTL <code>.main</code> hash.
 */
- (FreemarkerCoreEnvironment_Namespace *)getMainNamespace;

/**
 @brief Returns the topmost Template , with other words, the one for which this Environment was created.
 That template will never change, like <code>#include</code> or macro calls don't change it.
 @since 2.3.22
 */
- (FreemarkerTemplateTemplate *)getMainTemplate;

/**
 @brief Returns the name-space for the name if exists, or null.
 @param name the template path that you have used with the <code>import</code> directive or #importLib(String,String) call, in normalized form. That is, the path must be an absolute path, and it must not contain "/../" or "/./". The leading "/" is optional.
 */
- (FreemarkerCoreEnvironment_Namespace *)getNamespaceWithNSString:(NSString *)name;

/**
 @return the namespace URI registered for this prefix, or null. This is based on the mappings registered in the current namespace.
 */
- (NSString *)getNamespaceForPrefixWithNSString:(NSString *)prefix;

- (JavaIoWriter *)getOut;

- (NSString *)getPrefixForNamespaceWithNSString:(NSString *)nsURI;

/**
 @brief Despite its name it just returns #getParent() .
 If Configuration#getIncompatibleImprovements() is at least 2.3.22, then that will be the same as #getMainTemplate() . Otherwise the returned value follows the Environment parent switchings that occur at <code>#include</code> / <code>#import</code> and <code>#nested</code> directive calls, that is, it's not very meaningful outside FreeMarker internals.
 */
- (FreemarkerTemplateTemplate *)getTemplate;

/**
 @brief Gets a template for importing; used with #importLib(Template importedTemplate,String namespace) .
 The advantage over simply using <code>config.getTemplate(...)</code> is that it chooses the encoding as the <code>import</code> directive does.
 @param name the name of the template, relatively to the template root directory (not the to the directory of the currently executing template file!). (Note that you can use freemarker.cache.TemplateCache#getFullTemplatePath to convert paths to template root relative paths.)
 */
- (FreemarkerTemplateTemplate *)getTemplateForImportingWithNSString:(NSString *)name;

/**
 @brief Same as #getTemplateForInclusion(String,String,boolean,boolean) with <code>false</code> <code>ignoreMissign</code> argument.
 */
- (FreemarkerTemplateTemplate *)getTemplateForInclusionWithNSString:(NSString *)name
                                                       withNSString:(NSString *)encoding
                                                        withBoolean:(jboolean)parse;

/**
 @brief Gets a template for inclusion; used for implementing #include(Template includedTemplate) .
 The advantage over simply using <code>config.getTemplate(...)</code> is that it chooses the default encoding exactly as the <code>include</code> directive does, although that encoding selection mechanism is a historical baggage and considered to be harmful.
 @param name the name of the template, relatively to the template root directory (not the to the directory of the currently executing template file). (Note that you can use freemarker.cache.TemplateCache#getFullTemplatePath to convert paths to template root relative paths.) For more details see the identical parameter of Configuration#getTemplate(String,Locale,String,boolean,boolean)
 @param encoding the charset of the obtained template. If <code>null</code> , the encoding of the top template that is currently being processed in this Environment is used, which can lead to odd situations, so using <code>null</code> is not recommended. In most applications, the value of Configuration#getEncoding(Locale) (or Configuration#getDefaultEncoding() ) should be used here.
 @param parseAsFTL See identical parameter of Configuration#getTemplate(String,Locale,String,boolean,boolean)
 @param ignoreMissing See identical parameter of Configuration#getTemplate(String,Locale,String,boolean,boolean)
 @return Same as Configuration#getTemplate(String,Locale,String,boolean,boolean)
 @throws IOException Same as exceptions thrown by Configuration#getTemplate(String,Locale,String,boolean,boolean)
 @since 2.3.21
 */
- (FreemarkerTemplateTemplate *)getTemplateForInclusionWithNSString:(NSString *)name
                                                       withNSString:(NSString *)encoding
                                                        withBoolean:(jboolean)parseAsFTL
                                                        withBoolean:(jboolean)ignoreMissing;

/**
 @brief Returns the variable that is visible in this context, or <code>null</code> if the variable is not found.
 This is the correspondent to an FTL top-level variable reading expression. That is, it tries to find the the variable in this order: <ol> <li>An loop variable (if we're in a loop or user defined directive body) such as foo_has_next <li>A local variable (if we're in a macro) <li>A variable defined in the current namespace (say, via &lt;#assign ...&gt;) <li>A variable defined globally (say, via &lt;#global ....&gt;) <li>Variable in the data model: <ol> <li>A variable in the root hash that was exposed to this rendering environment in the Template.process(...) call <li>A shared variable set in the configuration via a call to Configuration.setSharedVariable(...) </ol> </li> </ol>
 */
- (id<FreemarkerTemplateTemplateModel>)getVariableWithNSString:(NSString *)name;

/**
 @brief Emulates <code>import</code> directive, except that <code>name</code> must be tempate root relative.
 <p>It's the same as <code>importLib(getTemplateForImporting(name), namespace)</code>. But, you may want to separately call these two methods, so you can determine the source of exceptions more precisely, and thus achieve more intelligent error handling.
 */
- (FreemarkerCoreEnvironment_Namespace *)importLibWithNSString:(NSString *)name
                                                  withNSString:(NSString *)namespace_;

/**
 @brief Emulates <code>import</code> directive.
 @param loadedTemplate the template to import. Note that it does <em>not</em> need to be a template returned by #getTemplateForImporting(String name) .
 */
- (FreemarkerCoreEnvironment_Namespace *)importLibWithFreemarkerTemplateTemplate:(FreemarkerTemplateTemplate *)loadedTemplate
                                                                    withNSString:(NSString *)namespace_;

/**
 @brief Emulates <code>include</code> directive, except that <code>name</code> must be tempate root relative.
 <p>It's the same as <code>include(getTemplateForInclusion(name, encoding, parse))</code>. But, you may want to separately call these two methods, so you can determine the source of exceptions more precisely, and thus achieve more intelligent error handling.
 */
- (void)includeWithNSString:(NSString *)name
               withNSString:(NSString *)encoding
                withBoolean:(jboolean)parse;

/**
 @brief Processes a Template in the context of this <code>Environment</code>, including its output in the <code>Environment</code>'s Writer.
 @param includedTemplate the template to process. Note that it does <em>not</em> need to be a template returned by #getTemplateForInclusion(String name,String encoding,boolean parse) .
 */
- (void)includeWithFreemarkerTemplateTemplate:(FreemarkerTemplateTemplate *)includedTemplate;

/**
 @brief Tells if we are inside an <tt>#attempt</tt> block (but before <tt>#recover</tt>).
 This can be useful for TemplateExceptionHandler -s, as then they may don't want to print the error to the output, as <tt>#attempt</tt> will roll it back anyway.
 @since 2.3.20
 */
- (jboolean)isInAttemptBlock;

/**
 @brief Prints the current FTL stack trace.
 Useful for debugging. TemplateException s incorporate this information in their stack traces.
 */
- (void)outputInstructionStackWithJavaIoPrintWriter:(JavaIoPrintWriter *)pw;

/**
 @brief Processes the template to which this environment belongs to.
 */
- (void)process;

/**
 @brief sets TemplateNodeModel as the current visitor node.
 <tt>.current_node</tt>
 */
- (void)setCurrentVisitorNodeWithFreemarkerTemplateTemplateNodeModel:(id<FreemarkerTemplateTemplateNodeModel>)node;

- (void)setDateFormatWithNSString:(NSString *)dateFormat;

- (void)setDateTimeFormatWithNSString:(NSString *)dateTimeFormat;

/**
 @brief Sets a variable that is visible globally.
 This is correspondent to FTL <code>&lt;#global <i>name</i>=<i>model</i>&gt;</code>. This can be considered a convenient shorthand for: getGlobalNamespace().put(name, model)
 */
- (void)setGlobalVariableWithNSString:(NSString *)name
  withFreemarkerTemplateTemplateModel:(id<FreemarkerTemplateTemplateModel>)model;

- (void)setLocaleWithJavaUtilLocale:(JavaUtilLocale *)locale;

/**
 @brief Sets a local variable (one effective only during a macro invocation).
 This is correspondent to FTL <code>&lt;#local <i>name</i>=<i>model</i>&gt;</code>.
 @param name the identifier of the variable
 @param model the value of the variable.
 @throws IllegalStateException if the environment is not executing a macro body.
 */
- (void)setLocalVariableWithNSString:(NSString *)name
 withFreemarkerTemplateTemplateModel:(id<FreemarkerTemplateTemplateModel>)model;

- (void)setNumberFormatWithNSString:(NSString *)formatName;

- (void)setOutWithJavaIoWriter:(JavaIoWriter *)outArg;

- (void)setOutputEncodingWithNSString:(NSString *)outputEncoding;

- (void)setSQLDateAndTimeTimeZoneWithJavaUtilTimeZone:(JavaUtilTimeZone *)timeZone;

- (void)setTemplateExceptionHandlerWithFreemarkerTemplateTemplateExceptionHandler:(id<FreemarkerTemplateTemplateExceptionHandler>)templateExceptionHandler;

- (void)setTimeFormatWithNSString:(NSString *)timeFormat;

- (void)setTimeZoneWithJavaUtilTimeZone:(JavaUtilTimeZone *)timeZone;

- (void)setURLEscapingCharsetWithNSString:(NSString *)urlEscapingCharset;

/**
 @brief Sets a variable in the current namespace.
 This is correspondent to FTL <code>&lt;#assign <i>name</i>=<i>model</i>&gt;</code>. This can be considered a convenient shorthand for: getCurrentNamespace().put(name, model)
 */
- (void)setVariableWithNSString:(NSString *)name
withFreemarkerTemplateTemplateModel:(id<FreemarkerTemplateTemplateModel>)model;

/**
 @brief Resolves a reference to a template (like the one used in <code>#include</code> or <code>#import</code> ), assuming a base name.
 This gives a full (that is, absolute), even if non-normalized template name, that could be used for Configuration#getTemplate(String) . This is mostly used when a template refers to another template.
 @param baseName The name to which relative <code>targetName</code> -s are relative to. Maybe <code>null</code> , which usually means that the base is the root "directory". Assuming TemplateNameFormat#DEFAULT_2_3_0 or TemplateNameFormat#DEFAULT_2_4_0 , the rules are as follows. If you want to specify a base directory here, it must end with <code>"/"</code> . If it doesn't end with <code>"/"</code> , it's parent directory will be used as the base path. Might starts with a scheme part (like <code>"foo://"</code> , or with TemplateNameFormat#DEFAULT_2_4_0 even just <code>"foo:"</code> ).
 @param targetName The name of the template, which is either a relative or absolute name. Assuming TemplateNameFormat#DEFAULT_2_3_0 or TemplateNameFormat#DEFAULT_2_4_0 , the rules are as follows. If it starts with <code>"/"</code> or contains a scheme part separator ( <code>"://"</code> , also, with TemplateNameFormat#DEFAULT_2_4_0 a <code>":"</code> with no <code>"/"</code> anywhere before it) then it's an absolute name, otherwise it's a relative path. Relative paths are interpreted relatively to the <code>baseName</code> . Absolute names are simply returned as is, ignoring the <code>baseName</code> , except, when the <code>baseName</code> has scheme part while the <code>targetName</code> doesn't have, then the schema of the <code>baseName</code> is prepended to the <code>targetName</code> .
 @since 2.3.22
 */
- (NSString *)toFullTemplateNameWithNSString:(NSString *)baseName
                                withNSString:(NSString *)targetName;

- (void)visitWithFreemarkerCoreTemplateElement:(FreemarkerCoreTemplateElement *)element
  withFreemarkerTemplateTemplateDirectiveModel:(id<FreemarkerTemplateTemplateDirectiveModel>)directiveModel
                               withJavaUtilMap:(id<JavaUtilMap>)args
                              withJavaUtilList:(id<JavaUtilList>)bodyParameterNames;

#pragma mark Package-Private

+ (void)appendInstructionStackItemWithFreemarkerCoreTemplateElement:(FreemarkerCoreTemplateElement *)stackEl
                                           withJavaLangStringBuffer:(JavaLangStringBuffer *)sb;

- (void)clearLastReturnValue;

- (void)fallback;

- (NSString *)formatDateWithFreemarkerTemplateTemplateDateModel:(id<FreemarkerTemplateTemplateDateModel>)tdm
                                   withFreemarkerCoreExpression:(FreemarkerCoreExpression *)tdmSourceExpr;

- (NSString *)formatDateWithFreemarkerTemplateTemplateDateModel:(id<FreemarkerTemplateTemplateDateModel>)tdm
                                                   withNSString:(NSString *)formatDescriptor
                                   withFreemarkerCoreExpression:(FreemarkerCoreExpression *)tdmSourceExpr;

- (NSString *)formatNumberWithNSNumber:(NSNumber *)number;

- (JavaTextCollator *)getCollator;

- (FreemarkerCoreMacro_Context *)getCurrentMacroContext;

- (NSString *)getCurrentRecoveredErrorMessage;

/**
 @brief Returns the name of the charset that should be used for URL encoding.
 This will be <code>null</code> if the information is not available. The function caches the return value, so it's quick to call it repeately.
 */
- (NSString *)getEffectiveURLEscapingCharset;

/**
 @brief See #setFastInvalidReferenceExceptions(boolean) .
 */
- (jboolean)getFastInvalidReferenceExceptions;

/**
 @brief Returns the snapshot of what would be printed as FTL stack trace.
 @since 2.3.20
 */
- (IOSObjectArray *)getInstructionStackSnapshot;

/**
 @brief Returns the DateToISO8601CalendarFactory used by the the "iso_" built-ins.
 Be careful when using this; it should only by used with DateUtil#dateToISO8601String(Date,boolean,boolean,boolean,int,TimeZone,DateToISO8601CalendarFactory) and DateUtil#dateToXSString(Date,boolean,boolean,boolean,int,TimeZone,DateToISO8601CalendarFactory) .
 */
- (id<FreemarkerTemplateUtilityDateUtil_DateToISO8601CalendarFactory>)getISOBuiltInCalendarFactory;

- (id<FreemarkerTemplateTemplateModel>)getLastReturnValue;

- (JavaUtilArrayList *)getLocalContextStack;

- (FreemarkerCoreEnvironment_Namespace *)getMacroNamespaceWithFreemarkerCoreMacro:(FreemarkerCoreMacro *)macro;

- (id<FreemarkerTemplateTemplateModel>)getNodeProcessorWithFreemarkerTemplateTemplateNodeModel:(id<FreemarkerTemplateTemplateNodeModel>)node;

- (JavaTextNumberFormat *)getNumberFormatObjectWithNSString:(NSString *)pattern;

/**
 @brief Returns the same value as pre-IcI 2.3.22 getTemplate() did.
 */
- (FreemarkerTemplateTemplate *)getTemplate230;

/**
 @param dateType The FTL date type, one of TemplateDateModel#DATETIME , TemplateDateModel#TIME and TemplateDateModel#DATE .
 @param dateClass The exact Java class of the formatted or created (via parsing) object. This matters because the time zone is part of the returned DateFormat , and if #getSQLDateAndTimeTimeZone() differs from #getTimeZone() then the exact class influences the time zone.
 @param dateSourceExpr Used for better error messages only; may be <code>null</code>
 */
- (FreemarkerCoreTemplateDateFormat *)getTemplateDateFormatWithInt:(jint)dateType
                                                      withIOSClass:(IOSClass *)dateClass
                                      withFreemarkerCoreExpression:(FreemarkerCoreExpression *)dateSourceExpr;

/**
 @param dateType  TemplateDateModel#UNKNOWN is accepted or not depending on the <code>formatDescriptor</code> value. When it isn't, a TemplateModelException will be thrown.
 @param dateClass The exact class of the date object, such as java.sql.Timestamp .
 @param formatDescriptor Like "iso m" or "dd.MM.yyyy HH:mm"
 */
- (FreemarkerCoreTemplateDateFormat *)getTemplateDateFormatWithInt:(jint)dateType
                                                      withIOSClass:(IOSClass *)dateClass
                                                      withNSString:(NSString *)formatDescriptor
                                      withFreemarkerCoreExpression:(FreemarkerCoreExpression *)dateSourceExpr;

- (id<FreemarkerTemplateTemplateTransformModel>)getTransformWithFreemarkerCoreExpression:(FreemarkerCoreExpression *)exp;

- (void)importMacrosWithFreemarkerTemplateTemplate:(FreemarkerTemplateTemplate *)template_;

+ (NSString *)instructionStackItemToStringWithFreemarkerCoreTemplateElement:(FreemarkerCoreTemplateElement *)stackEl;

/**
 @brief Calls the macro or function with the given arguments and nested block.
 */
- (void)invokeWithFreemarkerCoreMacro:(FreemarkerCoreMacro *)macro
                      withJavaUtilMap:(id<JavaUtilMap>)namedArgs
                     withJavaUtilList:(id<JavaUtilList>)positionalArgs
                     withJavaUtilList:(id<JavaUtilList>)bodyParameterNames
    withFreemarkerCoreTemplateElement:(FreemarkerCoreTemplateElement *)nestedBlock;

/**
 @brief Used for <code>#nested</code> .
 */
- (void)invokeNestedContentWithFreemarkerCoreBodyInstruction_Context:(FreemarkerCoreBodyInstruction_Context *)bodyCtx;

/**
 @brief Used for <code>#visit</code> and <code>#recurse</code> .
 */
- (void)invokeNodeHandlerForWithFreemarkerTemplateTemplateNodeModel:(id<FreemarkerTemplateTemplateNodeModel>)node
                        withFreemarkerTemplateTemplateSequenceModel:(id<FreemarkerTemplateTemplateSequenceModel>)namespaces;

/**
 @brief Tells if the same concrete time zone is used for SQL date-only and time-only values as for other date/time/date-time values.
 */
- (jboolean)isSQLDateAndTimeTimeZoneSameAsNormal;

/**
 @brief Prints an FTL stack trace based on a stack trace snapshot.
 @param w If it's a PrintWriter , PrintWriter#println() will be used for line-breaks.
 @since 2.3.21
 */
+ (void)outputInstructionStackWithFreemarkerCoreTemplateElementArray:(IOSObjectArray *)instructionStackSnapshot
                                                         withBoolean:(jboolean)terseMode
                                                    withJavaIoWriter:(JavaIoWriter *)w;

- (void)recurseWithFreemarkerTemplateTemplateNodeModel:(id<FreemarkerTemplateTemplateNodeModel>)node
           withFreemarkerTemplateTemplateSequenceModel:(id<FreemarkerTemplateTemplateSequenceModel>)namespaces;

- (NSString *)renderElementToStringWithFreemarkerCoreTemplateElement:(FreemarkerCoreTemplateElement *)te;

- (void)replaceElementStackTopWithFreemarkerCoreTemplateElement:(FreemarkerCoreTemplateElement *)instr;

+ (void)setCurrentEnvironmentWithFreemarkerCoreEnvironment:(FreemarkerCoreEnvironment *)env;

/**
 @brief Sets if for invalid references InvalidReferenceException#FAST_INSTANCE should be thrown, or a new InvalidReferenceException .
 The "fast" instance is used if we know that the error will be handled so that its message will not be logged or shown anywhere.
 */
- (jboolean)setFastInvalidReferenceExceptionsWithBoolean:(jboolean)b;

- (void)setLastReturnValueWithFreemarkerTemplateTemplateModel:(id<FreemarkerTemplateTemplateModel>)lastReturnValue;

- (jboolean)shouldUseSQLDTTZWithIOSClass:(IOSClass *)dateClass;

/**
 @brief "Visit" the template element.
 */
- (void)visitWithFreemarkerCoreTemplateElement:(FreemarkerCoreTemplateElement *)element;

/**
 @brief "Visit" the template element, passing the output through a TemplateTransformModel
 @param element the element to visit through a transform
 @param transform the transform to pass the element output through
 @param args optional arguments fed to the transform
 */
- (void)visitAndTransformWithFreemarkerCoreTemplateElement:(FreemarkerCoreTemplateElement *)element
              withFreemarkerTemplateTemplateTransformModel:(id<FreemarkerTemplateTemplateTransformModel>)transform
                                           withJavaUtilMap:(id<JavaUtilMap>)args;

/**
 @brief Visit a block using buffering/recovery
 */
- (void)visitAttemptRecoverWithFreemarkerCoreTemplateElement:(FreemarkerCoreTemplateElement *)attemptBlock
                             withFreemarkerCoreRecoveryBlock:(FreemarkerCoreRecoveryBlock *)recoveryBlock;

/**
 @brief Instead of pushing into the element stack, we replace the top element for the time the parameter element is visited, and then we restore the top element.
 The main purpose of this is to get rid of elements in the error stack trace that from user perspective shouldn't have a stack frame. The typical example is <code>[#if foo]...[@@failsHere/]...[/#if]</code> , where the #if call shouldn't be in the stack trace. (Simply marking #if as hidden in stack traces would be wrong, because we still want to show #if when its test expression fails.)
 */
- (void)visitByHiddingParentWithFreemarkerCoreTemplateElement:(FreemarkerCoreTemplateElement *)element;

/**
 @brief "visit" an IteratorBlock
 */
- (jboolean)visitIteratorBlockWithFreemarkerCoreIteratorBlock_IterationContext:(FreemarkerCoreIteratorBlock_IterationContext *)ictxt;

/**
 @brief Defines the given macro in the current namespace (doesn't call it).
 */
- (void)visitMacroDefWithFreemarkerCoreMacro:(FreemarkerCoreMacro *)macro;

@end

J2OBJC_STATIC_INIT(FreemarkerCoreEnvironment)

FOUNDATION_EXPORT FreemarkerCoreEnvironment *FreemarkerCoreEnvironment_getCurrentEnvironment();

FOUNDATION_EXPORT void FreemarkerCoreEnvironment_setCurrentEnvironmentWithFreemarkerCoreEnvironment_(FreemarkerCoreEnvironment *env);

FOUNDATION_EXPORT void FreemarkerCoreEnvironment_initWithFreemarkerTemplateTemplate_withFreemarkerTemplateTemplateHashModel_withJavaIoWriter_(FreemarkerCoreEnvironment *self, FreemarkerTemplateTemplate *template_, id<FreemarkerTemplateTemplateHashModel> rootDataModel, JavaIoWriter *outArg);

FOUNDATION_EXPORT FreemarkerCoreEnvironment *new_FreemarkerCoreEnvironment_initWithFreemarkerTemplateTemplate_withFreemarkerTemplateTemplateHashModel_withJavaIoWriter_(FreemarkerTemplateTemplate *template_, id<FreemarkerTemplateTemplateHashModel> rootDataModel, JavaIoWriter *outArg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerCoreEnvironment_outputInstructionStackWithFreemarkerCoreTemplateElementArray_withBoolean_withJavaIoWriter_(IOSObjectArray *instructionStackSnapshot, jboolean terseMode, JavaIoWriter *w);

FOUNDATION_EXPORT NSString *FreemarkerCoreEnvironment_instructionStackItemToStringWithFreemarkerCoreTemplateElement_(FreemarkerCoreTemplateElement *stackEl);

FOUNDATION_EXPORT void FreemarkerCoreEnvironment_appendInstructionStackItemWithFreemarkerCoreTemplateElement_withJavaLangStringBuffer_(FreemarkerCoreTemplateElement *stackEl, JavaLangStringBuffer *sb);

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerCoreEnvironment)

@interface FreemarkerCoreEnvironment_NestedElementTemplateDirectiveBody : NSObject < FreemarkerTemplateTemplateDirectiveBody >

#pragma mark Public

- (FreemarkerCoreTemplateElement *)getElement;

- (void)renderWithJavaIoWriter:(JavaIoWriter *)newOut;

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerCoreEnvironment_NestedElementTemplateDirectiveBody)

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerCoreEnvironment_NestedElementTemplateDirectiveBody)

@interface FreemarkerCoreEnvironment_Namespace : FreemarkerTemplateSimpleHash

#pragma mark Public

/**
 @return the Template object with which this Namespace is associated.
 */
- (FreemarkerTemplateTemplate *)getTemplate;

#pragma mark Package-Private

- (instancetype)initWithFreemarkerCoreEnvironment:(FreemarkerCoreEnvironment *)outer$;

- (instancetype)initWithFreemarkerCoreEnvironment:(FreemarkerCoreEnvironment *)outer$
                   withFreemarkerTemplateTemplate:(FreemarkerTemplateTemplate *)template_;

@end

J2OBJC_EMPTY_STATIC_INIT(FreemarkerCoreEnvironment_Namespace)

FOUNDATION_EXPORT void FreemarkerCoreEnvironment_Namespace_initWithFreemarkerCoreEnvironment_(FreemarkerCoreEnvironment_Namespace *self, FreemarkerCoreEnvironment *outer$);

FOUNDATION_EXPORT FreemarkerCoreEnvironment_Namespace *new_FreemarkerCoreEnvironment_Namespace_initWithFreemarkerCoreEnvironment_(FreemarkerCoreEnvironment *outer$) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void FreemarkerCoreEnvironment_Namespace_initWithFreemarkerCoreEnvironment_withFreemarkerTemplateTemplate_(FreemarkerCoreEnvironment_Namespace *self, FreemarkerCoreEnvironment *outer$, FreemarkerTemplateTemplate *template_);

FOUNDATION_EXPORT FreemarkerCoreEnvironment_Namespace *new_FreemarkerCoreEnvironment_Namespace_initWithFreemarkerCoreEnvironment_withFreemarkerTemplateTemplate_(FreemarkerCoreEnvironment *outer$, FreemarkerTemplateTemplate *template_) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(FreemarkerCoreEnvironment_Namespace)

#endif // _FreemarkerCoreEnvironment_H_
