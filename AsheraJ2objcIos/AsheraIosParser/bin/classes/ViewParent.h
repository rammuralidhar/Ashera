//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ramm/git/Ashera/AsheraAndroidParser/androidlayouts/repackaged/android/view/ViewParent.java
//

#ifndef _RepackagedAndroidViewViewParent_H_
#define _RepackagedAndroidViewViewParent_H_

#include "J2ObjC_header.h"

@class IOSIntArray;
@class RepackagedAndroidGraphicsPoint;
@class RepackagedAndroidGraphicsRect;
@class RepackagedAndroidOsBundle;
@class RepackagedAndroidViewAccessibilityAccessibilityEvent;
@class RepackagedAndroidViewActionMode;
@class RepackagedAndroidViewContextMenu;
@class RepackagedAndroidViewView;
@protocol RepackagedAndroidViewActionMode_Callback;

/**
 @brief Defines the responsibilities for a class that will be a parent of a View.
 This is the API that a view sees when it wants to interact with its parent.
 */
@protocol RepackagedAndroidViewViewParent < NSObject, JavaObject >

/**
 @brief Called when something has changed which has invalidated the layout of a child of this view parent.
 This will schedule a layout pass of the view tree.
 */
- (void)requestLayout;

/**
 @brief Indicates whether layout was requested on this view parent.
 @return true if layout was requested, false otherwise
 */
- (jboolean)isLayoutRequested;

/**
 @brief Called when a child wants the view hierarchy to gather and report transparent regions to the window compositor.
 Views that "punch" holes in the view hierarchy, such as SurfaceView can use this API to improve performance of the system. When no such a view is present in the hierarchy, this optimization in unnecessary and might slightly reduce the view hierarchy performance.
 @param child the view requesting the transparent region computation
 */
- (void)requestTransparentRegionWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)child;

/**
 @brief All or part of a child is dirty and needs to be redrawn.
 @param child The child which is dirty
 @param r The area within the child that is invalid
 */
- (void)invalidateChildWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)child
                   withRepackagedAndroidGraphicsRect:(RepackagedAndroidGraphicsRect *)r;

/**
 @brief All or part of a child is dirty and needs to be redrawn.
 <p>The location array is an array of two int values which respectively define the left and the top position of the dirty child.</p> <p>This method must return the parent of this ViewParent if the specified rectangle must be invalidated in the parent. If the specified rectangle does not require invalidation in the parent or if the parent does not exist, this method must return null.</p> <p>When this method returns a non-null value, the location array must have been updated with the left and top coordinates of this ViewParent.</p>
 @param location An array of 2 ints containing the left and top coordinates of the child to invalidate
 @param r The area within the child that is invalid
 @return the parent of this ViewParent or null
 */
- (id<RepackagedAndroidViewViewParent>)invalidateChildInParentWithIntArray:(IOSIntArray *)location
                                         withRepackagedAndroidGraphicsRect:(RepackagedAndroidGraphicsRect *)r;

/**
 @brief Returns the parent if it exists, or null.
 @return a ViewParent or null if this ViewParent does not have a parent
 */
- (id<RepackagedAndroidViewViewParent>)getParent;

/**
 @brief Called when a child of this parent wants focus
 @param child The child of this ViewParent that wants focus. This view will contain the focused view. It is not necessarily the view that actually has focus.
 @param focused The view that is a descendant of child that actually has focus
 */
- (void)requestChildFocusWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)child
                         withRepackagedAndroidViewView:(RepackagedAndroidViewView *)focused;

/**
 @brief Tell view hierarchy that the global view attributes need to be re-evaluated.
 @param child View whose attributes have changed.
 */
- (void)recomputeViewAttributesWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)child;

/**
 @brief Called when a child of this parent is giving up focus
 @param child The view that is giving up focus
 */
- (void)clearChildFocusWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)child;

/**
 @brief Compute the visible part of a rectangular region defined in terms of a child view's coordinates.
 <p>Returns the clipped visible part of the rectangle <code>r</code>, defined in the <code>child</code>'s local coordinate system. <code>r</code> is modified by this method to contain the result, expressed in the global (root) coordinate system.</p> <p>The resulting rectangle is always axis aligned. If a rotation is applied to a node in the View hierarchy, the result is the axis-aligned bounding box of the visible rectangle.</p>
 @param child A child View, whose rectangular visible region we want to compute
 @param r The input rectangle, defined in the child coordinate system. Will be overwritten to contain the resulting visible rectangle, expressed in global (root) coordinates
 @param offset The input coordinates of a point, defined in the child coordinate system. As with the <code>r</code> parameter, this will be overwritten to contain the global (root) coordinates of that point. A <code>null</code> value is valid (in case you are not interested in this result)
 @return true if the resulting rectangle is not empty, false otherwise
 */
- (jboolean)getChildVisibleRectWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)child
                           withRepackagedAndroidGraphicsRect:(RepackagedAndroidGraphicsRect *)r
                          withRepackagedAndroidGraphicsPoint:(RepackagedAndroidGraphicsPoint *)offset;

/**
 @brief Find the nearest view in the specified direction that wants to take focus
 @param v The view that currently has focus
 @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
 */
- (RepackagedAndroidViewView *)focusSearchWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)v
                                                                withInt:(jint)direction;

/**
 @brief Change the z order of the child so it's on top of all other children.
 This ordering change may affect layout, if this container uses an order-dependent layout scheme (e.g., LinearLayout). Prior to repackaged.android.os.Build.VERSION_CODES#KITKAT this method should be followed by calls to #requestLayout() and View#invalidate() on this parent to force the parent to redraw with the new child ordering.
 @param child The child to bring to the top of the z order
 */
- (void)bringChildToFrontWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)child;

/**
 @brief Tells the parent that a new focusable view has become available.
 This is to handle transitions from the case where there are no focusable views to the case where the first focusable view appears.
 @param v The view that has become newly focusable
 */
- (void)focusableViewAvailableWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)v;

/**
 @brief Bring up a context menu for the specified view or its ancestors.
 <p>In most cases, a subclass does not need to override this.  However, if the subclass is added directly to the window manager (for example, ViewManager#addView(View,repackaged.android.view.ViewGroup.LayoutParams) ) then it should override this and show the context menu.</p>
 @param originalView The source view where the context menu was first invoked
 @return true if a context menu was displayed
 */
- (jboolean)showContextMenuForChildWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)originalView;

/**
 @brief Have the parent populate the specified context menu if it has anything to add (and then recurse on its parent).
 @param menu The menu to populate
 */
- (void)createContextMenuWithRepackagedAndroidViewContextMenu:(RepackagedAndroidViewContextMenu *)menu;

/**
 @brief Start an action mode for the specified view with the default type ActionMode#TYPE_PRIMARY .
 <p>In most cases, a subclass does not need to override this. However, if the subclass is added directly to the window manager (for example, ViewManager#addView(View,repackaged.android.view.ViewGroup.LayoutParams) ) then it should override this and start the action mode.</p>
 @param originalView The source view where the action mode was first invoked
 @param callback The callback that will handle lifecycle events for the action mode
 @return The new action mode if it was started, null otherwise
 */
- (RepackagedAndroidViewActionMode *)startActionModeForChildWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)originalView
                                             withRepackagedAndroidViewActionMode_Callback:(id<RepackagedAndroidViewActionMode_Callback>)callback;

/**
 @brief Start an action mode of a specific type for the specified view.
 <p>In most cases, a subclass does not need to override this. However, if the subclass is added directly to the window manager (for example, ViewManager#addView(View,repackaged.android.view.ViewGroup.LayoutParams) ) then it should override this and start the action mode.</p>
 @param originalView The source view where the action mode was first invoked
 @param callback The callback that will handle lifecycle events for the action mode
 @param type One of ActionMode#TYPE_PRIMARY or ActionMode#TYPE_FLOATING .
 @return The new action mode if it was started, null otherwise
 */
- (RepackagedAndroidViewActionMode *)startActionModeForChildWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)originalView
                                             withRepackagedAndroidViewActionMode_Callback:(id<RepackagedAndroidViewActionMode_Callback>)callback
                                                                                  withInt:(jint)type;

/**
 @brief This method is called on the parent when a child's drawable state has changed.
 @param child The child whose drawable state has changed.
 */
- (void)childDrawableStateChangedWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)child;

/**
 @brief Called when a child does not want this parent and its ancestors to intercept touch events with ViewGroup#onInterceptTouchEvent(MotionEvent) .
 <p>This parent should pass this call onto its parents. This parent must obey this request for the duration of the touch (that is, only clear the flag after this parent has received an up or a cancel.</p>
 @param disallowIntercept True if the child does not want the parent to intercept touch events.
 */
- (void)requestDisallowInterceptTouchEventWithBoolean:(jboolean)disallowIntercept;

/**
 @brief Called when a child of this group wants a particular rectangle to be positioned onto the screen.
 ViewGroup s overriding this can trust that: <ul> <li>child will be a direct child of this group</li> <li>rectangle will be in the child's coordinates</li> </ul> <p> ViewGroup s overriding this should uphold the contract:</p> <ul> <li>nothing will change if the rectangle is already visible</li> <li>the view port will be scrolled only just enough to make the rectangle visible</li> <ul>
 @param child The direct child making the request.
 @param rectangle The rectangle in the child's coordinates the child wishes to be on the screen.
 @param immediate True to forbid animated or delayed scrolling, false otherwise
 @return Whether the group scrolled to handle the operation
 */
- (jboolean)requestChildRectangleOnScreenWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)child
                                     withRepackagedAndroidGraphicsRect:(RepackagedAndroidGraphicsRect *)rectangle
                                                           withBoolean:(jboolean)immediate;

/**
 @brief Called by a child to request from its parent to send an AccessibilityEvent .
 The child has already populated a record for itself in the event and is delegating to its parent to send the event. The parent can optionally add a record for itself. <p> Note: An accessibility event is fired by an individual view which populates the event with a record for its state and requests from its parent to perform the sending. The parent can optionally add a record for itself before dispatching the request to its parent. A parent can also choose not to respect the request for sending the event. The accessibility event is sent by the topmost view in the view tree.</p>
 @param child The child which requests sending the event.
 @param event The event to be sent.
 @return True if the event was sent.
 */
- (jboolean)requestSendAccessibilityEventWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)child
              withRepackagedAndroidViewAccessibilityAccessibilityEvent:(RepackagedAndroidViewAccessibilityAccessibilityEvent *)event;

/**
 @brief Called when a child view now has or no longer is tracking transient state.
 <p>"Transient state" is any state that a View might hold that is not expected to be reflected in the data model that the View currently presents. This state only affects the presentation to the user within the View itself, such as the current state of animations in progress or the state of a text selection operation.</p> <p>Transient state is useful for hinting to other components of the View system that a particular view is tracking something complex but encapsulated. A <code>ListView</code> for example may acknowledge that list item Views with transient state should be preserved within their position or stable item ID instead of treating that view as trivially replaceable by the backing adapter. This allows adapter implementations to be simpler instead of needing to track the state of item view animations in progress such that they could be restored in the event of an unexpected recycling and rebinding of attached item views.</p> <p>This method is called on a parent view when a child view or a view within its subtree begins or ends tracking of internal transient state.</p>
 @param child Child view whose state has changed
 @param hasTransientState true if this child has transient state
 */
- (void)childHasTransientStateChangedWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)child
                                                       withBoolean:(jboolean)hasTransientState;

/**
 @brief Ask that a new dispatch of View#fitSystemWindows(Rect) View.fitSystemWindows(Rect) be performed.
 */
- (void)requestFitSystemWindows;

/**
 @brief Gets the parent of a given View for accessibility.
 Since some Views are not exposed to the accessibility layer the parent for accessibility is not necessarily the direct parent of the View, rather it is a predecessor.
 @return The parent or <code>null</code> if no such is found.
 */
- (id<RepackagedAndroidViewViewParent>)getParentForAccessibility;

/**
 @brief Notifies a view parent that the accessibility state of one of its descendants has changed and that the structure of the subtree is different.
 @param child The direct child whose subtree has changed.
 @param source The descendant view that changed.
 @param changeType A bit mask of the types of changes that occurred. One or more of: <ul> <li> AccessibilityEvent#CONTENT_CHANGE_TYPE_CONTENT_DESCRIPTION <li> AccessibilityEvent#CONTENT_CHANGE_TYPE_SUBTREE <li> AccessibilityEvent#CONTENT_CHANGE_TYPE_TEXT <li> AccessibilityEvent#CONTENT_CHANGE_TYPE_UNDEFINED </ul>
 */
- (void)notifySubtreeAccessibilityStateChangedWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)child
                                              withRepackagedAndroidViewView:(RepackagedAndroidViewView *)source
                                                                    withInt:(jint)changeType;

/**
 @brief Tells if this view parent can resolve the layout direction.
 See View#setLayoutDirection(int)
 @return True if this view parent can resolve the layout direction.
 */
- (jboolean)canResolveLayoutDirection;

/**
 @brief Tells if this view parent layout direction is resolved.
 See View#setLayoutDirection(int)
 @return True if this view parent layout direction is resolved.
 */
- (jboolean)isLayoutDirectionResolved;

/**
 @brief Return this view parent layout direction.
 See View#getLayoutDirection()
 @return View#LAYOUT_DIRECTION_RTL if the layout direction is RTL or returns View#LAYOUT_DIRECTION_LTR if the layout direction is not RTL.
 */
- (jint)getLayoutDirection;

/**
 @brief Tells if this view parent can resolve the text direction.
 See View#setTextDirection(int)
 @return True if this view parent can resolve the text direction.
 */
- (jboolean)canResolveTextDirection;

/**
 @brief Tells if this view parent text direction is resolved.
 See View#setTextDirection(int)
 @return True if this view parent text direction is resolved.
 */
- (jboolean)isTextDirectionResolved;

/**
 @brief Return this view parent text direction.
 See View#getTextDirection()
 @return the resolved text direction. Returns one of: View#TEXT_DIRECTION_FIRST_STRONG View#TEXT_DIRECTION_ANY_RTL , View#TEXT_DIRECTION_LTR , View#TEXT_DIRECTION_RTL , View#TEXT_DIRECTION_LOCALE
 */
- (jint)getTextDirection;

/**
 @brief Tells if this view parent can resolve the text alignment.
 See View#setTextAlignment(int)
 @return True if this view parent can resolve the text alignment.
 */
- (jboolean)canResolveTextAlignment;

/**
 @brief Tells if this view parent text alignment is resolved.
 See View#setTextAlignment(int)
 @return True if this view parent text alignment is resolved.
 */
- (jboolean)isTextAlignmentResolved;

/**
 @brief Return this view parent text alignment.
 See repackaged.android.view.View#getTextAlignment()
 @return the resolved text alignment. Returns one of: View#TEXT_ALIGNMENT_GRAVITY , View#TEXT_ALIGNMENT_CENTER , View#TEXT_ALIGNMENT_TEXT_START , View#TEXT_ALIGNMENT_TEXT_END , View#TEXT_ALIGNMENT_VIEW_START , View#TEXT_ALIGNMENT_VIEW_END
 */
- (jint)getTextAlignment;

/**
 @brief React to a descendant view initiating a nestable scroll operation, claiming the nested scroll operation if appropriate.
 <p>This method will be called in response to a descendant view invoking View#startNestedScroll(int) . Each parent up the view hierarchy will be given an opportunity to respond and claim the nested scrolling operation by returning <code>true</code>.</p> <p>This method may be overridden by ViewParent implementations to indicate when the view is willing to support a nested scrolling operation that is about to begin. If it returns true, this ViewParent will become the target view's nested scrolling parent for the duration of the scroll operation in progress. When the nested scroll is finished this ViewParent will receive a call to #onStopNestedScroll(View) . </p>
 @param child Direct child of this ViewParent containing target
 @param target View that initiated the nested scroll
 @param nestedScrollAxes Flags consisting of View#SCROLL_AXIS_HORIZONTAL , View#SCROLL_AXIS_VERTICAL or both
 @return true if this ViewParent accepts the nested scroll operation
 */
- (jboolean)onStartNestedScrollWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)child
                               withRepackagedAndroidViewView:(RepackagedAndroidViewView *)target
                                                     withInt:(jint)nestedScrollAxes;

/**
 @brief React to the successful claiming of a nested scroll operation.
 <p>This method will be called after #onStartNestedScroll(View,View,int) onStartNestedScroll returns true. It offers an opportunity for the view and its superclasses to perform initial configuration for the nested scroll. Implementations of this method should always call their superclass's implementation of this method if one is present.</p>
 @param child Direct child of this ViewParent containing target
 @param target View that initiated the nested scroll
 @param nestedScrollAxes Flags consisting of View#SCROLL_AXIS_HORIZONTAL , View#SCROLL_AXIS_VERTICAL or both
 */
- (void)onNestedScrollAcceptedWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)child
                              withRepackagedAndroidViewView:(RepackagedAndroidViewView *)target
                                                    withInt:(jint)nestedScrollAxes;

/**
 @brief React to a nested scroll operation ending.
 <p>Perform cleanup after a nested scrolling operation. This method will be called when a nested scroll stops, for example when a nested touch scroll ends with a MotionEvent#ACTION_UP or MotionEvent#ACTION_CANCEL event. Implementations of this method should always call their superclass's implementation of this method if one is present.</p>
 @param target View that initiated the nested scroll
 */
- (void)onStopNestedScrollWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)target;

/**
 @brief React to a nested scroll in progress.
 <p>This method will be called when the ViewParent's current nested scrolling child view dispatches a nested scroll event. To receive calls to this method the ViewParent must have previously returned <code>true</code> for a call to #onStartNestedScroll(View,View,int) .</p> <p>Both the consumed and unconsumed portions of the scroll distance are reported to the ViewParent. An implementation may choose to use the consumed portion to match or chase scroll position of multiple child elements, for example. The unconsumed portion may be used to allow continuous dragging of multiple scrolling or draggable elements, such as scrolling a list within a vertical drawer where the drawer begins dragging once the edge of inner scrolling content is reached.</p>
 @param target The descendent view controlling the nested scroll
 @param dxConsumed Horizontal scroll distance in pixels already consumed by target
 @param dyConsumed Vertical scroll distance in pixels already consumed by target
 @param dxUnconsumed Horizontal scroll distance in pixels not consumed by target
 @param dyUnconsumed Vertical scroll distance in pixels not consumed by target
 */
- (void)onNestedScrollWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)target
                                            withInt:(jint)dxConsumed
                                            withInt:(jint)dyConsumed
                                            withInt:(jint)dxUnconsumed
                                            withInt:(jint)dyUnconsumed;

/**
 @brief React to a nested scroll in progress before the target view consumes a portion of the scroll.
 <p>When working with nested scrolling often the parent view may want an opportunity to consume the scroll before the nested scrolling child does. An example of this is a drawer that contains a scrollable list. The user will want to be able to scroll the list fully into view before the list itself begins scrolling.</p> <p><code>onNestedPreScroll</code> is called when a nested scrolling child invokes View#dispatchNestedPreScroll(int,int,int[],int[]) . The implementation should report how any pixels of the scroll reported by dx, dy were consumed in the <code>consumed</code> array. Index 0 corresponds to dx and index 1 corresponds to dy. This parameter will never be null. Initial values for consumed[0] and consumed[1] will always be 0.</p>
 @param target View that initiated the nested scroll
 @param dx Horizontal scroll distance in pixels
 @param dy Vertical scroll distance in pixels
 @param consumed Output. The horizontal and vertical scroll distance consumed by this parent
 */
- (void)onNestedPreScrollWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)target
                                               withInt:(jint)dx
                                               withInt:(jint)dy
                                          withIntArray:(IOSIntArray *)consumed;

/**
 @brief Request a fling from a nested scroll.
 <p>This method signifies that a nested scrolling child has detected suitable conditions for a fling. Generally this means that a touch scroll has ended with a VelocityTracker velocity in the direction of scrolling that meets or exceeds the ViewConfiguration#getScaledMinimumFlingVelocity() minimum fling velocity along a scrollable axis.</p> <p>If a nested scrolling child view would normally fling but it is at the edge of its own content, it can use this method to delegate the fling to its nested scrolling parent instead. The parent may optionally consume the fling or observe a child fling.</p>
 @param target View that initiated the nested scroll
 @param velocityX Horizontal velocity in pixels per second
 @param velocityY Vertical velocity in pixels per second
 @param consumed true if the child consumed the fling, false otherwise
 @return true if this parent consumed or otherwise reacted to the fling
 */
- (jboolean)onNestedFlingWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)target
                                             withFloat:(jfloat)velocityX
                                             withFloat:(jfloat)velocityY
                                           withBoolean:(jboolean)consumed;

/**
 @brief React to a nested fling before the target view consumes it.
 <p>This method siginfies that a nested scrolling child has detected a fling with the given velocity along each axis. Generally this means that a touch scroll has ended with a VelocityTracker velocity in the direction of scrolling that meets or exceeds the ViewConfiguration#getScaledMinimumFlingVelocity() minimum fling velocity along a scrollable axis.</p> <p>If a nested scrolling parent is consuming motion as part of a #onNestedPreScroll(View,int,int,int[]) pre-scroll , it may be appropriate for it to also consume the pre-fling to complete that same motion. By returning <code>true</code> from this method, the parent indicates that the child should not fling its own internal content as well.</p>
 @param target View that initiated the nested scroll
 @param velocityX Horizontal velocity in pixels per second
 @param velocityY Vertical velocity in pixels per second
 @return true if this parent consumed the fling ahead of the target view
 */
- (jboolean)onNestedPreFlingWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)target
                                                withFloat:(jfloat)velocityX
                                                withFloat:(jfloat)velocityY;

/**
 @brief React to an accessibility action delegated by a target descendant view before the target processes it.
 <p>This method may be called by a target descendant view if the target wishes to give a view in its parent chain a chance to react to the event before normal processing occurs. Most commonly this will be a scroll event such as repackaged.android.view.accessibility.AccessibilityNodeInfo#ACTION_SCROLL_FORWARD . A ViewParent that supports acting as a nested scrolling parent should override this method and act accordingly to implement scrolling via accesibility systems.</p>
 @param target The target view dispatching this action
 @param action Action being performed; see repackaged.android.view.accessibility.AccessibilityNodeInfo
 @param arguments Optional action arguments
 @return true if the action was consumed by this ViewParent
 */
- (jboolean)onNestedPrePerformAccessibilityActionWithRepackagedAndroidViewView:(RepackagedAndroidViewView *)target
                                                                       withInt:(jint)action
                                                 withRepackagedAndroidOsBundle:(RepackagedAndroidOsBundle *)arguments;

@end

J2OBJC_EMPTY_STATIC_INIT(RepackagedAndroidViewViewParent)

J2OBJC_TYPE_LITERAL_HEADER(RepackagedAndroidViewViewParent)

#endif // _RepackagedAndroidViewViewParent_H_
