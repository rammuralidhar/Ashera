//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ramm/git/Ashera/AsheraAndroidParser/androidlayouts/repackaged/android/util/Base64.java
//

#ifndef _RepackagedAndroidUtilBase64_H_
#define _RepackagedAndroidUtilBase64_H_

#include "J2ObjC_header.h"

@class IOSByteArray;

#define RepackagedAndroidUtilBase64_DEFAULT 0
#define RepackagedAndroidUtilBase64_NO_PADDING 1
#define RepackagedAndroidUtilBase64_NO_WRAP 2
#define RepackagedAndroidUtilBase64_CRLF 4
#define RepackagedAndroidUtilBase64_URL_SAFE 8
#define RepackagedAndroidUtilBase64_NO_CLOSE 16

/**
 @brief Utilities for encoding and decoding the Base64 representation of binary data.
 See RFCs <a href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
 */
@interface RepackagedAndroidUtilBase64 : NSObject

#pragma mark Public

/**
 @brief Decode the Base64-encoded data in input and return the data in a new byte array.
 <p>The padding '=' characters at the end are considered optional, but if any are present, there must be the correct number of them.
 @param input the input array to decode
 @param flags controls certain features of the decoded output. Pass <code>DEFAULT</code> to decode standard Base64.
 @throws IllegalArgumentException if the input contains incorrect padding
 */
+ (IOSByteArray *)decodeWithByteArray:(IOSByteArray *)input
                              withInt:(jint)flags;

/**
 @brief Decode the Base64-encoded data in input and return the data in a new byte array.
 <p>The padding '=' characters at the end are considered optional, but if any are present, there must be the correct number of them.
 @param input the data to decode
 @param offset the position within the input array at which to start
 @param len the number of bytes of input to decode
 @param flags controls certain features of the decoded output. Pass <code>DEFAULT</code> to decode standard Base64.
 @throws IllegalArgumentException if the input contains incorrect padding
 */
+ (IOSByteArray *)decodeWithByteArray:(IOSByteArray *)input
                              withInt:(jint)offset
                              withInt:(jint)len
                              withInt:(jint)flags;

/**
 @brief Decode the Base64-encoded data in input and return the data in a new byte array.
 <p>The padding '=' characters at the end are considered optional, but if any are present, there must be the correct number of them.
 @param str the input String to decode, which is converted to bytes using the default charset
 @param flags controls certain features of the decoded output. Pass <code>DEFAULT</code> to decode standard Base64.
 @throws IllegalArgumentException if the input contains incorrect padding
 */
+ (IOSByteArray *)decodeWithNSString:(NSString *)str
                             withInt:(jint)flags;

/**
 @brief Base64-encode the given data and return a newly allocated byte[] with the result.
 @param input the data to encode
 @param flags controls certain features of the encoded output. Passing <code>DEFAULT</code> results in output that adheres to RFC 2045.
 */
+ (IOSByteArray *)encodeWithByteArray:(IOSByteArray *)input
                              withInt:(jint)flags;

/**
 @brief Base64-encode the given data and return a newly allocated byte[] with the result.
 @param input the data to encode
 @param offset the position within the input array at which to start
 @param len the number of bytes of input to encode
 @param flags controls certain features of the encoded output. Passing <code>DEFAULT</code> results in output that adheres to RFC 2045.
 */
+ (IOSByteArray *)encodeWithByteArray:(IOSByteArray *)input
                              withInt:(jint)offset
                              withInt:(jint)len
                              withInt:(jint)flags;

/**
 @brief Base64-encode the given data and return a newly allocated String with the result.
 @param input the data to encode
 @param flags controls certain features of the encoded output. Passing <code>DEFAULT</code> results in output that adheres to RFC 2045.
 */
+ (NSString *)encodeToStringWithByteArray:(IOSByteArray *)input
                                  withInt:(jint)flags;

/**
 @brief Base64-encode the given data and return a newly allocated String with the result.
 @param input the data to encode
 @param offset the position within the input array at which to start
 @param len the number of bytes of input to encode
 @param flags controls certain features of the encoded output. Passing <code>DEFAULT</code> results in output that adheres to RFC 2045.
 */
+ (NSString *)encodeToStringWithByteArray:(IOSByteArray *)input
                                  withInt:(jint)offset
                                  withInt:(jint)len
                                  withInt:(jint)flags;

@end

J2OBJC_EMPTY_STATIC_INIT(RepackagedAndroidUtilBase64)

J2OBJC_STATIC_FIELD_GETTER(RepackagedAndroidUtilBase64, DEFAULT, jint)

J2OBJC_STATIC_FIELD_GETTER(RepackagedAndroidUtilBase64, NO_PADDING, jint)

J2OBJC_STATIC_FIELD_GETTER(RepackagedAndroidUtilBase64, NO_WRAP, jint)

J2OBJC_STATIC_FIELD_GETTER(RepackagedAndroidUtilBase64, CRLF, jint)

J2OBJC_STATIC_FIELD_GETTER(RepackagedAndroidUtilBase64, URL_SAFE, jint)

J2OBJC_STATIC_FIELD_GETTER(RepackagedAndroidUtilBase64, NO_CLOSE, jint)

FOUNDATION_EXPORT IOSByteArray *RepackagedAndroidUtilBase64_decodeWithNSString_withInt_(NSString *str, jint flags);

FOUNDATION_EXPORT IOSByteArray *RepackagedAndroidUtilBase64_decodeWithByteArray_withInt_(IOSByteArray *input, jint flags);

FOUNDATION_EXPORT IOSByteArray *RepackagedAndroidUtilBase64_decodeWithByteArray_withInt_withInt_withInt_(IOSByteArray *input, jint offset, jint len, jint flags);

FOUNDATION_EXPORT NSString *RepackagedAndroidUtilBase64_encodeToStringWithByteArray_withInt_(IOSByteArray *input, jint flags);

FOUNDATION_EXPORT NSString *RepackagedAndroidUtilBase64_encodeToStringWithByteArray_withInt_withInt_withInt_(IOSByteArray *input, jint offset, jint len, jint flags);

FOUNDATION_EXPORT IOSByteArray *RepackagedAndroidUtilBase64_encodeWithByteArray_withInt_(IOSByteArray *input, jint flags);

FOUNDATION_EXPORT IOSByteArray *RepackagedAndroidUtilBase64_encodeWithByteArray_withInt_withInt_withInt_(IOSByteArray *input, jint offset, jint len, jint flags);

J2OBJC_TYPE_LITERAL_HEADER(RepackagedAndroidUtilBase64)

@interface RepackagedAndroidUtilBase64_Coder : NSObject {
 @public
  IOSByteArray *output_;
  jint op_;
}

#pragma mark Public

/**
 @return the maximum number of bytes a call to process() could produce for the given number of input bytes.  This may be an overestimate.
 */
- (jint)maxOutputSizeWithInt:(jint)len;

/**
 @brief Encode/decode another block of input data.
 this.output is provided by the caller, and must be big enough to hold all the coded data.  On exit, this.opwill be set to the length of the coded data.
 @param finish true if this is the final call to process for this object.  Will finalize the coder state and include any final bytes in the output.
 @return true if the input so far is good; false if some error has been detected in the input stream..
 */
- (jboolean)processWithByteArray:(IOSByteArray *)input
                         withInt:(jint)offset
                         withInt:(jint)len
                     withBoolean:(jboolean)finish;

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(RepackagedAndroidUtilBase64_Coder)

J2OBJC_FIELD_SETTER(RepackagedAndroidUtilBase64_Coder, output_, IOSByteArray *)

FOUNDATION_EXPORT void RepackagedAndroidUtilBase64_Coder_init(RepackagedAndroidUtilBase64_Coder *self);

J2OBJC_TYPE_LITERAL_HEADER(RepackagedAndroidUtilBase64_Coder)

@interface RepackagedAndroidUtilBase64_Decoder : RepackagedAndroidUtilBase64_Coder

#pragma mark Public

- (instancetype)initWithInt:(jint)flags
              withByteArray:(IOSByteArray *)output;

/**
 @return an overestimate for the number of bytes <code>len</code> bytes could decode to.
 */
- (jint)maxOutputSizeWithInt:(jint)len;

/**
 @brief Decode another block of input data.
 @return true if the state machine is still healthy.  false if bad base-64 data has been detected in the input stream.
 */
- (jboolean)processWithByteArray:(IOSByteArray *)input
                         withInt:(jint)offset
                         withInt:(jint)len
                     withBoolean:(jboolean)finish;

@end

J2OBJC_STATIC_INIT(RepackagedAndroidUtilBase64_Decoder)

FOUNDATION_EXPORT void RepackagedAndroidUtilBase64_Decoder_initWithInt_withByteArray_(RepackagedAndroidUtilBase64_Decoder *self, jint flags, IOSByteArray *output);

FOUNDATION_EXPORT RepackagedAndroidUtilBase64_Decoder *new_RepackagedAndroidUtilBase64_Decoder_initWithInt_withByteArray_(jint flags, IOSByteArray *output) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(RepackagedAndroidUtilBase64_Decoder)

#define RepackagedAndroidUtilBase64_Encoder_LINE_GROUPS 19

@interface RepackagedAndroidUtilBase64_Encoder : RepackagedAndroidUtilBase64_Coder {
 @public
  jint tailLen_;
  jboolean do_padding_;
  jboolean do_newline_;
  jboolean do_cr_;
}

#pragma mark Public

- (instancetype)initWithInt:(jint)flags
              withByteArray:(IOSByteArray *)output;

/**
 @return an overestimate for the number of bytes <code>len</code> bytes could encode to.
 */
- (jint)maxOutputSizeWithInt:(jint)len;

- (jboolean)processWithByteArray:(IOSByteArray *)input
                         withInt:(jint)offset
                         withInt:(jint)len
                     withBoolean:(jboolean)finish;

@end

J2OBJC_STATIC_INIT(RepackagedAndroidUtilBase64_Encoder)

J2OBJC_STATIC_FIELD_GETTER(RepackagedAndroidUtilBase64_Encoder, LINE_GROUPS, jint)

FOUNDATION_EXPORT void RepackagedAndroidUtilBase64_Encoder_initWithInt_withByteArray_(RepackagedAndroidUtilBase64_Encoder *self, jint flags, IOSByteArray *output);

FOUNDATION_EXPORT RepackagedAndroidUtilBase64_Encoder *new_RepackagedAndroidUtilBase64_Encoder_initWithInt_withByteArray_(jint flags, IOSByteArray *output) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(RepackagedAndroidUtilBase64_Encoder)

#endif // _RepackagedAndroidUtilBase64_H_
