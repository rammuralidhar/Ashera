//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/ramm/git/Ashera/AsheraAndroidParser/androidlayouts/repackaged/android/util/ArraySet.java
//

#ifndef _RepackagedAndroidUtilArraySet_H_
#define _RepackagedAndroidUtilArraySet_H_

#include "J2ObjC_header.h"
#include "java/util/Collection.h"
#include "java/util/Set.h"

@class IOSIntArray;
@class IOSObjectArray;
@class RepackagedAndroidUtilMapCollections;
@protocol JavaUtilIterator;

/**
 @brief ArraySet is a generic set data structure that is designed to be more memory efficient than a traditional java.util.HashSet .
 The design is very similar to ArrayMap , with all of the caveats described there.  This implementation is separate from ArrayMap, however, so the Object array contains only one item for each entry in the set (instead of a pair for a mapping). <p>Note that this implementation is not intended to be appropriate for data structures that may contain large numbers of items.  It is generally slower than a traditional HashSet, since lookups require a binary search and adds and removes require inserting and deleting entries in the array.  For containers holding up to hundreds of items, the performance difference is not significant, less than 50%.</p> <p>Because this container is intended to better balance memory use, unlike most other standard Java containers it will shrink its array as items are removed from it.  Currently you have no control over this shrinking -- if you set a capacity and then remove an item, it may reduce the capacity to better match the current size.  In the future an explicit call to set the capacity should turn off this aggressive shrinking behavior.</p>
 */
@interface RepackagedAndroidUtilArraySet : NSObject < JavaUtilCollection, JavaUtilSet > {
 @public
  IOSIntArray *mHashes_;
  IOSObjectArray *mArray_;
  jint mSize_;
  RepackagedAndroidUtilMapCollections *mCollections_;
}

#pragma mark Public

/**
 @brief Create a new empty ArraySet.
 The default capacity of an array map is 0, and will grow once items are added to it.
 */
- (instancetype)init;

/**
 @brief Create a new ArraySet with the mappings from the given ArraySet.
 */
- (instancetype)initWithRepackagedAndroidUtilArraySet:(RepackagedAndroidUtilArraySet *)set;

/**
 
 */
- (instancetype)initWithJavaUtilCollection:(id<JavaUtilCollection>)set;

/**
 @brief Create a new ArraySet with a given initial capacity.
 */
- (instancetype)initWithInt:(jint)capacity;

/**
 @brief Adds the specified object to this set.
 The set is not modified if it already contains the object.
 @param value the object to add.
 @return <code>true</code> if this set is modified, <code>false</code> otherwise.
 @throws ClassCastException when the class of the object is inappropriate for this set.
 */
- (jboolean)addWithId:(id)value;

/**
 @brief Perform a #add(Object) of all values in <var>array</var>
 @param array The array whose contents are to be retrieved.
 */
- (void)addAllWithRepackagedAndroidUtilArraySet:(RepackagedAndroidUtilArraySet *)array;

/**
 @brief Perform an #add(Object) of all values in <var>collection</var>
 @param collection The collection whose contents are to be retrieved.
 */
- (jboolean)addAllWithJavaUtilCollection:(id<JavaUtilCollection>)collection;

/**
 @brief Make the array map empty.
 All storage is released.
 */
- (void)clear;

/**
 @brief Check whether a value exists in the set.
 @param key The value to search for.
 @return Returns true if the value exists, else false.
 */
- (jboolean)containsWithId:(id)key;

/**
 @brief Determine if the array set contains all of the values in the given collection.
 @param collection The collection whose contents are to be checked against.
 @return Returns true if this array set contains a value for every entry in <var>collection</var>, else returns false.
 */
- (jboolean)containsAllWithJavaUtilCollection:(id<JavaUtilCollection>)collection;

/**
 @brief Ensure the array map can hold at least <var>minimumCapacity</var> items.
 */
- (void)ensureCapacityWithInt:(jint)minimumCapacity;

/**
 @brief <p>This implementation returns false if the object is not a set, or if the sets have different sizes.
 Otherwise, for each value in this set, it checks to make sure the value also exists in the other set. If any value doesn't exist, the method returns false; otherwise, it returns true.
 */
- (jboolean)isEqual:(id)object;

/**
 
 */
- (NSUInteger)hash;

/**
 @brief Returns the index of a value in the set.
 @param key The value to search for.
 @return Returns the index of the value if it exists, else a negative integer.
 */
- (jint)indexOfWithId:(id)key;

/**
 @brief Return true if the array map contains no items.
 */
- (jboolean)isEmpty;

/**
 @brief Return an java.util.Iterator over all values in the set.
 <p><b>Note:</b> this is a fairly inefficient way to access the array contents, it requires generating a number of temporary objects and allocates additional state information associated with the container that will remain for the life of the container.</p>
 */
- (id<JavaUtilIterator>)iterator;

/**
 @brief Removes the specified object from this set.
 @param object the object to remove.
 @return <code>true</code> if this set was modified, <code>false</code> otherwise.
 */
- (jboolean)removeWithId:(id)object;

/**
 @brief Perform a #remove(Object) of all values in <var>array</var>
 @param array The array whose contents are to be removed.
 */
- (jboolean)removeAllWithRepackagedAndroidUtilArraySet:(RepackagedAndroidUtilArraySet *)array;

/**
 @brief Remove all values in the array set that exist in the given collection.
 @param collection The collection whose contents are to be used to remove values.
 @return Returns true if any values were removed from the array set, else false.
 */
- (jboolean)removeAllWithJavaUtilCollection:(id<JavaUtilCollection>)collection;

/**
 @brief Remove the key/value mapping at the given index.
 @param index The desired index, must be between 0 and #size() -1.
 @return Returns the value that was stored at this index.
 */
- (id)removeAtWithInt:(jint)index;

/**
 @brief Remove all values in the array set that do <b>not</b> exist in the given collection.
 @param collection The collection whose contents are to be used to determine which values to keep.
 @return Returns true if any values were removed from the array set, else false.
 */
- (jboolean)retainAllWithJavaUtilCollection:(id<JavaUtilCollection>)collection;

/**
 @brief Return the number of items in this array map.
 */
- (jint)size;

- (IOSObjectArray *)toArray;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)array;

/**
 @brief <p>This implementation composes a string by iterating over its values.
 If this set contains itself as a value, the string "(this Set)" will appear in its place.
 */
- (NSString *)description;

/**
 @brief Return the value at the given index in the array.
 @param index The desired index, must be between 0 and #size() -1.
 @return Returns the value stored at the given index.
 */
- (id)valueAtWithInt:(jint)index;

#pragma mark Package-Private


@end

J2OBJC_EMPTY_STATIC_INIT(RepackagedAndroidUtilArraySet)

J2OBJC_FIELD_SETTER(RepackagedAndroidUtilArraySet, mHashes_, IOSIntArray *)
J2OBJC_FIELD_SETTER(RepackagedAndroidUtilArraySet, mArray_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(RepackagedAndroidUtilArraySet, mCollections_, RepackagedAndroidUtilMapCollections *)

FOUNDATION_EXPORT IOSObjectArray *RepackagedAndroidUtilArraySet_mBaseCache_;
J2OBJC_STATIC_FIELD_GETTER(RepackagedAndroidUtilArraySet, mBaseCache_, IOSObjectArray *)
J2OBJC_STATIC_FIELD_SETTER(RepackagedAndroidUtilArraySet, mBaseCache_, IOSObjectArray *)

FOUNDATION_EXPORT jint RepackagedAndroidUtilArraySet_mBaseCacheSize_;
J2OBJC_STATIC_FIELD_GETTER(RepackagedAndroidUtilArraySet, mBaseCacheSize_, jint)
J2OBJC_STATIC_FIELD_REF_GETTER(RepackagedAndroidUtilArraySet, mBaseCacheSize_, jint)

FOUNDATION_EXPORT IOSObjectArray *RepackagedAndroidUtilArraySet_mTwiceBaseCache_;
J2OBJC_STATIC_FIELD_GETTER(RepackagedAndroidUtilArraySet, mTwiceBaseCache_, IOSObjectArray *)
J2OBJC_STATIC_FIELD_SETTER(RepackagedAndroidUtilArraySet, mTwiceBaseCache_, IOSObjectArray *)

FOUNDATION_EXPORT jint RepackagedAndroidUtilArraySet_mTwiceBaseCacheSize_;
J2OBJC_STATIC_FIELD_GETTER(RepackagedAndroidUtilArraySet, mTwiceBaseCacheSize_, jint)
J2OBJC_STATIC_FIELD_REF_GETTER(RepackagedAndroidUtilArraySet, mTwiceBaseCacheSize_, jint)

FOUNDATION_EXPORT void RepackagedAndroidUtilArraySet_init(RepackagedAndroidUtilArraySet *self);

FOUNDATION_EXPORT RepackagedAndroidUtilArraySet *new_RepackagedAndroidUtilArraySet_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void RepackagedAndroidUtilArraySet_initWithInt_(RepackagedAndroidUtilArraySet *self, jint capacity);

FOUNDATION_EXPORT RepackagedAndroidUtilArraySet *new_RepackagedAndroidUtilArraySet_initWithInt_(jint capacity) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void RepackagedAndroidUtilArraySet_initWithRepackagedAndroidUtilArraySet_(RepackagedAndroidUtilArraySet *self, RepackagedAndroidUtilArraySet *set);

FOUNDATION_EXPORT RepackagedAndroidUtilArraySet *new_RepackagedAndroidUtilArraySet_initWithRepackagedAndroidUtilArraySet_(RepackagedAndroidUtilArraySet *set) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void RepackagedAndroidUtilArraySet_initWithJavaUtilCollection_(RepackagedAndroidUtilArraySet *self, id<JavaUtilCollection> set);

FOUNDATION_EXPORT RepackagedAndroidUtilArraySet *new_RepackagedAndroidUtilArraySet_initWithJavaUtilCollection_(id<JavaUtilCollection> set) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(RepackagedAndroidUtilArraySet)

#endif // _RepackagedAndroidUtilArraySet_H_
